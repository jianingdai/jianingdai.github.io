<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CSP并发模型</title>
    <url>/2025/08/15/CSP%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="CSP、Goroutine-与-Channel"><a href="#CSP、Goroutine-与-Channel" class="headerlink" title="CSP、Goroutine 与 Channel"></a>CSP、Goroutine 与 Channel</h1><h1 id="核心理念：通信顺序进程-CSP"><a href="#核心理念：通信顺序进程-CSP" class="headerlink" title="核心理念：通信顺序进程 (CSP)"></a>核心理念：通信顺序进程 (CSP)</h1><p>Go 语言的并发模型基于 <strong>CSP (Communicating Sequential Processes)</strong> 理论。其核心思想是：</p>
<blockquote>
<p>不要通过共享内存来通信；相反，要通过通信来共享内存。</p>
<p>(Do not communicate by sharing memory; instead, share memory by communicating.)</p>
</blockquote>
<p>这种模型通过 <code>Goroutine</code> (执行体) 和 <code>Channel</code> (通信管道) 实现，旨在简化并发编程，降低数据竞争和死锁的风险。</p>
<h1 id="Goroutine：轻量级并发执行体"><a href="#Goroutine：轻量级并发执行体" class="headerlink" title="Goroutine：轻量级并发执行体"></a>Goroutine：轻量级并发执行体</h1><p><code>Goroutine</code> 是 Go 语言并发设计的核心。它是由 Go 运行时管理的轻量级线程。</p>
<ul>
<li><p><strong>启动方式</strong>：使用 <code>go</code> 关键字即可启动一个 Goroutine。</p>
<p>Go</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">go func() &#123;</span><br><span class="line">    fmt.Println(&quot;Hello from Goroutine!&quot;)</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>核心特性：“轻量”</strong></p>
<ul>
<li><strong>微小的栈空间</strong>：每个 Goroutine 启动时仅需约 <strong>2KB</strong> 的栈空间（而操作系统线程通常为 1-2MB）。其栈空间还会根据需要动态增长和收缩。</li>
<li><strong>高效的调度</strong>：Goroutine 的调度由 Go 运行时在用户态完成，采用 <strong>M:N 调度模型</strong>（将 M 个 Goroutine 调度到 N 个系统线程上）。切换成本远低于系统线程，因此可以轻松创建数十万个 Goroutine。</li>
</ul>
</li>
</ul>
<h1 id="Channel：Goroutine-间的通信管道"><a href="#Channel：Goroutine-间的通信管道" class="headerlink" title="Channel：Goroutine 间的通信管道"></a>Channel：Goroutine 间的通信管道</h1><p><code>Channel</code> 是 Goroutine 之间传递数据的类型安全管道，是实践 CSP 模型的关键。</p>
<ul>
<li><strong>创建与操作</strong><ul>
<li><strong>创建</strong>：<code>ch := make(chan int)</code> 创建一个传递 <code>int</code> 类型的无缓冲 Channel。</li>
<li><strong>发送</strong>：<code>ch &lt;- 10</code> 将数据发送到 Channel。</li>
<li><strong>接收</strong>：<code>value := &lt;-ch</code> 从 Channel 接收数据。</li>
</ul>
</li>
<li><strong>阻塞与同步</strong><ul>
<li><strong>无缓冲 Channel</strong>：发送和接收操作是 <strong>同步</strong> 的。发送方会阻塞，直到接收方准备好；反之亦然。这提供了一种无需显式锁的强大同步机制。</li>
<li><strong>缓冲 Channel</strong>：<code>ch := make(chan int, 5)</code> 创建一个容量为 5 的缓冲 Channel。发送操作只有在缓冲区满时才会阻塞，接收操作只有在缓冲区空时才会阻塞。</li>
</ul>
</li>
<li><strong>重要实践与状态</strong><ol>
<li><strong>Channel 的三种状态</strong>：<ul>
<li><code>nil</code>：未初始化的 Channel。对其读写会 <strong>永久阻塞</strong>。</li>
<li><code>open</code>：正常的 Channel，可读可写。</li>
<li><code>closed</code>：已关闭的 Channel。</li>
</ul>
</li>
<li><strong>关闭 Channel</strong><ul>
<li>向已关闭的 Channel <strong>发送</strong>数据会引发 <code>panic</code>。</li>
<li>从已关闭的 Channel <strong>接收</strong>数据永远不会阻塞，会立即返回该类型的 <strong>零值</strong>。</li>
</ul>
</li>
<li><strong>判断 Channel 是否关闭</strong>：使用 <code>value, ok := &lt;-ch</code> 语法。若 <code>ok</code> 为 <code>false</code>，表示 Channel 已关闭且缓冲区为空。</li>
<li><strong>所有权约定</strong>：通常遵循 <strong>“由发送方关闭 Channel”</strong> 的原则。接收方通过 <code>range</code> 或 <code>v, ok</code> 语法来安全地消费数据。</li>
</ol>
</li>
</ul>
<h1 id="select：多路-Channel-复用"><a href="#select：多路-Channel-复用" class="headerlink" title="select：多路 Channel 复用"></a>select：多路 Channel 复用</h1><p><code>select</code> 语句允许一个 Goroutine 同时等待多个 Channel 操作，类似于网络编程中的 <code>select</code> 或 <code>epoll</code>。</p>
<ul>
<li><p><strong>基本用法</strong>：<code>select</code> 会选择第一个准备就绪的 <code>case</code> 执行。如果多个 <code>case</code> 同时就绪，则随机选择一个。</p>
<p>Go</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select &#123;</span><br><span class="line">case msg1 := &lt;-ch1:</span><br><span class="line">    fmt.Println(&quot;Received from ch1:&quot;, msg1)</span><br><span class="line">case ch2 &lt;- msg2:</span><br><span class="line">    fmt.Println(&quot;Sent to ch2&quot;)</span><br><span class="line">default:</span><br><span class="line">    // 如果没有任何 Channel 准备好，则执行 default 分支，实现非阻塞操作</span><br><span class="line">    fmt.Println(&quot;No communication ready&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>常见并发模式</strong></p>
<ul>
<li><p><strong>超时控制</strong></p>
<p>Go</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select &#123;</span><br><span class="line">case res := &lt;-taskChan:</span><br><span class="line">    // 处理结果</span><br><span class="line">case &lt;-time.After(2 * time.Second):</span><br><span class="line">    fmt.Println(&quot;Task timed out!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>优雅退出 (Graceful Shutdown)</strong></p>
<p>Go</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func worker(done &lt;-chan struct&#123;&#125;) &#123;</span><br><span class="line">    for &#123;</span><br><span class="line">        select &#123;</span><br><span class="line">        case &lt;-done: // 接收到退出信号</span><br><span class="line">            fmt.Println(&quot;Worker shutting down...&quot;)</span><br><span class="line">            return</span><br><span class="line">        default:</span><br><span class="line">            // 执行正常工作</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h1 id="传统同步机制：sync-包"><a href="#传统同步机制：sync-包" class="headerlink" title="传统同步机制：sync 包"></a>传统同步机制：<code>sync</code> 包</h1><p>Go 的核心哲学是推荐使用 Channel，但这 <strong>不是强制规则</strong>。<code>sync</code> 包提供了传统的基于共享内存的同步原语。</p>
<ul>
<li><strong>何时使用 <code>sync.Mutex</code> (互斥锁)?</strong><ul>
<li><strong>保护内部状态</strong>：当多个 Goroutine 需要读写一个共享的结构体或变量（如缓存、计数器）时，使用互斥锁来保护这个状态通常比用 Channel 传递状态更简单直接。</li>
<li><strong>性能敏感场景</strong>：对于高频、低延迟的共享数据修改，锁的开销可能低于 Channel 通信（涉及 Goroutine 调度等）。</li>
</ul>
</li>
</ul>
<p><strong>经验法则</strong>：</p>
<ul>
<li><strong>事件通知、任务分发、数据流转</strong> -&gt; 使用 <code>Channel</code>。</li>
<li><strong>保护共享资源的临界区</strong> -&gt; 使用 <code>sync.Mutex</code>。</li>
</ul>
<h1 id="CSP-并发模型的优缺点"><a href="#CSP-并发模型的优缺点" class="headerlink" title="CSP 并发模型的优缺点"></a>CSP 并发模型的优缺点</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol>
<li><strong>简化心智模型</strong>：将并发问题转化为数据流动问题，代码更易读、更直观。</li>
<li><strong>安全性高</strong>：通过所有权转移（数据在 Channel 中传递）和显式同步，大大减少了数据竞争的风险。</li>
<li><strong>高可伸缩性</strong>：基于轻量的 Goroutine，可以轻松构建支持极高并发的系统。</li>
</ol>
<h2 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h2><ol>
<li><strong>性能开销</strong>：对于某些场景，Channel 的通信开销会高于 <code>sync.Mutex</code>。</li>
<li><strong>学习曲线</strong>：需要理解 Channel 的阻塞、缓冲、关闭等机制，避免死锁等问题。</li>
<li><strong>设计复杂性</strong>：在复杂的系统中，过多的 Channel 可能导致“管道地狱”，使数据流难以追踪。</li>
</ol>
]]></content>
      <categories>
        <category>后端开发</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>后端开发</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Go HTTP 服务：从超时、重试、限流到优雅关闭</title>
    <url>/2025/12/23/Go-HTTP-%E6%9C%8D%E5%8A%A1%EF%BC%9A%E4%BB%8E%E8%B6%85%E6%97%B6%E3%80%81%E9%87%8D%E8%AF%95%E3%80%81%E9%99%90%E6%B5%81%E5%88%B0%E4%BC%98%E9%9B%85%E5%85%B3%E9%97%AD/</url>
    <content><![CDATA[<h1 id="Go-HTTP-服务：从超时、重试、限流到优雅关闭"><a href="#Go-HTTP-服务：从超时、重试、限流到优雅关闭" class="headerlink" title="Go HTTP 服务：从超时、重试、限流到优雅关闭"></a>Go HTTP 服务：从超时、重试、限流到优雅关闭</h1><p>做一个稳定的 HTTP 服务，很多人一开始会盯着某一个点，比如“重试要不要做”。但真正落地时你会发现，这些点是按请求链路串起来的：<strong>先定超时预算，再谈重试；有限流兜底，才能扛住重试带来的放大；最后用优雅关闭保证上线&#x2F;下线过程不伤用户。</strong></p>
<p>这篇文章按“请求一进一出”的顺序来走，让每一步都能自然衔接到下一步。</p>
<h2 id="1-先定总预算：端到端超时"><a href="#1-先定总预算：端到端超时" class="headerlink" title="1. 先定总预算：端到端超时"></a>1. 先定总预算：端到端超时</h2><p>如果没有一个明确的“总耗时上限”，下游一旦卡住，你的服务就会被拖死。最常见的做法是：<strong>客户端、服务端和业务内部都设置超时</strong>，并用 <code>context</code> 把预算传下去。</p>
<p>服务端最小配置：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">srv := &amp;http.Server&#123;</span><br><span class="line">	<span class="comment">// 基础监听配置</span></span><br><span class="line">	Addr:              <span class="string">&quot;:8080&quot;</span>,</span><br><span class="line">	Handler:           mux,</span><br><span class="line">	<span class="comment">// 读取请求头、请求体、响应写回的超时控制</span></span><br><span class="line">	ReadHeaderTimeout: <span class="number">3</span> * time.Second,</span><br><span class="line">	ReadTimeout:       <span class="number">5</span> * time.Second,</span><br><span class="line">	WriteTimeout:      <span class="number">10</span> * time.Second,</span><br><span class="line">	<span class="comment">// 空闲连接保活时间</span></span><br><span class="line">	IdleTimeout:       <span class="number">60</span> * time.Second,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端最小配置：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">transport := &amp;http.Transport&#123;</span><br><span class="line">	<span class="comment">// 建连超时 + TCP KeepAlive</span></span><br><span class="line">	DialContext: (&amp;net.Dialer&#123;</span><br><span class="line">		Timeout:   <span class="number">2</span> * time.Second,</span><br><span class="line">		KeepAlive: <span class="number">30</span> * time.Second,</span><br><span class="line">	&#125;).DialContext,</span><br><span class="line">	<span class="comment">// TLS 握手与响应头超时</span></span><br><span class="line">	TLSHandshakeTimeout:   <span class="number">2</span> * time.Second,</span><br><span class="line">	ResponseHeaderTimeout: <span class="number">3</span> * time.Second,</span><br><span class="line">	<span class="comment">// 连接池与空闲连接控制</span></span><br><span class="line">	IdleConnTimeout:       <span class="number">60</span> * time.Second,</span><br><span class="line">	MaxIdleConns:          <span class="number">200</span>,</span><br><span class="line">	MaxIdleConnsPerHost:   <span class="number">20</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">client := &amp;http.Client&#123;</span><br><span class="line">	<span class="comment">// 端到端总超时（兜底）</span></span><br><span class="line">	Timeout:   <span class="number">5</span> * time.Second,</span><br><span class="line">	Transport: transport,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>业务内部要把预算传给下游：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 业务处理的子预算</span></span><br><span class="line">	ctx, cancel := context.WithTimeout(r.Context(), <span class="number">2</span>*time.Second)</span><br><span class="line">	<span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 下游调用必须继承 ctx</span></span><br><span class="line">	resp, err := callDownstream(ctx)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		http.Error(w, err.Error(), http.StatusGatewayTimeout)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	_, _ = w.Write(resp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一步的核心是：<strong>先把时间预算定死</strong>。没有预算，后面的重试和连接池配置都没有意义。</p>
<h2 id="2-在预算内重试：只对可重试错误出手"><a href="#2-在预算内重试：只对可重试错误出手" class="headerlink" title="2. 在预算内重试：只对可重试错误出手"></a>2. 在预算内重试：只对可重试错误出手</h2><p>重试是为了提升成功率，但它也会“吃掉”你的预算。做法是：</p>
<ul>
<li>只重试网络错误、超时、5xx；</li>
<li>POST 要配幂等 key，否则是重复扣款&#x2F;重复写入。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">retry</span><span class="params">(ctx context.Context, max <span class="type">int</span>, fn <span class="keyword">func</span>()</span></span> <span class="type">error</span>) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="comment">// 指数退避，避免瞬时放大流量</span></span><br><span class="line">	backoff := <span class="number">100</span> * time.Millisecond</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; max; i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> err := fn(); err == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="comment">// 等待一段时间后重试</span></span><br><span class="line">		<span class="keyword">case</span> &lt;-time.After(backoff):</span><br><span class="line">			backoff *= <span class="number">2</span></span><br><span class="line">		<span class="comment">// 超时预算耗尽则退出</span></span><br><span class="line">		<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">			<span class="keyword">return</span> ctx.Err()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;retry failed after %d attempts&quot;</span>, max)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例：幂等 key 的重试请求：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">req, _ := http.NewRequestWithContext(ctx, http.MethodPost, url, body)</span><br><span class="line"><span class="comment">// 幂等 key：避免重复写入</span></span><br><span class="line">req.Header.Set(<span class="string">&quot;Idempotency-Key&quot;</span>, uuid.NewString())</span><br><span class="line"></span><br><span class="line">err := retry(ctx, <span class="number">3</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	resp, err := client.Do(req)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">	<span class="comment">// 仅对 5xx 做重试</span></span><br><span class="line">	<span class="keyword">if</span> resp.StatusCode &gt;= <span class="number">500</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;server error: %d&quot;</span>, resp.StatusCode)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>这里和上一步的关系</strong>：重试必须受 <code>context</code> 控制，否则一重试就可能直接超时。</p>
<h2 id="3-入口限流：给“重试放大”留个安全阀"><a href="#3-入口限流：给“重试放大”留个安全阀" class="headerlink" title="3. 入口限流：给“重试放大”留个安全阀"></a>3. 入口限流：给“重试放大”留个安全阀</h2><p>重试会放大流量。如果没有限流，峰值+重试很容易把服务打挂。入口限流是最简单有效的兜底。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> limiter = rate.NewLimiter(<span class="number">100</span>, <span class="number">200</span>) <span class="comment">// 每秒100，桶容量200</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">limitMiddleware</span><span class="params">(next http.Handler)</span></span> http.Handler &#123;</span><br><span class="line">	<span class="keyword">return</span> http.HandlerFunc(<span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">		<span class="comment">// 无令牌则拒绝</span></span><br><span class="line">		<span class="keyword">if</span> !limiter.Allow() &#123;</span><br><span class="line">			http.Error(w, <span class="string">&quot;too many requests&quot;</span>, http.StatusTooManyRequests)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		next.ServeHTTP(w, r)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这里和上一步的关系</strong>：你允许重试，就必须能承受它放大的请求量；限流就是这道保险。</p>
<h2 id="4-连接池与-KeepAlive：把延迟波动压下来"><a href="#4-连接池与-KeepAlive：把延迟波动压下来" class="headerlink" title="4. 连接池与 KeepAlive：把延迟波动压下来"></a>4. 连接池与 KeepAlive：把延迟波动压下来</h2><p>连接池配置会影响“每次请求消耗多少时间”。如果连接池太小，频繁建连会占用你的超时预算；如果太大，资源消耗会被放大。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">transport := &amp;http.Transport&#123;</span><br><span class="line">	<span class="comment">// 连接池上限与空闲时长</span></span><br><span class="line">	MaxIdleConns:        <span class="number">200</span>,</span><br><span class="line">	MaxIdleConnsPerHost: <span class="number">50</span>,</span><br><span class="line">	IdleConnTimeout:     <span class="number">90</span> * time.Second,</span><br><span class="line">	DisableCompression:  <span class="literal">false</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一步和前面的关系是：<strong>连接效率决定了你是否能把预算留给真正的业务处理</strong>。</p>
<h2 id="5-优雅关闭：给在途请求一个“善终”"><a href="#5-优雅关闭：给在途请求一个“善终”" class="headerlink" title="5. 优雅关闭：给在途请求一个“善终”"></a>5. 优雅关闭：给在途请求一个“善终”</h2><p>服务上线&#x2F;下线是常态，如果直接 <code>Close()</code>，会让正在处理的请求直接失败。优雅关闭的思路是：停止接新请求，给在途请求时间完成。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">srv := &amp;http.Server&#123;Addr: <span class="string">&quot;:8080&quot;</span>, Handler: mux&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 非预期退出记录错误</span></span><br><span class="line">	<span class="keyword">if</span> err := srv.ListenAndServe(); err != <span class="literal">nil</span> &amp;&amp; err != http.ErrServerClosed &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;listen error: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">quit := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line">signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)</span><br><span class="line">&lt;-quit</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给在途请求一个收尾时间</span></span><br><span class="line">ctx, cancel := context.WithTimeout(context.Background(), <span class="number">10</span>*time.Second)</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line">_ = srv.Shutdown(ctx)</span><br></pre></td></tr></table></figure>

<p>这里和前面的关系是：<strong>只有在超时、重试、限流都合理时，优雅关闭才不会导致大量失败</strong>。</p>
<h2 id="6-一个完整请求的示例（把流程串起来）"><a href="#6-一个完整请求的示例（把流程串起来）" class="headerlink" title="6. 一个完整请求的示例（把流程串起来）"></a>6. 一个完整请求的示例（把流程串起来）</h2><p>假设你的订单服务 <code>CreateOrder</code> 调用库存服务 <code>ReserveStock</code>：</p>
<ul>
<li>总超时 800ms；</li>
<li>下游调用 300ms 超时；</li>
<li>最多重试 1 次，退避 100ms；</li>
<li>入口限流 200 rps，桶 400。</li>
</ul>
<p>请求路径就是：</p>
<ol>
<li>先限流，确保服务不会被瞬时流量冲垮；  </li>
<li>进入 handler，开启 800ms 的总预算；  </li>
<li>调库存时用 300ms 子预算；  </li>
<li>如果失败且预算够，再重试一次；  </li>
<li>预算不够就快速失败；  </li>
<li>服务下线时，优雅关闭让在途请求收尾。</li>
</ol>
<p>这就是“超时→重试→限流→优雅关闭”的真实关系：每一步都为下一步留出空间。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>把这些机制按顺序串起来，你的服务就不会“只在某一个点上强、整体却不稳定”。下一步你可以在此基础上增加可观测性（日志&#x2F;指标&#x2F;trace）和熔断策略，让整条链路更易于排查和自愈。</p>
]]></content>
      <categories>
        <category>后端开发</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>HTTP</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>AI网关架构设计</title>
    <url>/2025/08/15/AI%E7%BD%91%E5%85%B3%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="AI网关架构设计"><a href="#AI网关架构设计" class="headerlink" title="AI网关架构设计"></a>AI网关架构设计</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在人工智能技术快速演进的时代背景下，大型语言模型（LLMs）和 AI 智能体已成为各类应用的核心组件，引发 AI 相关 API 流量的指数级增长。随着企业将 AI 深度整合至业务流程，如何有效管理和优化 AI 驱动的交互正成为新的技术挑战。</p>
<p>以 DeepSeek 为代表的开源 LLM 技术兴起，使得企业不仅能够使用 OpenAI、Azure 等 SaaS 化 LLM 服务，更可在私有化环境中部署 LLM 模型，形成混合云架构。这一技术范式迁移带来了数据安全、多 LLM 适配管理、性能优化和可靠性保障等系列挑战，传统 API 网关向专业化 <strong>AI 网关</strong> 的演进势在必行。</p>
<hr>
<h2 id="详细设计与实施方案"><a href="#详细设计与实施方案" class="headerlink" title="详细设计与实施方案"></a>详细设计与实施方案</h2><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><h4 id="功能需求"><a href="#功能需求" class="headerlink" title="功能需求"></a>功能需求</h4><table>
<thead>
<tr>
<th>需求类别</th>
<th>功能点描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>统一接入</strong></td>
<td>提供单一、稳定、兼容 OpenAI 规范的 API 入口，屏蔽后端厂商差异。</td>
</tr>
<tr>
<td><strong>认证授权</strong></td>
<td>对接入的业务系统进行身份认证，并基于角色进行细粒度的模型访问授权。</td>
</tr>
<tr>
<td><strong>密钥管理</strong></td>
<td>集中、安全地管理所有下游厂商的 API Key，业务系统无需接触真实密钥。</td>
</tr>
<tr>
<td><strong>智能路由</strong></td>
<td>支持基于权重、延迟、成本、可用性的动态路由策略和故障自动切换。</td>
</tr>
<tr>
<td><strong>流量控制</strong></td>
<td>实现基于客户端、模型的 QPS 限流和基于 Token 用量的周期性配额管理。</td>
</tr>
<tr>
<td><strong>可观测性</strong></td>
<td>提供详细的调用日志、多维度监控指标（延迟、Token、费用）和可视化仪表盘。</td>
</tr>
<tr>
<td><strong>提示词工程</strong></td>
<td>（高级）支持提示词模板、动态上下文注入和 RAG（检索增强生成）能力。</td>
</tr>
</tbody></table>
<h4 id="性能与安全指标"><a href="#性能与安全指标" class="headerlink" title="性能与安全指标"></a>性能与安全指标</h4><table>
<thead>
<tr>
<th>需求类别</th>
<th>指标要求</th>
</tr>
</thead>
<tbody><tr>
<td><strong>性能</strong></td>
<td><strong>高吞吐</strong>：初始目标 &gt;1000 QPS，可水平扩展。<strong>低延迟</strong>：网关自身引入的延迟 P99 &lt; 50ms。</td>
</tr>
<tr>
<td><strong>安全性</strong></td>
<td>密钥不落地、传输全程加密、严格的访问控制、防注入攻击。</td>
</tr>
<tr>
<td><strong>可用性</strong></td>
<td>关键组件无单点故障，支持集群化部署，目标可用性 &gt; 99.95%。</td>
</tr>
<tr>
<td><strong>可扩展性</strong></td>
<td>采用插件化适配器模式，接入新厂商或新功能时对核心代码无侵入。</td>
</tr>
</tbody></table>
<hr>
<h3 id="系统架构设计：微服务架构"><a href="#系统架构设计：微服务架构" class="headerlink" title="系统架构设计：微服务架构"></a>系统架构设计：微服务架构</h3><h4 id="系统架构图"><a href="#系统架构图" class="headerlink" title="系统架构图"></a>系统架构图</h4><p><img data-src="https://raw.githubusercontent.com/jianingdai/Blog_img/main/img202508151750302.png" alt="image-20250815175040206"></p>
<hr>
<h3 id="微服务职责划分"><a href="#微服务职责划分" class="headerlink" title="微服务职责划分"></a>微服务职责划分</h3><ol>
<li><p><strong>AI Gateway Core（网关核心）</strong></p>
<ul>
<li><strong>职责</strong>：所有业务流量唯一入口，处理同步低延迟请求（认证、授权、限流、路由、协议适配、下游调用），支持高级功能（如 RAG）时同步调用 Orchestration Service。请求处理后将审计事件异步发布到消息中间件。</li>
<li><strong>特性</strong>：无状态、轻量级、极致性能优化，属于数据平面。</li>
</ul>
</li>
<li><p><strong>Orchestration Service（编排服务）</strong></p>
<ul>
<li><strong>职责</strong>：处理复杂提示词工程任务，实现 RAG 逻辑、提示词模板渲染、动态上下文注入等。</li>
<li><strong>特性</strong>：可独立伸缩，适合计算密集型任务。</li>
</ul>
</li>
<li><p><strong>Observability Service（可观测性服务）</strong></p>
<ul>
<li><strong>职责</strong>：异步消费审计事件，执行高延迟或批处理任务（如费用计算、日志写入、数据聚合），实现基于 Token 用量的配额检查与更新。</li>
<li><strong>特性</strong>：日志与指标处理与核心请求路径解耦，保障性能。</li>
</ul>
</li>
<li><p><strong>Management Service（管理服务）</strong></p>
<ul>
<li><strong>职责</strong>：提供 &#x2F;api&#x2F;admin&#x2F;v1 管理接口，负责所有配置的 CRUD，包括客户端、路由、上游、权限等。配置变更时清除缓存或通知其他服务。</li>
<li><strong>特性</strong>：控制平面，可用性不影响线上业务请求转发。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="接口设计（API-Specification）"><a href="#接口设计（API-Specification）" class="headerlink" title="接口设计（API Specification）"></a>接口设计（API Specification）</h3><h4 id="对外-API"><a href="#对外-API" class="headerlink" title="对外 API"></a>对外 API</h4><ul>
<li><p><strong>通用规范</strong>：</p>
<ul>
<li><strong>Endpoint前缀</strong>：<code>/v1</code></li>
<li><strong>消息认证</strong>：HTTP Header <code>Authorization: Bearer &lt;gateway-api-key&gt;</code></li>
<li><strong>数据格式</strong>：<code>application/json</code></li>
</ul>
</li>
<li><p><strong>POST &#x2F;v1&#x2F;chat&#x2F;completions</strong></p>
<ul>
<li><p><strong>功能</strong>：与对话型大语言模型交互的核心入口，支持标准和流式（SSE）模式。</p>
</li>
<li><p><strong>请求头</strong>：</p>
<table>
<thead>
<tr>
<th>Header</th>
<th>Type</th>
<th>必填</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Authorization</td>
<td>string</td>
<td>是</td>
<td>Bearer <code>&lt;gateway-api-key&gt;</code></td>
</tr>
<tr>
<td>Content-Type</td>
<td>string</td>
<td>是</td>
<td>必须为 application&#x2F;json</td>
</tr>
<tr>
<td>X-Request-ID</td>
<td>string</td>
<td>否</td>
<td>建议传入 UUID，用于全链路日志追踪</td>
</tr>
</tbody></table>
</li>
<li><p><strong>请求体</strong>：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>类型</th>
<th>必填</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>model</td>
<td>string</td>
<td>是</td>
<td>逻辑模型名称，如 “gpt-4-turbo”</td>
</tr>
<tr>
<td>messages</td>
<td>array</td>
<td>是</td>
<td>对话消息对象数组，不能为空</td>
</tr>
<tr>
<td>messages[].role</td>
<td>string</td>
<td>是</td>
<td>角色，system&#x2F;user&#x2F;assistant</td>
</tr>
<tr>
<td>messages[].content</td>
<td>string</td>
<td>是</td>
<td>消息内容</td>
</tr>
<tr>
<td>stream</td>
<td>boolean</td>
<td>否</td>
<td>是否流式返回，默认 false</td>
</tr>
<tr>
<td>temperature</td>
<td>number</td>
<td>否</td>
<td>0-2，控制输出随机性，默认 1</td>
</tr>
<tr>
<td>max_tokens</td>
<td>integer</td>
<td>否</td>
<td>生成内容最大长度（token数）</td>
</tr>
<tr>
<td>user</td>
<td>string</td>
<td>否</td>
<td>终端用户唯一标识，建议传入</td>
</tr>
</tbody></table>
</li>
<li><p><strong>响应</strong>：</p>
<ul>
<li>200 OK（标准&#x2F;流式）：请求成功</li>
<li>400 Bad Request：请求体格式错误</li>
<li>401 Unauthorized：认证失败</li>
<li>403 Forbidden：无权访问该模型</li>
<li>429 Too Many Requests：速率或配额超限</li>
<li>500 Internal Server Error：网关内部错误</li>
<li>503 Service Unavailable：所有下游服务均不可用</li>
</ul>
</li>
<li><p><strong>响应体 Schema（200 OK, 非流式）</strong>：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;chatcmpl-gateway-abc123xyz&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;object&quot;</span><span class="punctuation">:</span> <span class="string">&quot;chat.completion&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;created&quot;</span><span class="punctuation">:</span> <span class="number">1677652288</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;model&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gpt-4-turbo&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;choices&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;role&quot;</span><span class="punctuation">:</span> <span class="string">&quot;assistant&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="string">&quot;好的，这是一个关于...&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;finish_reason&quot;</span><span class="punctuation">:</span> <span class="string">&quot;stop&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;usage&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;prompt_tokens&quot;</span><span class="punctuation">:</span> <span class="number">30</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;completion_tokens&quot;</span><span class="punctuation">:</span> <span class="number">1500</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;total_tokens&quot;</span><span class="punctuation">:</span> <span class="number">1530</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;debug_info&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;request_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;uuid-v4-goes-here&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;actual_upstream&quot;</span><span class="punctuation">:</span> <span class="string">&quot;azure-gpt4-eastus-deployment-1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;strategy_used&quot;</span><span class="punctuation">:</span> <span class="string">&quot;latency-based&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;gateway_latency_ms&quot;</span><span class="punctuation">:</span> <span class="number">45</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;upstream_latency_ms&quot;</span><span class="punctuation">:</span> <span class="number">1850</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>POST &#x2F;v1&#x2F;embeddings</strong></p>
<ul>
<li><strong>功能</strong>：文本转向量</li>
<li><strong>请求体</strong>：<code>&#123; &quot;model&quot;: &quot;text-embedding-ada-002&quot;, &quot;input&quot;: [&quot;text1&quot;, &quot;text2&quot;] &#125;</code></li>
<li><strong>响应体</strong>：<code>&#123; &quot;object&quot;: &quot;list&quot;, &quot;data&quot;: [ &#123; &quot;object&quot;: &quot;embedding&quot;, ... &#125; ], &quot;model&quot;: &quot;...&quot;, &quot;usage&quot;: &#123; ... &#125; &#125;</code></li>
</ul>
</li>
</ul>
<h4 id="管理-API"><a href="#管理-API" class="headerlink" title="管理 API"></a>管理 API</h4><ul>
<li><p><strong>通用规范</strong>：</p>
<ul>
<li><strong>Endpoint Prefix</strong>：<code>/api/admin/v1</code></li>
<li><strong>Authentication</strong>：独立 Admin 认证机制（如内部 JWT）</li>
</ul>
</li>
<li><p><strong>资源：Clients（客户端）</strong></p>
<ul>
<li><code>POST /clients</code>：创建客户端</li>
<li><code>GET /clients</code>：查询客户端列表（支持分页）</li>
<li><code>GET /clients/&#123;clientId&#125;</code>：获取客户端详情</li>
<li><code>PUT /clients/&#123;clientId&#125;</code>：更新客户端信息</li>
<li><code>DELETE /clients/&#123;clientId&#125;</code>：逻辑删除客户端</li>
<li><code>POST /clients/&#123;clientId&#125;/credentials</code>：创建凭证</li>
<li><code>DELETE /clients/&#123;clientId&#125;/credentials/&#123;keyId&#125;</code>：吊销凭证</li>
</ul>
</li>
<li><p><strong>资源：Routes &amp; Upstreams（路由与上游）</strong></p>
<ul>
<li><code>POST /routes</code>：创建路由</li>
<li><code>GET /routes</code>：查询路由列表</li>
<li><code>PUT /routes/&#123;routeId&#125;</code>：更新路由</li>
<li><code>DELETE /routes/&#123;routeId&#125;</code>：删除路由</li>
<li><code>POST /routes/&#123;routeId&#125;/upstreams</code>：添加上游</li>
<li><code>GET /routes/&#123;routeId&#125;/upstreams</code>：获取某路由下所有上游</li>
<li><code>GET /upstreams/health</code>：实时返回所有上游健康检查状态</li>
<li><code>PUT /upstreams/&#123;upstreamId&#125;</code>：更新上游</li>
<li><code>DELETE /upstreams/&#123;upstreamId&#125;</code>：移除上游</li>
</ul>
</li>
</ul>
<hr>
<h3 id="安全设计"><a href="#安全设计" class="headerlink" title="安全设计"></a>安全设计</h3><ol>
<li><strong>访问控制与身份认证</strong>：为每个业务系统生成独立 API Key，使用 bcrypt 哈希加盐存储。通过 RBAC 精确控制 Key 可访问的模型和功能。</li>
<li><strong>密钥管理</strong>：所有下游厂商 API Key 由 Vault 加密存储和生命周期管理，服务通过 AppRole 动态获取，杜绝明文泄露。</li>
<li><strong>传输安全</strong>：所有对外及服务间通信强制使用 TLS 1.2+ 加密。</li>
<li><strong>微服务间安全（零信任网络）</strong>：引入服务网格（如 Istio），自动提供双向 TLS（mTLS）和精细化服务间授权策略。</li>
</ol>
<hr>
<h3 id="性能与高可用性设计"><a href="#性能与高可用性设计" class="headerlink" title="性能与高可用性设计"></a>性能与高可用性设计</h3><h4 id="消息中间件解耦与削峰"><a href="#消息中间件解耦与削峰" class="headerlink" title="消息中间件解耦与削峰"></a>消息中间件解耦与削峰</h4><ul>
<li><strong>选型</strong>：Apache Kafka 或 Pulsar。</li>
<li><strong>作用</strong>：Gateway Core 快速发布审计事件到 Kafka，实现与 Observability Service 解耦，保障低延迟和最终一致性。</li>
</ul>
<h4 id="流量控制的实现"><a href="#流量控制的实现" class="headerlink" title="流量控制的实现"></a>流量控制的实现</h4><ol>
<li><strong>限流中间件</strong>：<ul>
<li>在 CoreGW 中引入限流中间件，采用基于 Redis 的令牌桶算法实现。</li>
<li>每个客户端的 QPS 限流规则可动态配置，支持精细化控制。</li>
</ul>
</li>
<li><strong>配额管理</strong>：<ul>
<li>配合 <code>usage_quotas</code> 表，定期将配额数据同步到 Redis 缓存，减少数据库查询压力。</li>
<li>在请求处理时，实时检查缓存中的配额数据，确保 Token 用量不超限。</li>
</ul>
</li>
</ol>
<h4 id="可观测性与监控"><a href="#可观测性与监控" class="headerlink" title="可观测性与监控"></a>可观测性与监控</h4><ol>
<li><strong>定义关键性能指标（KPIs）</strong>：<ul>
<li><strong>请求延迟</strong>：监控网关的 P50、P90、P99 延迟，确保性能符合预期。</li>
<li><strong>成功率</strong>：统计 HTTP 状态码分布（如 2xx、4xx、5xx），监控请求成功率。</li>
<li><strong>上游服务健康状态</strong>：定期检查上游服务的可用性和响应时间。</li>
<li><strong>流量指标</strong>：监控每个客户端的 QPS 和 Token 用量，防止超限。</li>
<li><strong>系统资源</strong>：监控 CPU、内存、磁盘 I&#x2F;O 和网络带宽使用情况。</li>
</ul>
</li>
<li><strong>使用监控工具</strong>：<ul>
<li><strong>Prometheus</strong>：采集系统和应用的监控指标。</li>
<li><strong>Grafana</strong>：可视化监控数据，创建实时仪表盘。</li>
<li><strong>Alertmanager</strong>：结合 Prometheus 设置告警规则，及时通知异常情况。</li>
</ul>
</li>
<li><strong>实现细节</strong>：<ul>
<li>在 CoreGW 和 Observability Service 中集成 Prometheus Exporter，暴露监控指标。</li>
<li>配置 Grafana 仪表盘，展示关键性能指标（如延迟、成功率、流量）。</li>
<li>设置告警规则（如延迟超过阈值、成功率低于 99%），通过邮件或短信通知运维团队。</li>
</ul>
</li>
</ol>
<h4 id="高并发场景下的性能优化"><a href="#高并发场景下的性能优化" class="headerlink" title="高并发场景下的性能优化"></a>高并发场景下的性能优化</h4><ol>
<li><strong>连接池与复用</strong>：<ul>
<li>在 CoreGW 中使用连接池（如 gRPC 和 HTTP 的连接复用）。</li>
<li>配置全局 <code>http.Client</code>，优化 <code>http.Transport</code> 参数以支持高并发。</li>
<li>示例代码：<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">transport := &amp;http.Transport&#123;</span><br><span class="line">    MaxIdleConns:        <span class="number">200</span>,</span><br><span class="line">    MaxIdleConnsPerHost: <span class="number">100</span>,</span><br><span class="line">    IdleConnTimeout:     <span class="number">90</span> * time.Second,</span><br><span class="line">&#125;</span><br><span class="line">client := &amp;http.Client&#123;Transport: transport&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>多级缓存</strong>：<ul>
<li>对于频繁访问的数据（如路由规则、配额），引入多级缓存：<ul>
<li><strong>L1 内存缓存</strong>：使用高性能内存缓存（如  <code>go-cache</code>）。</li>
<li><strong>L2 分布式缓存</strong>：使用 Redis 存储共享数据，支持多实例访问。</li>
</ul>
</li>
<li>缓存策略：<ul>
<li><strong>Cache-Aside 模式</strong>：先查询缓存，未命中时查询数据库并更新缓存。</li>
<li>配置变更时主动失效缓存，确保数据一致性。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="灾备与容灾设计"><a href="#灾备与容灾设计" class="headerlink" title="灾备与容灾设计"></a>灾备与容灾设计</h4><ol>
<li><strong>跨区域数据库主从同步</strong>：<ul>
<li>配置 MySQL 的主从复制，支持跨区域同步，提升数据可用性。</li>
<li>使用异步复制模式，确保主库性能不受影响。</li>
</ul>
</li>
<li><strong>定期备份</strong>：<ul>
<li>定期备份 Redis 和 MySQL 数据库，确保数据在灾难场景下可恢复。</li>
<li>备份策略：<ul>
<li><strong>Redis</strong>：使用 <code>RDB</code> 和 <code>AOF</code> 文件，定期上传到对象存储（如 AWS S3）。</li>
<li><strong>MySQL</strong>：使用 <code>mysqldump</code> 或 <code>xtrabackup</code> 工具，生成全量和增量备份。</li>
</ul>
</li>
</ul>
</li>
<li><strong>容灾演练</strong>：<ul>
<li>定期进行容灾演练，验证备份数据的可用性和恢复流程的有效性。</li>
</ul>
</li>
<li><strong>多区域部署</strong>：<ul>
<li>在多个区域部署关键服务（如 CoreGW 和 Redis），实现跨区域容灾。</li>
<li>使用负载均衡器（如 AWS ALB 或 GCP Load Balancer）实现流量切换。</li>
</ul>
</li>
</ol>
<h4 id="内存与-GC-优化"><a href="#内存与-GC-优化" class="headerlink" title="内存与 GC 优化"></a>内存与 GC 优化</h4><ul>
<li>高频大对象（如 <code>[]byte buffer</code>）用 <code>sync.Pool</code> 复用，降低 GC 压力。</li>
<li>尽量用 <code>io.Reader</code>&#x2F;<code>io.Writer</code> 流式处理，避免一次性读入大数据。</li>
</ul>
<hr>
<h3 id="扩展性设计"><a href="#扩展性设计" class="headerlink" title="扩展性设计"></a>扩展性设计</h3><ol>
<li><p><strong>功能扩展（插件化）</strong></p>
<ul>
<li>Gateway Core 协议适配器插件化，支持新厂商仅需开发 Adapter 插件并部署，无需改动核心代码</li>
</ul>
</li>
<li><p><strong>系统扩展（差异化伸缩）</strong></p>
<ul>
<li>微服务架构允许各组件独立扩容</li>
<li>API 请求量大时独立扩容 Gateway Core</li>
<li>RAG 需求大时独立扩容 Orchestration Service</li>
<li>日志量大时增加 Observability Service 实例和 Kafka 分区</li>
<li>差异化伸缩高效应对复杂负载</li>
</ul>
</li>
</ol>
<hr>
<ul>
<li>如果大量业务使用RAG，可以<strong>独立扩容Orchestration Service的Pod数量</strong>。</li>
<li>如果日志量巨大，可以<strong>增加Observability Service的消费者实例和Kafka的分区数</strong>。</li>
<li>这种<strong>差异化伸缩</strong>能力是应对复杂多变负载的最高效方式。</li>
</ul>
<hr>
<h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2><p>AI 网关核心数据库采用 MySQL 8.0+，结合 Redis 做缓存。以下为 MySQL 版本的 ER 图、表结构（DDL）、关系与索引设计。</p>
<h3 id="ER-图"><a href="#ER-图" class="headerlink" title="ER 图"></a>ER 图</h3><p><img data-src="https://raw.githubusercontent.com/jianingdai/Blog_img/main/img202508161741870.png" alt="image-20250816174111703"></p>
<pre class="mermaid">erDiagram
    clients {
        string id PK "UUID (CHAR 36)"
        string name "唯一 (VARCHAR 255)"
        string description "TEXT"
        boolean enabled "TINYINT"
        datetime created_at "TIMESTAMP"
        datetime updated_at "TIMESTAMP"
    }
    client_credentials {
        string id PK "UUID (CHAR 36)"
        string client_id FK "CHAR 36"
        string api_key_prefix "唯一 (VARCHAR 8)"
        string api_key_hash "VARCHAR 255"
        string role "VARCHAR 255"
        boolean revoked "TINYINT"
        datetime created_at "TIMESTAMP"
        datetime revoked_at "TIMESTAMP"
    }
    models {
        string id PK "UUID (CHAR 36)"
        string name "唯一 (VARCHAR 255)"
        string description "TEXT"
        boolean enabled "TINYINT"
        datetime created_at "TIMESTAMP"
    }
    routes {
        string id PK "UUID (CHAR 36)"
        string name "唯一 (VARCHAR 255)"
        string model_id FK "CHAR 36"
        string header_match "VARCHAR 255"
        string path_match "VARCHAR 255"
        string other_conditions "JSON"
        boolean enabled "TINYINT"
        datetime created_at "TIMESTAMP"
    }
    upstreams {
        string id PK "UUID (CHAR 36)"
        string name "唯一 (VARCHAR 255)"
        string type "VARCHAR 50"
        string config "JSON"
        boolean enabled "TINYINT"
        datetime created_at "TIMESTAMP"
    }
    route_upstreams {
        string id PK "UUID (CHAR 36)"
        string route_id FK "CHAR 36"
        string upstream_id FK "CHAR 36"
        int weight "INT"
    }
    audit_logs {
        int id PK "AUTO_INCREMENT (BIGINT)"
        string request_id "CHAR 36"
        string client_id FK "CHAR 36"
        string credential_id FK "CHAR 36"
        string route_id FK "CHAR 36"
        string upstream_id FK "CHAR 36"
        string request_body "JSON"
        string response_body "JSON"
        int prompt_tokens "INT"
        int completion_tokens "INT"
        int total_tokens "INT"
        float cost "DECIMAL 18,9"
        datetime created_at "TIMESTAMP"
    }
    usage_quotas {
        string id PK "UUID (CHAR 36)"
        string client_id FK "CHAR 36"
        string model_id FK "CHAR 36"
        string period "ENUM daily/monthly"
        date period_start "DATE"
        int used_tokens "BIGINT"
        int quota_tokens "BIGINT"
        datetime updated_at "TIMESTAMP"
    }

    clients ||--o{ client_credentials : has
    clients ||--o{ audit_logs : has
    clients ||--o{ usage_quotas : has
    client_credentials ||--o{ audit_logs : used_by
    models ||--o{ routes : supports
    models ||--o{ usage_quotas : counted_by
    routes ||--o{ route_upstreams : maps
    upstreams ||--o{ route_upstreams : mapped
    routes ||--o{ audit_logs : logs
    upstreams ||--o{ audit_logs : logs</pre>

<h3 id="详细表结构说明"><a href="#详细表结构说明" class="headerlink" title="详细表结构说明"></a>详细表结构说明</h3><p>以下为各表的设计与约束说明，包含设计思想和理由，具体 DDL 实现由数据库工程师负责。</p>
<ol>
<li><strong>clients（接入方&#x2F;业务系统）</strong></li>
</ol>
<ul>
<li><strong>用途</strong>：记录接入业务系统的基本信息及启用状态。</li>
<li><strong>主要字段</strong>：<ul>
<li><code>id</code>：主键，UUID。</li>
<li><code>name</code>：客户端名称，需全局唯一。</li>
<li><code>description</code>：可选的文本描述。</li>
<li><code>enabled</code>：布尔值，标识是否启用。</li>
<li><code>created_at</code> &#x2F; <code>updated_at</code>：记录创建和更新时间。</li>
</ul>
</li>
<li><strong>约束与设计要点</strong>：<ul>
<li><code>name</code> 字段需唯一。</li>
<li>推荐保留软删除策略（如需），由业务逻辑层控制。</li>
</ul>
</li>
<li><strong>设计思想</strong>：记录接入系统的基本信息，作为其他表的核心关联点。</li>
<li><strong>设计理由</strong>：<ul>
<li>通过 <code>id</code> 唯一标识每个接入方，便于扩展和管理。</li>
<li><code>name</code> 唯一性确保接入方名称不冲突，方便查询和识别。</li>
<li><code>enabled</code> 字段支持快速启停接入方，灵活控制接入权限。</li>
</ul>
</li>
</ul>
<ol start="2">
<li><strong>client_credentials（API Key&#x2F;凭证）</strong></li>
</ol>
<ul>
<li><strong>用途</strong>：管理每个客户端的访问凭证。</li>
<li><strong>主要字段</strong>：<ul>
<li><code>id</code>：主键，UUID。</li>
<li><code>client_id</code>：外键，关联 <code>clients.id</code>。</li>
<li><code>api_key_prefix</code>：API Key 前缀，唯一，用于快速定位凭证。</li>
<li><code>api_key_hash</code>：API Key 的哈希值（bcrypt），不存储明文。</li>
<li><code>role</code>：角色或权限域，与 RBAC 策略配合使用。</li>
<li><code>revoked</code>：布尔值，标识是否吊销。</li>
<li><code>created_at</code> &#x2F; <code>revoked_at</code>：记录凭证的生命周期时间戳。</li>
</ul>
</li>
<li><strong>约束与设计要点</strong>：<ul>
<li><code>api_key_prefix</code> 字段需唯一。</li>
<li>建议开启级联删除（删除 <code>client</code> 时清理其凭证），或由服务层保障一致性。</li>
</ul>
</li>
<li><strong>设计思想</strong>：为每个接入方生成独立的访问凭证，支持多 Key 和权限控制。</li>
<li><strong>设计理由</strong>：<ul>
<li><code>api_key_prefix</code> 提供快速定位凭证的能力，避免存储明文。</li>
<li><code>role</code> 字段结合 RBAC 实现细粒度权限控制。</li>
<li>支持吊销机制（<code>revoked</code>），确保凭证的安全性和生命周期管理。</li>
</ul>
</li>
</ul>
<ol start="3">
<li><strong>models（逻辑模型）</strong></li>
</ol>
<ul>
<li><strong>用途</strong>：记录支持的逻辑模型（如 GPT-4、嵌入模型等）。</li>
<li><strong>主要字段</strong>：<ul>
<li><code>id</code>：主键，UUID。</li>
<li><code>name</code>：模型名称，需唯一。</li>
<li><code>description</code>：可选的文本描述。</li>
<li><code>enabled</code>：布尔值，标识是否启用。</li>
<li><code>created_at</code>：记录创建时间。</li>
</ul>
</li>
<li><strong>约束与设计要点</strong>：<ul>
<li><code>name</code> 字段需唯一。</li>
<li>与 <code>routes</code> 和 <code>usage_quotas</code> 表存在一对多关联。</li>
</ul>
</li>
<li><strong>设计思想</strong>：统一管理支持的逻辑模型，作为路由和配额的核心关联点。</li>
<li><strong>设计理由</strong>：<ul>
<li><code>name</code> 唯一性确保模型名称不冲突，便于路由规则的匹配。</li>
<li><code>enabled</code> 字段支持快速启停模型，灵活控制模型的可用性。</li>
</ul>
</li>
</ul>
<ol start="4">
<li><strong>routes（路由规则）</strong></li>
</ol>
<ul>
<li><strong>用途</strong>：定义 API 请求的匹配规则及转发逻辑。</li>
<li><strong>主要字段</strong>：<ul>
<li><code>id</code>：主键，UUID。</li>
<li><code>name</code>：路由名称，需唯一。</li>
<li><code>model_id</code>：外键，关联 <code>models.id</code>。</li>
<li><code>header_match</code>：存储请求头匹配规则。</li>
<li><code>path_match</code>：存储路径匹配规则。</li>
<li><code>other_conditions</code>：存储其他复杂匹配条件（如 JSON 格式）。</li>
<li><code>enabled</code>：布尔值，标识是否启用。</li>
<li><code>created_at</code>：记录创建时间。</li>
</ul>
</li>
<li><strong>约束与设计要点</strong>：<ul>
<li><code>name</code> 字段需唯一。</li>
<li>高频查询字段（如 <code>header_match</code> 和 <code>path_match</code>）通过结构化存储并建立索引，提升查询效率。</li>
<li>对于复杂的匹配条件，仍可使用 <code>other_conditions</code> 字段存储 JSON 数据。</li>
</ul>
</li>
<li><strong>设计思想</strong>：定义请求的匹配规则和转发逻辑，支持动态配置。</li>
<li><strong>设计理由</strong>：<ul>
<li>将高频查询字段（如 <code>header_match</code> 和 <code>path_match</code>）结构化存储，避免 JSON 查询性能瓶颈。</li>
<li>对复杂的匹配条件保留 JSON 存储的灵活性，兼顾性能与扩展性。</li>
<li>路由规则存储在数据库中，支持动态更新，无需重启服务。</li>
</ul>
</li>
</ul>
<ol start="5">
<li><strong>upstreams（下游服务商&#x2F;模型实例）</strong></li>
</ol>
<ul>
<li><strong>用途</strong>：记录下游 LLM 服务实例及其类型。</li>
<li><strong>主要字段</strong>：<ul>
<li><code>id</code>：主键，UUID。</li>
<li><code>name</code>：上游名称，需唯一。</li>
<li><code>type</code>：服务类型（如 OpenAI、Azure、私有模型等）。</li>
<li><code>config</code>：JSON 格式，存储实例配置（如 endpoint、region 等）。</li>
<li><code>enabled</code>：布尔值，标识是否启用。</li>
<li><code>created_at</code>：记录创建时间。</li>
</ul>
</li>
<li><strong>约束与设计要点</strong>：<ul>
<li><code>name</code> 字段需唯一。</li>
<li>敏感密钥不落地，<code>config</code> 中仅存储非敏感信息或密钥引用标识。</li>
</ul>
</li>
<li><strong>设计思想</strong>：统一管理下游服务实例，支持多厂商和多实例配置。</li>
<li><strong>设计理由</strong>：<ul>
<li><code>type</code> 字段区分不同厂商（如 OpenAI、Azure），便于运营和运维。</li>
<li><code>config</code> 使用 JSON 存储实例配置，支持灵活扩展。</li>
<li><code>enabled</code> 字段支持快速启停实例，便于故障隔离。</li>
</ul>
</li>
</ul>
<ol start="6">
<li><strong>route_upstreams（路由-上游映射）</strong></li>
</ol>
<ul>
<li><strong>用途</strong>：定义 <code>routes</code> 与 <code>upstreams</code> 的多对多关系，并支持加权。</li>
<li><strong>主要字段</strong>：<ul>
<li><code>id</code>：主键，UUID。</li>
<li><code>route_id</code>：外键，关联 <code>routes.id</code>。</li>
<li><code>upstream_id</code>：外键，关联 <code>upstreams.id</code>。</li>
<li><code>weight</code>：整数，表示权重（默认值为 100）。</li>
</ul>
</li>
<li><strong>约束与设计要点</strong>：<ul>
<li><code>route_id</code> + <code>upstream_id</code> 需唯一。</li>
<li>可按需开启对 <code>route</code> 的级联删除。</li>
</ul>
</li>
<li><strong>设计思想</strong>：实现路由与上游服务的多对多关系，支持加权路由。</li>
<li><strong>设计理由</strong>：<ul>
<li><code>weight</code> 字段支持负载均衡和流量分配。</li>
<li>通过 <code>route_id</code> 和 <code>upstream_id</code> 唯一性约束，避免重复映射。</li>
</ul>
</li>
</ul>
<ol start="7">
<li><strong>audit_logs（调用审计日志）</strong></li>
</ol>
<ul>
<li><strong>用途</strong>：记录 API 调用的请求、响应、Token 用量及费用，支撑审计、计费与分析。</li>
<li><strong>主要字段</strong>：<ul>
<li><code>id</code>：自增主键（适合高写入场景）。</li>
<li><code>request_id</code>：请求链路 ID（UUID）。</li>
<li><code>client_id</code>、<code>credential_id</code>、<code>route_id</code>、<code>upstream_id</code>：外键字段，记录调用上下文。</li>
<li><code>request_body</code> &#x2F; <code>response_body</code>：JSON 格式，存储请求与响应内容。</li>
<li><code>prompt_tokens</code>、<code>completion_tokens</code>、<code>total_tokens</code>、<code>cost</code>：记录 Token 用量与费用。</li>
<li><code>created_at</code>：记录调用时间。</li>
</ul>
</li>
<li><strong>约束与设计要点</strong>：<ul>
<li>高写入场景建议仅保留必要外键，或由服务层保障一致性。</li>
<li><strong>按时间分区存储</strong>：基于 <code>created_at</code> 字段按月分区，减少单表数据量，提升写入和查询性能。</li>
<li><strong>冷热数据分离</strong>：将历史日志（如 6 个月前的数据）归档到冷存储（如对象存储或专用日志数据库），降低主数据库存储压力。</li>
</ul>
</li>
<li><strong>设计思想</strong>：记录每次 API 调用的详细信息，支持审计、计费和问题排查。</li>
<li><strong>设计理由</strong>：<ul>
<li><code>request_id</code> 提供全链路追踪能力。</li>
<li><code>prompt_tokens</code> 和 <code>completion_tokens</code> 支持 Token 用量统计，便于计费。</li>
<li>高写入场景下，使用自增主键优化性能，并支持分区或归档策略。</li>
</ul>
</li>
</ul>
<ol start="8">
<li><strong>usage_quotas（用量配额&#x2F;统计）</strong></li>
</ol>
<ul>
<li><strong>用途</strong>：按 <code>client</code> × <code>model</code> × <code>周期</code> 跟踪与限制用量。</li>
<li><strong>主要字段</strong>：<ul>
<li><code>id</code>：主键，UUID。</li>
<li><code>client_id</code>、<code>model_id</code>：外键字段。</li>
<li><code>period</code>：统计周期（如 daily、monthly）。</li>
<li><code>period_start</code>：周期起始日期，与 <code>period</code> 共同界定统计周期。</li>
<li><code>used_tokens</code>、<code>quota_tokens</code>：记录已用与配额 Token 数（-1 表示无限制）。</li>
<li><code>updated_at</code>：记录最后更新时间。</li>
</ul>
</li>
<li><strong>约束与设计要点</strong>：<ul>
<li>唯一键：<code>client_id</code> + <code>model_id</code> + <code>period</code> + <code>period_start</code>。</li>
<li>支持幂等更新与原子累加。</li>
<li>可按周期归档或清理历史数据。</li>
</ul>
</li>
<li><strong>设计思想</strong>：按接入方、模型和周期跟踪用量，支持配额限制。</li>
<li><strong>设计理由</strong>：<ul>
<li><code>period</code> 和 <code>period_start</code> 定义统计周期，支持灵活的配额管理。</li>
<li><code>quota_tokens</code> 支持无限制（-1）配置，满足不同业务需求。</li>
<li>唯一键确保每个周期内的统计记录不重复，便于幂等更新。</li>
</ul>
</li>
</ul>
<h3 id="关系说明"><a href="#关系说明" class="headerlink" title="关系说明"></a>关系说明</h3><ul>
<li>一对多<ul>
<li>clients → client_credentials &#x2F; audit_logs &#x2F; usage_quotas</li>
<li>models → routes &#x2F; usage_quotas</li>
<li>routes → route_upstreams &#x2F; audit_logs</li>
<li>upstreams → route_upstreams &#x2F; audit_logs</li>
</ul>
</li>
<li>多对多<ul>
<li>routes ↔ upstreams 通过 route_upstreams 关联，并通过 weight 实现加权路由&#x2F;故障切换。</li>
</ul>
</li>
<li>审计闭环<ul>
<li>audit_logs 关联调用链关键实体，支持基于 request_id 的全链路追踪与基于时间&#x2F;客户&#x2F;凭证的统计查询。</li>
</ul>
</li>
</ul>
<h3 id="索引设计与建议"><a href="#索引设计与建议" class="headerlink" title="索引设计与建议"></a>索引设计与建议</h3><ul>
<li>唯一约束<ul>
<li>clients(name), models(name), routes(name), upstreams(name)</li>
<li>client_credentials(api_key_prefix)</li>
<li>route_upstreams(route_id, upstream_id)</li>
<li>usage_quotas(client_id, model_id, period, period_start)</li>
</ul>
</li>
<li>复合&#x2F;普通索引<ul>
<li>client_credentials(client_id) 加速按客户管理凭证</li>
<li>routes(model_id) 加速按模型检索路由</li>
<li>routes(header_match, path_match) 提升高频路由规则查询性能</li>
<li>upstreams(type) 支持运营&#x2F;运维检索</li>
<li>audit_logs：<ul>
<li>(request_id) 单次定位</li>
<li>(client_id, credential_id) 客户&#x2F;凭证统计</li>
<li>(route_id, upstream_id) 路由与上游维度统计</li>
<li>(created_at) 按时间窗口查询</li>
</ul>
</li>
</ul>
</li>
<li>JSON 查询<ul>
<li>对于 <code>routes</code> 表中的 <code>other_conditions</code> 字段，建议仅在低频查询场景下使用 JSON 查询。</li>
<li>usage_quotas(client_id, model_id, period, period_start)</li>
</ul>
</li>
</ul>
<h2 id="网关整体工作流程示例"><a href="#网关整体工作流程示例" class="headerlink" title="网关整体工作流程示例"></a>网关整体工作流程示例</h2><p>对外来说，AI 网关对接业务系统，提供一个 <strong>统一的 OpenAI 兼容 API</strong>。业务系统的开发者只需要知道 <strong>网关的地址和 API Key</strong>，其余的复杂性（不同厂商 API 差异、密钥管理、路由策略）都被屏蔽掉了。</p>
<h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><ol>
<li><p><strong>获取凭证</strong></p>
<ul>
<li>管理员在管理 API (<code>/api/admin/v1/clients</code>) 里为业务系统创建一个 <strong>Client</strong>，并生成对应的 <strong>API Key</strong>。</li>
<li>业务系统只需要记住这个 Key。</li>
</ul>
</li>
<li><p><strong>调用 AI 网关的接口</strong></p>
<ul>
<li><p>假设调用对话模型：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /v1/chat/completions</span><br><span class="line">Authorization: Bearer &lt;gateway-api-key&gt;</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;model&quot;: &quot;gpt-4-turbo&quot;,</span><br><span class="line">  &quot;messages&quot;: [</span><br><span class="line">    &#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;帮我写一首七言律诗&quot;&#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;stream&quot;: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>AI 网关返回和 OpenAI 格式一样的结果（支持标准响应和流式 SSE）。</p>
</li>
</ul>
</li>
<li><p><strong>查询用量与配额</strong></p>
<ul>
<li><p>业务方可以通过管理 API（未来扩展）查询自己的调用日志和 Token 使用情况：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /api/admin/v1/usage/quotas?clientId=xxx</span><br></pre></td></tr></table></figure>
</li>
<li><p>避免超额调用。</p>
</li>
</ul>
</li>
</ol>
<p>对业务方而言，网关就是 <strong>一个统一的 LLM 服务入口</strong>，像用 OpenAI API 一样用，但实际上背后可能是 OpenAI、Azure、DeepSeek、甚至本地私有化模型。</p>
<h3 id="AI-网关内部是怎么工作的"><a href="#AI-网关内部是怎么工作的" class="headerlink" title="AI 网关内部是怎么工作的"></a>AI 网关内部是怎么工作的</h3><p>内部流程可以分成 <strong>核心请求处理路径</strong> 和 <strong>辅助管理&#x2F;观测路径</strong>。</p>
<h4 id="请求进入网关"><a href="#请求进入网关" class="headerlink" title="请求进入网关"></a>请求进入网关</h4><ul>
<li>业务请求先进入 <strong>AI Gateway Core</strong>（核心网关服务）。</li>
<li>Gateway Core 执行以下步骤：<ol>
<li><strong>认证</strong>：校验 API Key（通过 Redis&#x2F;DB 验证哈希）。</li>
<li><strong>授权</strong>：检查这个 Key 是否有访问 <code>gpt-4-turbo</code> 的权限（RBAC 控制）。</li>
<li><strong>限流&#x2F;配额</strong>：检查当前客户端是否超过 QPS&#x2F;Token 用量限制。</li>
</ol>
</li>
</ul>
<h4 id="路由与下游调用"><a href="#路由与下游调用" class="headerlink" title="路由与下游调用"></a>路由与下游调用</h4><ul>
<li>Gateway Core 根据配置的 <strong>路由策略</strong>，决定把请求发到哪个下游模型：<ul>
<li>策略可能基于：延迟、权重、成本、可用性。</li>
<li>例如：优先发 Azure GPT-4，如果宕机就自动切到 OpenAI GPT-4。</li>
</ul>
</li>
<li>请求发送到下游模型时，所需的 <strong>API Key</strong> 从 Vault 动态拉取（不是写死在代码里）。</li>
</ul>
<h4 id="高级功能（可选）"><a href="#高级功能（可选）" class="headerlink" title="高级功能（可选）"></a>高级功能（可选）</h4><ul>
<li>如果开启了 <strong>RAG 或提示词模板</strong>：<ul>
<li>Gateway Core 会调用 <strong>Orchestration Service</strong>，先执行检索增强、上下文拼接，再把增强后的 Prompt 交给下游模型。</li>
</ul>
</li>
</ul>
<h4 id="响应返回"><a href="#响应返回" class="headerlink" title="响应返回"></a>响应返回</h4><ul>
<li>Gateway Core 收到下游返回后，组装成 OpenAI 兼容格式，返回给业务系统。</li>
<li>同时，生成一条 <strong>审计事件（调用日志、Token 用量、费用信息）</strong>，异步写入 Kafka。</li>
</ul>
<h4 id="后台异步处理"><a href="#后台异步处理" class="headerlink" title="后台异步处理"></a>后台异步处理</h4><ul>
<li><strong>Observability Service</strong> 消费 Kafka 事件：<ul>
<li>记录审计日志（MySQL &#x2F; 冷存储）。</li>
<li>更新 <code>usage_quotas</code>（Redis + DB）。</li>
<li>推送监控指标给 Prometheus（延迟、QPS、费用）。</li>
</ul>
</li>
<li><strong>Management Service</strong> 负责：<ul>
<li>提供管理 API（客户端、路由、上游配置）。</li>
<li>配置变更时通过缓存失效&#x2F;事件通知广播给其他服务。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="整体工作闭环"><a href="#整体工作闭环" class="headerlink" title="整体工作闭环"></a>整体工作闭环</h3><ol>
<li><strong>管理员</strong> 配置 Client、Route、Upstream。</li>
<li><strong>业务系统</strong> 拿 API Key 调用 <code>/v1/chat/completions</code>。</li>
<li><strong>网关 Core</strong> 验证身份 → 限流配额 → 智能路由 → 调用下游模型。</li>
<li><strong>返回结果</strong> 给业务系统（OpenAI 风格）。</li>
<li><strong>调用日志和用量</strong> 异步写入 Observability Service。</li>
<li><strong>管理员&#x2F;业务系统</strong> 可以通过管理 API 查看用量、配额、上游健康状态。</li>
</ol>
<hr>
<p>总结：</p>
<ul>
<li><strong>对业务系统</strong>：AI 网关就是一个统一的、安全的 API 入口。</li>
<li><strong>对内部</strong>：AI 网关通过认证、限流、智能路由、密钥管理，把多个 LLM 服务封装成一个高可用、可观测、可扩展的服务层。</li>
</ul>
]]></content>
      <categories>
        <category>后端开发</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>后端开发</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Go Runtime</title>
    <url>/2025/08/21/Go-Runtime/</url>
    <content><![CDATA[<h1 id="Go-Runtime"><a href="#Go-Runtime" class="headerlink" title="Go Runtime"></a>Go Runtime</h1><p>Go Runtime 主要由两大支柱构成：</p>
<ol>
<li><strong>调度器 (Scheduler)</strong>: 负责管理和调度成千上万的 goroutine，让它们在少量的操作系统线程上高效运行。其核心就是 <strong>GMP 模型</strong>。</li>
<li><strong>内存管理器 (Memory Manager)</strong>: 负责 Go 程序的内存分配和垃圾回收 (Garbage Collection, GC)，确保内存使用的安全和高效。</li>
</ol>
<h1 id="调度器的详细过程（GMP模型）"><a href="#调度器的详细过程（GMP模型）" class="headerlink" title="调度器的详细过程（GMP模型）"></a>调度器的详细过程（GMP模型）</h1><ul>
<li><strong>G (Goroutine)</strong>:<ul>
<li><strong>本质</strong>: 一个执行单元，包含了它需要运行的函数指令、程序计数器 (PC)、栈指针 (SP) 和自己的栈。</li>
<li><strong>轻量级</strong>: 它的栈初始非常小 (约 2KB)，可以根据需要动态增长和收缩。这就是为什么可以轻松创建成千上万个 goroutine，而操作系统线程的栈通常是固定的兆字节 (MB) 级别。</li>
<li><strong>状态</strong>: Goroutine 有多种状态，如 Grunnable (可运行)、Grunning (正在运行)、Gsyscall (等待系统调用)、Gwaiting (等待中，如 channel 或锁)。调度器根据这些状态来移动 G。</li>
</ul>
</li>
<li><strong>M (Machine)</strong>:<ul>
<li><strong>本质</strong>: 一个标准的操作系统线程 (OS Thread)。Go 代码的实际执行者。</li>
<li><strong>数量</strong>: Runtime 会根据需要创建和销毁 M，但有一个上限。它不是直接由 <code>GOMAXPROCS</code> 控制的。</li>
</ul>
</li>
<li><strong>P (Processor)</strong>:<ul>
<li><strong>本质</strong>: 一个逻辑处理器，是 G 和 M 之间的“调度上下文”或“执行许可证”。<strong>runtime.GOMAXPROCS(n) 设置的就是 P 的数量</strong>，默认等于 CPU 的核心数。这个值决定了你的程序能<strong>同时</strong>运行多少个 goroutine。</li>
<li><strong>关键作用</strong>: P 拥有一个**本地可运行 G 队列 (Local Run Queue, LRQ)**。这极大地减少了多个 M 争抢同一个全局队列的锁竞争，提高了调度效率。</li>
</ul>
</li>
</ul>
<h2 id="GMP-调度过程的生命周期"><a href="#GMP-调度过程的生命周期" class="headerlink" title="GMP 调度过程的生命周期"></a><strong>GMP 调度过程的生命周期</strong></h2><p>下面列举一个完整的流程来理解它们是如何协同工作的：</p>
<ol>
<li><strong>程序启动</strong>:<ul>
<li>Go Runtime 初始化，创建一定数量的 M 和 P（数量由 <code>GOMAXPROCS</code> 决定）。</li>
<li>创建第一个 goroutine，用于执行 main 函数。</li>
</ul>
</li>
<li><strong>创建新的 Goroutine (以go myFunc()为例)</strong>:<ul>
<li>代码执行到 go myFunc()。</li>
<li>Runtime 调用内部函数 newproc，在堆上创建一个新的 G 对象，并设置好它的指令指针指向 myFunc 的开头，以及初始化它的栈。</li>
<li>这个新的 G 被放入当前 M 所绑定的 P 的<strong>本地运行队列 (Local Run Queue, LRQ)</strong> 中。</li>
</ul>
</li>
<li><strong>M 的执行循环</strong>:<ul>
<li>M 就像是是一个不知疲倦的工作者，它会不断地执行一个循环：<br>a. 从它绑定的 P 的 LRQ 中寻找一个可运行的 G。<br>b. 如果找到了，就设置好 CPU 的寄存器，然后执行这个 G 的代码。<br>c. 如果 G 执行完毕，M 就再次去 LRQ 中寻找下一个 G。</li>
</ul>
</li>
<li><strong>发生阻塞 (关键调度点)</strong>:<ul>
<li>假设一个正在运行的 G (我们称之为 G1) 进行了一个<strong>阻塞的系统调用</strong> (如文件读写、网络请求)。</li>
<li>这时，运行 G1 的 M (我们称之为 M1) 将会随着 G1 一起被操作系统阻塞。</li>
<li><strong>调度器介入</strong>: M1 会与它绑定的 P (我们称之为 P1) <strong>解绑</strong>。</li>
<li>Runtime 会寻找一个空闲的 M (或者创建一个新的 M，称之为 M2)，让它<strong>接管</strong> P1。</li>
<li>M2 开始执行 P1 本地队列中的其他 G。<strong>这样，仅仅一个 G 的阻塞，并不会阻塞整个程序的并行能力</strong>。</li>
<li>当 G1 的系统调用完成后，它会重新变为可运行状态，并被放回一个 P 的队列中，等待某个 M 来执行它。</li>
</ul>
</li>
<li><strong>工作窃取 (Work Stealing)</strong>:<ul>
<li>如果一个 M (比如 M1) 绑定的 P (比如 P1) 的本地队列已经空了，M1 不会闲着。</li>
<li>它会变成一个“小偷”，随机地去查看其他 P (比如 P2) 的本地队列。</li>
<li>如果发现 P2 的队列中有 G，M1 就会“窃取”一半的 G 到自己的 P1 队列中，然后开始执行。</li>
<li>这个机制实现了出色的负载均衡，确保了所有 CPU 核心都尽可能地保持忙碌。</li>
</ul>
</li>
</ol>
<h1 id="内存管理器的详细过程"><a href="#内存管理器的详细过程" class="headerlink" title="内存管理器的详细过程"></a>内存管理器的详细过程</h1><p>Go 的内存管理器主要负责两件事：为新对象分配内存，以及回收不再使用的对象（垃圾回收）。</p>
<h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><p>Go 的内存分配器非常精巧，它采用了分级分配的策略来减少锁竞争，提高效率。</p>
<ul>
<li><strong>TCMalloc 思想</strong>: Go 将内存虚拟地址空间组织成一个金字塔结构，越往上，访问速度越快，但资源越少；越往下，资源越丰富，但访问成本越高。<ol>
<li>Go 的分配器借鉴了 Google 的 TCMalloc（<code>Thread-Caching Malloc</code>）。核心思想是为每个 P 维护一个本地的内存缓存 (<strong>mcache</strong>)。这是分配效率最高的层次。每个逻辑处理器 P (Processor) 都有一个自己的 <code>mcache</code>。<code>mcache</code> 是一个包含各种常用 Size Class 的 <code>mspan</code> 列表的本地缓存。**(<code>mspan</code> 是 Go 内存管理的基本单位。它可以是 1 页 (8KB)，也可以是多页。mspan 会被预先格式化，用于存储特定大小的对象，例如，一个 mspan 可能只用来存 16 字节的对象，另一个只用来存 32 字节的对象。这种按大小分类的方式称为 Size Class。)**</li>
<li><strong>mcentral</strong> 负责管理特定 <strong>Size Class</strong> 的 <code>mspan</code>。例如，有一个 <code>mcentral</code> 专门管理所有用于 16 字节对象的 mspan。</li>
<li><strong>mheap</strong> 这是 Go 进程持有的整个虚拟内存空间，由 Go Runtime 统一管理。它将从操作系统申请到的大块内存（称为 <strong>Arenas</strong>）切分成许多**页 (Page)**，每页大小为 8KB。访问 mheap 需要加全局锁，成本最高。它不会直接把零散的页分配出去，而是将一组连续的页打包成一个 <code>mspan</code>。</li>
</ol>
</li>
<li><strong>分配流程</strong>:<ol>
<li>当一个 goroutine 需要分配一小块内存时，它会直接从它所在的 P 的<strong>本地缓存</strong> <code>mcache</code> 中获取，这个过程<strong>完全不需要加锁</strong>，速度极快。</li>
<li>如果 <code>mcache</code> 中没有足够大的内存块，它会向一个<strong>中心缓存</strong> (<code>mcentral</code>) 请求。这个过程需要加锁，但多个 P 共享一个 <code>mcentral</code>，竞争程度适中。</li>
<li>如果 <code>mcentral</code> 也没有，它会向<strong>页堆</strong> (<code>mheap</code>) 申请一块更大的内存，并将其切分。这个过程锁的粒度最大。</li>
<li>如果连 <code>mheap</code> 都没有足够的空闲页了，Go Runtime 就会通过系统调用向操作系统申请一块新的大内存（通常是几 MB）。</li>
</ol>
</li>
</ul>
<p>这种设计使得绝大多数的小对象分配都能在无锁的情况下快速完成。</p>
<p><strong>注意</strong>：对于超过 32KB 的大对象，分配过程会绕过 mcache 和 mcentral，直接由 mheap 进行分配，因为对大对象的缓存意义不大。</p>
<h2 id="垃圾回收-GC"><a href="#垃圾回收-GC" class="headerlink" title="垃圾回收 (GC)"></a>垃圾回收 (GC)</h2><p>Go 的 GC 旨在最大程度上减少应用程序的暂停时间（Stop-The-World, STW）。它采用的是一个<strong>并发的三色标记-清除 (Tri-color Mark-and-Sweep)</strong> 算法。</p>
<p><strong>三色抽象</strong>:</p>
<ul>
<li><strong>白色</strong>: 初始状态，代表潜在的垃圾。</li>
<li><strong>灰色</strong>: 已被发现，但其引用的对象还没被扫描。</li>
<li><strong>黑色</strong>: 已被发现，且其引用的所有对象都已被扫描。GC 的目标就是把所有活动对象都变成黑色。</li>
</ul>
<p><strong>GC 过程</strong>:</p>
<p><strong>准备阶段 (STW)</strong>: 一个非常短暂的暂停。开启**写屏障 (Write Barrier)**。写屏障是一段由编译器插入的代码，用于记录在 GC 并发执行期间，程序对内存指针的修改。这是保证并发 GC 正确性的关键。</p>
<p><strong>标记阶段 (并发)</strong>:</p>
<ul>
<li><p><strong>此阶段与应用程序并发执行。</strong></p>
</li>
<li><p>从根对象（全局变量、每个 goroutine 栈上的变量等）开始，将它们标记为灰色，并放入一个队列。</p>
</li>
<li><p>GC 的后台工作 goroutine 会不断从队列中取出灰色对象，将其引用的所有白色对象也标记为灰色并放入队列，然后将自身标记为黑色。</p>
</li>
<li><p>这个过程是<strong>与你的应用程序代码并发执行的</strong>。你的 goroutine 仍然在运行和修改对象。写屏障会确保即使在标记过程中指针关系发生了变化，GC 也能正确地追踪到所有活动对象。</p>
</li>
</ul>
<p><strong>标记终止 (stop the world, STW)</strong>: 另一个短暂的暂停(通常只有微秒级别的暂停)。完成标记工作，关闭写屏障。</p>
<p><strong>清除阶段 (并发)</strong>:</p>
<ul>
<li>遍历堆内存，将所有仍然是<strong>白色</strong>的对象回收，它们的内存可以被重新分配。这个过程也是并发的。</li>
</ul>
<p>通过这种方式，Go 的 GC 将 STW 时间控制在亚毫秒级别，对应用程序的性能影响极小。</p>
<h3 id="并发-GC-的挑战与解决方案：写屏障-Write-Barrier"><a href="#并发-GC-的挑战与解决方案：写屏障-Write-Barrier" class="headerlink" title="并发 GC 的挑战与解决方案：写屏障 (Write Barrier)"></a>并发 GC 的挑战与解决方案：写屏障 (Write Barrier)</h3><p>如果 GC 在标记时，应用程序也在<strong>同时运行</strong>，就会出现一个严重问题：</p>
<blockquote>
<p><strong>场景</strong>：对象 A (黑色) 已经扫描完毕。此时，应用程序执行 A.ptr &#x3D; B，让 A 引用了一个对象 B (白色)。然后，应用程序删除了其他所有对 B 的引用。</p>
</blockquote>
<p>如果没有特殊机制，GC 不会再回头扫描黑色的 A，因此 B 将永远不会被发现，最终被错误地当作垃圾回收掉。这就是<strong>对象丢失</strong>问题。</p>
<p>为了解决这个问题，Go 引入了<strong>写屏障 (Write Barrier)</strong> 技术。写屏障是编译器插入的一段代码，它“监视”所有在堆上的指针修改操作。</p>
<p><strong>混合写屏障 (Hybrid Write Barrier) 的核心思想</strong>：</p>
<blockquote>
<p><strong>当一个指针被修改时，如果被指向的对象是白色的，写屏障会立即将其标记为灰色。</strong></p>
</blockquote>
<p>这样就保证了，一个黑色的对象永远无法直接指向一个白色的对象。这个简单的规则，确保了在并发标记过程中，所有活动对象最终都能被正确地标记为黑色。</p>
<h1 id="总结：Go-Runtime-的协同工作"><a href="#总结：Go-Runtime-的协同工作" class="headerlink" title="总结：Go Runtime 的协同工作"></a>总结：Go Runtime 的协同工作</h1><p>Go Runtime 就像一个高效的现代化工厂：</p>
<ul>
<li><strong>Goroutines (G)</strong> 是成千上万个等待处理的<strong>任务</strong>。</li>
<li><strong>Processors (P)</strong> 是固定数量的<strong>流水线</strong> (<code>GOMAXPROCS</code> 条)。</li>
<li><strong>OS Threads (M)</strong> 是<strong>工人</strong>。</li>
<li><strong>调度器</strong>是<strong>车间主任</strong>，它不断地将任务（G）分配到流水线（P）上，并指挥工人（M）去操作流水线。如果一个工人在某条流水线上被卡住了（系统调用），主任会立刻派另一个工人去接管这条流水线，保证生产不中断。如果有的流水线任务堆积，而有的空闲，主任还会让工人去“匀一些”任务过来（工作窃取）。</li>
<li><strong>内存管理器</strong>是工厂的<strong>后勤和保洁部门</strong>，它负责提供原材料（分配内存），并在任务完成后高效地清理废料（垃圾回收），保持整个工厂的整洁和高效运转。</li>
</ul>
]]></content>
      <categories>
        <category>后端开发</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Slice的实践与底层实现</title>
    <url>/2025/09/10/Slice%E7%9A%84%E5%AE%9E%E8%B7%B5%E4%B8%8E%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="Slice-的实践与底层实现"><a href="#Slice-的实践与底层实现" class="headerlink" title="Slice 的实践与底层实现"></a><strong>Slice 的实践与底层实现</strong></h1><p>在 Go 语言中，<code>slice</code> 是一种非常常用的数据结构，它是对数组的一个抽象和封装。<code>slice</code> 提供了灵活的动态数组操作，底层通过数组实现。理解 <code>slice</code> 的实践和底层实现对编写高效的 Go 程序至关重要。</p>
<h2 id="Slice的概念和实践用法"><a href="#Slice的概念和实践用法" class="headerlink" title="Slice的概念和实践用法"></a>Slice的概念和实践用法</h2><p>在Go中，<strong>数组（Array）</strong>是固定长度的，而<strong>Slice（切片）</strong>是对数组的抽象，更加灵活。</p>
<p>常见操作：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">arr := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">s := arr[<span class="number">1</span>:<span class="number">4</span>]   <span class="comment">// 包含 arr[1], arr[2], arr[3] → [2, 3, 4]</span></span><br><span class="line"></span><br><span class="line">s2 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">3</span>, <span class="number">5</span>) <span class="comment">// 长度3，容量5</span></span><br><span class="line">s2[<span class="number">0</span>] = <span class="number">10</span> <span class="comment">//s2 before append: [10 0 0] len: 3 cap: 5</span></span><br><span class="line">s2 = <span class="built_in">append</span>(s2, <span class="number">20</span>, <span class="number">30</span>) <span class="comment">// 自动扩容</span></span><br><span class="line"><span class="comment">//s2 after append: [10 0 0 20 30] len: 5 cap: 5</span></span><br></pre></td></tr></table></figure>

<h3 id="Slice-的三要素"><a href="#Slice-的三要素" class="headerlink" title="Slice 的三要素"></a>Slice 的三要素</h3><p>每个切片其实是一个描述符（slice header），包含 3 个字段：</p>
<ol>
<li><strong>指针</strong>：指向底层数组（backing array）的首地址</li>
<li>**长度 (len)**：切片中实际元素的个数</li>
<li>**容量 (cap)**：从切片首元素到底层数组最后一个元素的数量</li>
</ol>
<p>举例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">arr := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">s := arr[<span class="number">1</span>:<span class="number">3</span>] <span class="comment">// s = [2, 3]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>指针 → 指向 arr[1]</li>
<li>len &#x3D; 2</li>
<li>cap &#x3D; 4  (因为 arr[1] 到 arr[4] 一共有 4 个位置)</li>
</ul>
<h2 id="Slice-的底层数据结构"><a href="#Slice-的底层数据结构" class="headerlink" title="Slice 的底层数据结构"></a>Slice 的底层数据结构</h2><p>Go 的源码里（<code>runtime/slice.go</code>），切片头部结构大致如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">    array unsafe.Pointer <span class="comment">// 底层数组的指针</span></span><br><span class="line">    <span class="built_in">len</span>   <span class="type">int</span>            <span class="comment">// 长度</span></span><br><span class="line">    <span class="built_in">cap</span>   <span class="type">int</span>            <span class="comment">// 容量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以 <strong>slice 并不是直接存储数据</strong>，它只是个“视图”。</p>
<ul>
<li>多个切片可以共享同一个底层数组。</li>
<li>修改其中一个切片的内容，可能影响另一个切片。</li>
</ul>
<p>例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">arr := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">s1 := arr[<span class="number">1</span>:<span class="number">4</span>]   <span class="comment">// [2, 3, 4]</span></span><br><span class="line">s2 := arr[<span class="number">2</span>:<span class="number">5</span>]   <span class="comment">// [3, 4, 5]</span></span><br><span class="line"></span><br><span class="line">s1[<span class="number">1</span>] = <span class="number">99</span>       <span class="comment">// 修改 s1 中的元素</span></span><br><span class="line">fmt.Println(arr) <span class="comment">// [1, 2, 99, 4, 5]</span></span><br><span class="line">fmt.Println(s2)  <span class="comment">// [99, 4, 5]  &lt;-- 也受影响</span></span><br></pre></td></tr></table></figure>

<h2 id="Slice-的内存增长机制与坑点"><a href="#Slice-的内存增长机制与坑点" class="headerlink" title="Slice 的内存增长机制与坑点"></a>Slice 的内存增长机制与坑点</h2><p><code>append</code> 时，如果容量不足，Go 会分配一个新的数组，并把旧元素复制过去。</p>
<h3 id="扩容规则（简化版）："><a href="#扩容规则（简化版）：" class="headerlink" title="扩容规则（简化版）："></a>扩容规则（简化版）：</h3><ul>
<li>若新长度小于 2 倍原容量 → cap *&#x3D; 2</li>
<li>若超过 → cap &#x3D; 新长度</li>
<li>具体细节可能随 Go 版本略有变化</li>
</ul>
<p>例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s), <span class="built_in">cap</span>(s)) <span class="comment">// 3, 3</span></span><br><span class="line"></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">4</span>)            <span class="comment">// 扩容</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s), <span class="built_in">cap</span>(s)) <span class="comment">// 4, 6 (Go 1.18+ 大约会翻倍)</span></span><br></pre></td></tr></table></figure>

<h3 id="常见坑点"><a href="#常见坑点" class="headerlink" title="常见坑点"></a>常见坑点</h3><ol>
<li><p><strong>切片共享内存，容易“意外修改”</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s1 := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">s2 := s1[:<span class="number">2</span>]</span><br><span class="line">s1[<span class="number">1</span>] = <span class="number">99</span></span><br><span class="line">fmt.Println(s2) <span class="comment">// [1, 99]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>append 可能导致“底层数组更换”，不会影响原切片</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s1 := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">s2 := <span class="built_in">append</span>(s1, <span class="number">3</span>, <span class="number">4</span>) </span><br><span class="line">s1[<span class="number">0</span>] = <span class="number">99</span></span><br><span class="line">fmt.Println(s1) <span class="comment">// [99, 2]</span></span><br><span class="line">fmt.Println(s2) <span class="comment">// [1, 2, 3, 4]  &lt;-- 没有受影响</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>​		这是因为Slice本身不存储数据，其只是个“视图”。真正的数据存放在 <strong>底层数组（backing array）</strong> 中。所以<code>append</code> 在 <strong>容量足够时</strong>，新老切片共享底层数组；在 <strong>容量不足时</strong>，Go 会创建一个新数组，新老切片从此分开。</p>
<h2 id="实践案例与调试观察"><a href="#实践案例与调试观察" class="headerlink" title="实践案例与调试观察"></a>实践案例与调试观察</h2><p>我们可以用 <code>reflect.SliceHeader</code> 或 <code>unsafe</code> 来观察切片的底层信息：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;reflect&quot;</span></span><br><span class="line">    <span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">    s[<span class="number">0</span>], s[<span class="number">1</span>], s[<span class="number">2</span>] = <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span></span><br><span class="line"></span><br><span class="line">    hdr := (*reflect.SliceHeader)(unsafe.Pointer(&amp;s))</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Data Ptr: %x, Len: %d, Cap: %d\n&quot;</span>, hdr.Data, hdr.Len, hdr.Cap)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出示例（不同机器结果不同）：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Data Ptr:</span> <span class="string">c000010240,</span> <span class="attr">Len:</span> <span class="number">3</span><span class="string">,</span> <span class="attr">Cap:</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>这就印证了切片的三要素：指针、长度、容量。</p>
]]></content>
      <categories>
        <category>后端开发</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>后端开发</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>dlv分析Golang进程</title>
    <url>/2025/09/19/dlv%E5%88%86%E6%9E%90Golang%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="使用-dlv-分析-Go-进程-CPU-占用高问题的步骤"><a href="#使用-dlv-分析-Go-进程-CPU-占用高问题的步骤" class="headerlink" title="使用 dlv 分析 Go 进程 CPU 占用高问题的步骤"></a>使用 <code>dlv</code> 分析 Go 进程 CPU 占用高问题的步骤</h3><h4 id="1-确认-CPU-占用高的进程"><a href="#1-确认-CPU-占用高的进程" class="headerlink" title="1. 确认 CPU 占用高的进程"></a>1. <strong>确认 CPU 占用高的进程</strong></h4><p>首先，你需要找到 CPU 占用高的进程。在 Linux 环境下，可以使用 <code>top</code> 或 <code>htop</code> 命令来查看系统中各个进程的 CPU 使用情况。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">top</span><br></pre></td></tr></table></figure>



<p>通过 <code>top</code>，你可以找到 Go 程序的进程 ID（PID）。</p>
<h4 id="2-使用-dlv-附加到运行中的进程"><a href="#2-使用-dlv-附加到运行中的进程" class="headerlink" title="2. 使用 dlv 附加到运行中的进程"></a>2. <strong>使用 <code>dlv</code> 附加到运行中的进程</strong></h4><p>当找到占用 CPU 高的进程后，可以通过 <code>dlv</code> 附加到正在运行的 Go 进程。假设目标进程的 PID 为 <code>12345</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dlv attach 12345</span><br></pre></td></tr></table></figure>



<p><code>dlv attach</code> 会暂停该进程并进入调试模式。进入调试模式后，你可以查看进程的运行状态、查看当前的 Goroutine、函数调用栈等信息。</p>
<h4 id="3-查看-Goroutine"><a href="#3-查看-Goroutine" class="headerlink" title="3. 查看 Goroutine"></a>3. <strong>查看 Goroutine</strong></h4><p>使用 <code>dlv</code>，你可以查看当前所有的 Goroutine，检查是否有 Goroutine 堆积或死锁。运行以下命令来查看所有 Goroutine 的状态：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">goroutines</span><br></pre></td></tr></table></figure>



<p>你会看到当前所有 Goroutine 的列表，带有每个 Goroutine 的 ID 和执行中的函数信息。如果某些 Goroutine 在某个点停滞不前或有大量 Goroutine 堆积，这可能是导致高 CPU 使用的原因。</p>
<h4 id="4-检查-Goroutine-的堆栈"><a href="#4-检查-Goroutine-的堆栈" class="headerlink" title="4. 检查 Goroutine 的堆栈"></a>4. <strong>检查 Goroutine 的堆栈</strong></h4><p>对于特定的 Goroutine，可以进一步查看其调用栈，确认它正在执行的代码。可以通过以下命令查看某个 Goroutine 的调用栈：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">goroutine &lt;Goroutine_ID&gt; stack</span><br></pre></td></tr></table></figure>



<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">goroutine 1 stack</span><br></pre></td></tr></table></figure>



<p>这会显示该 Goroutine 的调用栈，可以帮助你找出哪部分代码可能导致高 CPU 占用。</p>
<h4 id="5-查看当前执行的位置"><a href="#5-查看当前执行的位置" class="headerlink" title="5. 查看当前执行的位置"></a>5. <strong>查看当前执行的位置</strong></h4><p>你还可以检查当前进程正在执行的代码，查看 CPU 消耗的具体位置。通过 <code>break</code> 设置断点，在特定的代码行停止执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">break main.go:20</span><br></pre></td></tr></table></figure>



<p>然后使用 <code>continue</code> 命令继续执行程序，程序将在达到该断点时暂停，这样可以了解程序在特定代码路径上的运行情况。</p>
<h4 id="6-分析-CPU-Profiling"><a href="#6-分析-CPU-Profiling" class="headerlink" title="6. 分析 CPU Profiling"></a>6. <strong>分析 CPU Profiling</strong></h4><p>对于更深层次的 CPU 占用问题分析，可以利用 <code>pprof</code> 工具生成 CPU 性能报告。使用 <code>runtime/pprof</code> 包，可以通过代码生成 CPU profile 文件，并使用 <code>go tool pprof</code> 分析。</p>
<p>首先，在程序中添加以下代码来记录 CPU profile：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;runtime/pprof&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f, _ := os.Create(<span class="string">&quot;cpu.prof&quot;</span>)</span><br><span class="line">    pprof.StartCPUProfile(f)</span><br><span class="line">    <span class="keyword">defer</span> pprof.StopCPUProfile()</span><br><span class="line">    <span class="comment">// your code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>运行程序后，使用 <code>go tool pprof</code> 来分析 <code>cpu.prof</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">go tool pprof cpu.prof</span><br></pre></td></tr></table></figure>



<p>进入 <code>pprof</code> 后，可以使用 <code>top</code>、<code>list</code> 等命令来查看哪些函数占用了最多的 CPU 时间。</p>
<h4 id="7-通过-trace-分析更多细节"><a href="#7-通过-trace-分析更多细节" class="headerlink" title="7. 通过 trace 分析更多细节"></a>7. <strong>通过 <code>trace</code> 分析更多细节</strong></h4><p>除了 <code>dlv</code> 和 <code>pprof</code>，还可以使用 Go 提供的 <code>trace</code> 工具来捕获更多的运行时信息。首先，修改代码以捕获 trace：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;runtime/trace&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f, _ := os.Create(<span class="string">&quot;trace.out&quot;</span>)</span><br><span class="line">    trace.Start(f)</span><br><span class="line">    <span class="keyword">defer</span> trace.Stop()</span><br><span class="line">    <span class="comment">// your code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>然后使用 <code>go tool trace</code> 查看 trace 文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">go tool trace trace.out</span><br></pre></td></tr></table></figure>



<p><code>trace</code> 工具能展示更多的调度、Goroutine 切换、GC 事件等，帮助更全面地分析程序性能。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>使用 <code>dlv</code> 调试 Go 进程 CPU 占用高的问题，可以从以下几方面着手：</p>
<ol>
<li><strong>确认高 CPU 使用的进程</strong>，使用 <code>top</code> 查找进程。</li>
<li><strong>附加到进程</strong>，使用 <code>dlv attach</code> 进入调试模式。</li>
<li><strong>查看 Goroutine 状态</strong>，检查是否有 Goroutine 堆积或执行异常。</li>
<li><strong>分析调用栈</strong>，定位消耗 CPU 资源的代码路径。</li>
<li>使用 <code>pprof</code> 和 <code>trace</code> 进行更详细的性能分析。</li>
</ol>
<p>通过这些步骤，可以有效找到并解决 Go 应用中的性能瓶颈问题。</p>
]]></content>
      <categories>
        <category>后端开发</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>后端开发</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>UE5引擎源码版编译和Windows版本打包</title>
    <url>/2024/11/20/UE5%E5%BC%95%E6%93%8E%E6%BA%90%E7%A0%81%E7%89%88%E7%BC%96%E8%AF%91%E5%92%8CWindows%E7%89%88%E6%9C%AC%E6%89%93%E5%8C%85/</url>
    <content><![CDATA[<h1 id="读前须知"><a href="#读前须知" class="headerlink" title="读前须知"></a>读前须知</h1><hr>
<p>​	这里先贴出来<a href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/downloading-unreal-engine-source-code?application_version=5.4">Unreal Engine</a>的官方安装文档，本人就是跟着官方文档做的。这篇文章作为个人搭建记录和XX公司课程的作业提交。课程中网络相关问题均未提到，如果访问某些网站出现困难那么请自己寻求魔法。本文章目前只有windows版本的教程，mac和Linux的教程在我文章中提到的官方文档里均有提到。</p>
<h1 id="访问得到Github上的虚幻引擎的源代码"><a href="#访问得到Github上的虚幻引擎的源代码" class="headerlink" title="访问得到Github上的虚幻引擎的源代码"></a>访问得到Github上的虚幻引擎的源代码</h1><p>​	首先就是要有一个<a href="https://github.com/">GitHub</a>账号，没有的话要去注册一个。然后你可以看一下你的账号的profile中的Organizations中有没有epic这个标志，</p>
<p><img data-src="https://raw.githubusercontent.com/jianingdai/Blog_img/main/imgimage-20241121004251563.png" alt="image-20241121004251563"></p>
<p>​	如果没有这个标志那么可以去<a href="https://www.unrealengine.com/zh-CN">Epic Games</a>登录然后在右上角可以点开自己的头像然后打开账户。要不然的话你点开UnrealEngine的源码仓库会出现访问404。</p>
<img data-src="https://raw.githubusercontent.com/jianingdai/Blog_img/main/imgimage-20241121002301539.png" alt="image-20241121002301539" style="zoom:;" />

<p>​	然后在左面点开应用与账户再点开右面的Github然后选择连接，按照操作进行关联就可以了。然后按照道理来说GitHub会发送邮件邀请你加入GitHub上的@EpicGames组织。你必须在7天内点击邮件内的 加入@EpicGames（Join @EpicGames） 按钮，才能完成GitHub与Epic Games账号的关联流程。但是我<strong>没有</strong>收到这份邮件，这个时候你不要急你等个几分钟然后去<a href="https://github.com/EpicGames">EpicGame的Github主页</a>这个时候你的页面上方应该会有一个消息提示其邀请你加入到Organizations中。如果没看见忘记点了也没事多刷新几次。</p>
<p><img data-src="https://raw.githubusercontent.com/jianingdai/Blog_img/main/imgimage-20241121002700384.png" alt="image-20241121002700384"></p>
<p>​	等你加进组织之后再次访问就不会显示404了。然后你就可以进入到<a href="https://github.com/EpicGames/UnrealEngine">EpicGame的UnrealEngine仓库</a>中访问到Github上的虚幻引擎的源代码了。</p>
<h1 id="安装Visual-Studio-2022"><a href="#安装Visual-Studio-2022" class="headerlink" title="安装Visual Studio 2022"></a>安装Visual Studio 2022</h1><p>​	安装Visual Studio2022主要是用来编译和提供相关依赖。首先第一步访问<a href="https://visualstudio.microsoft.com/zh-hans/">VS</a>的官网然后点击下载Visual Studio安装程序，点开后选择我下图所展示的依赖点上：</p>
<p><img data-src="https://raw.githubusercontent.com/jianingdai/Blog_img/main/imgimage-20241121125914604.png" alt="image-20241121125914604"></p>
<hr>
<p><img data-src="https://raw.githubusercontent.com/jianingdai/Blog_img/main/imgimage-20241121125940979.png" alt="image-20241121125940979"></p>
<p>​	这一步官方也有详细文档指导，请点击这里：<a href="https://dev.epicgames.com/documentation/en-us/unreal-engine/setting-up-visual-studio-development-environment-for-cplusplus-projects-in-unreal-engine?application_version=5.4">UE5相关VS安装指导</a>，如果你在之后遇到相关问题记得回来检查版本是否匹配，截至这篇post提交时，官方版本匹配指导见下图：</p>
<p><img data-src="https://raw.githubusercontent.com/jianingdai/Blog_img/main/imgimage-20241121130715320.png" alt="image-20241121130715320"></p>
<p>​	另外vs还可以安装自己喜欢的插件和主题，然后自己也可以进行各种设置外观等，这些我就不在这里赘述了，想要搞得自己可以慢慢调教。</p>
<h1 id="下载源码并且进行初始化"><a href="#下载源码并且进行初始化" class="headerlink" title="下载源码并且进行初始化"></a>下载源码并且进行初始化</h1><p>​	下载源码有多种方式可以直接对于指定的branch进行clone，也可以直接下载zip压缩包解压。</p>
<h2 id="clone方法"><a href="#clone方法" class="headerlink" title="clone方法"></a>clone方法</h2><p>​	首先要确保你的电脑安装了git，并且你的GitHub上已经绑定了你的本地git的ssh公钥，直接在你想要装Unreal Engine的目录中打开控制台然后输入以下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --depth 1 --branch 5.4 git@github.com:EpicGames/UnrealEngine.git</span><br></pre></td></tr></table></figure>

<h2 id="下载zip压缩包"><a href="#下载zip压缩包" class="headerlink" title="下载zip压缩包"></a>下载zip压缩包</h2><p>​	直接点击我的右面这个连接：<a href="https://github.com/EpicGames/UnrealEngine/releases">点我</a>，就可以进到UE的Releases的界面了，然后找到你想要下载的版本点开Assets点击Source code(zip)，msi后缀的是win上的安装包。然后就可以进行下载了，当下载完后直接解压就行。例如像我下图所示（推荐下载有发行版的releases一般来说会比较稳定）：</p>
<p><img data-src="https://raw.githubusercontent.com/jianingdai/Blog_img/main/imgimage-20241121132853132.png" alt="image-20241121132853132"></p>
<p>​	当做到这里的时候你应该已经获得了源码了（差不多有2个GB）。</p>
<h2 id="下载二进制文件等和开始编译"><a href="#下载二进制文件等和开始编译" class="headerlink" title="下载二进制文件等和开始编译"></a>下载二进制文件等和开始编译</h2><ol>
<li><p>在资源管理器中打开你的源代码文件夹，并运行 <code>Setup.bat</code>。</p>
<p>这样将下载引擎的二进制内容和先决程序，并设置虚幻文件关联。 在Windows 8上，可能会显示SmartScreen警告。请依次单击 <strong>更多信息</strong> 和 <strong>Run anyway</strong> 以继续。</p>
<p>引擎二进制文件的完整下载包需要一些时间（差不多20个GB）才能完成下载。 后续检出只需要下载增量部分，速度将会大幅提高。</p>
</li>
<li><p>运行 <code>GenerateProjectFiles.bat</code> 来为引擎创建项目文件。这个过程应该不超过一分钟即可完成。</p>
</li>
<li><p>双击 <code>UE5.sln</code> 文件以将项目加载到Visual Studio中。将你的解决方案配置设置为 <strong>开发编辑器</strong>，将解决方案平台设置为 <strong>Win64</strong>，然后右键单击 <strong>UE</strong> 目标并选择 <strong>构建</strong>。大概需要10-40分钟完成编译，具体取决于系统规格。这里我的电脑编译了有1个多小时差不多，反正就是很耗时了，对电脑的CPU和内存有较大要求，CPU越强时间越短。</p>
</li>
<li><p>编译完成后，可以将启动项目设置为 <strong>UE5</strong> 并按 <strong>F5</strong> 进行调试，以便从Visual Studio加载编辑器。</p>
<p><strong>（请一定确保按照操作进行操作，否则会损失很多时间）</strong></p>
<p><img data-src="https://raw.githubusercontent.com/jianingdai/Blog_img/main/imgimage-20241121133941806.png" alt="image-20241121133941806"></p>
</li>
</ol>
<h1 id="创建UE5工程并且开始打包"><a href="#创建UE5工程并且开始打包" class="headerlink" title="创建UE5工程并且开始打包"></a>创建UE5工程并且开始打包</h1><p>​	当你第一次打开UE客户端的时候因为需要进行着色所以的话会很耗时，然后打开客户端进行创建项目，注意以下几个点，项目名称最好别用中文，最好用英文。</p>
<p><img data-src="https://raw.githubusercontent.com/jianingdai/Blog_img/main/imgimage-20241121134504003.png" alt="image-20241121134504003"></p>
<h2 id="Windows平台打包"><a href="#Windows平台打包" class="headerlink" title="Windows平台打包"></a>Windows平台打包</h2><p>​	然后像下图一样就可以进行游戏的初次打包了：</p>
<p><img data-src="https://raw.githubusercontent.com/jianingdai/Blog_img/main/imgimage-20241121134620003.png" alt="image-20241121134620003"></p>
<h2 id="Android平台打包"><a href="#Android平台打包" class="headerlink" title="Android平台打包"></a>Android平台打包</h2><p>如果想要进行Android平台的打包记得要下载Android Studio进行SDK和NDK的安装，还有就是JAVA的SDK也是需要的一定要注意一下自己有没有安装相关工具链，如果安装成功了应该是我这个样子的：</p>
<p><img data-src="https://raw.githubusercontent.com/jianingdai/Blog_img/main/imgimage-20241121134916922.png" alt="image-20241121134916922"></p>
<p>​	如果没有安装的话可以看一下这个链接：<a href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/set-up-android-sdk-ndk-and-android-studio-using-turnkey-for-unreal-engine">点我</a>，这个官方文档有着详细的说明。</p>
<h1 id="打包成果展示"><a href="#打包成果展示" class="headerlink" title="打包成果展示"></a>打包成果展示</h1><p>经过一段时间的编译然后就生成了如下图所示的打包成果：</p>
<p><img data-src="https://raw.githubusercontent.com/jianingdai/Blog_img/main/imgimage-20241121174901797.png" alt="image-20241121174901797"></p>
<p><img data-src="https://raw.githubusercontent.com/jianingdai/Blog_img/main/imgimage-20241121175156226.png" alt="image-20241121175156226"></p>
<p>实机运行效果如图所示：</p>
<p><img data-src="https://raw.githubusercontent.com/jianingdai/Blog_img/main/imgimage-20241121175125192.png" alt="image-20241121175125192"></p>
<p>​	现在你成功制作了你自己的第一款游戏，具有逼真的物理模拟和极高的画质上限，现在你也可以叫自己为游戏制作工程师了~😍！</p>
<p>​	本教程到这里就结束了，如果还有什么问题可以在下面留言评论。</p>
]]></content>
      <categories>
        <category>UE5</category>
      </categories>
      <tags>
        <tag>UE5</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP_Client大量长连接保持</title>
    <url>/2025/09/18/HTTP-Client%E5%A4%A7%E9%87%8F%E9%95%BF%E8%BF%9E%E6%8E%A5%E4%BF%9D%E6%8C%81/</url>
    <content><![CDATA[<h2 id="问题起因"><a href="#问题起因" class="headerlink" title="问题起因"></a>问题起因</h2><p>在生产环境中，<code>server to server</code> 的服务出现大量 <code>TIME_WAIT</code> 状态的连接。通过 <code>netstat</code> 发现，连接不断建立但无法保持。抓取 TCP 包后确认，<code>request</code> 和 <code>response</code> 中的 <code>keepalive</code> 已正确设置，但每个 TCP 连接大约处理 6 次 HTTP 请求后就会关闭。</p>
<h2 id="排查分析"><a href="#排查分析" class="headerlink" title="排查分析"></a>排查分析</h2><p>在 Golang 中，<code>IdleConn</code> 的数量不仅受到 <code>MaxIdleConns</code> 的限制，还受到 <code>MaxIdleConnsPerHost</code> 的限制。</p>
<ul>
<li>**<code>MaxIdleConns</code>**：控制整个客户端的连接池中的最大空闲连接数。</li>
<li>**<code>MaxIdleConnsPerHost</code>**：控制每个主机的最大空闲连接数。</li>
</ul>
<p>在 <code>http.DefaultTransport</code> 中，这些参数默认没有显式配置，其中 <code>MaxIdleConnsPerHost</code> 的默认值是 2。这意味着每个主机最多只能保留 2 个空闲连接，即使客户端允许更多的空闲连接数（通过 <code>MaxIdleConns</code> 设置）。</p>
<p>因此，在高并发场景下，如果没有调整 <code>MaxIdleConnsPerHost</code>，其他请求只能不断的新建&#x2F;销毁连接，导致大量<code>TIME_WAIT</code>,这本身是TCP协议设计的保护机制（等待2MSL，确保最后的ACK被对方收到）。但是如果连接频繁被关闭，<code>TIME_WAIT</code>会积累，导致端口被占满，性能下降。为了提高性能，可以通过自定义 <code>http.Transport</code> 来增加 <code>MaxIdleConnsPerHost</code> 的值，例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">transport := &amp;http.Transport&#123;</span><br><span class="line">    MaxIdleConns:       <span class="number">100</span>,  <span class="comment">// 设置整个连接池的最大空闲连接数</span></span><br><span class="line">    MaxIdleConnsPerHost: <span class="number">10</span>,  <span class="comment">// 设置每个主机的最大空闲连接数</span></span><br><span class="line">    <span class="comment">// 其他配置</span></span><br><span class="line">&#125;</span><br><span class="line">client := &amp;http.Client&#123;</span><br><span class="line">    Transport: transport,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>出现大量的 <code>TIME_WAIT</code> 状态以及频繁关闭连接的问题，通常与以下几个因素有关：</p>
<ol>
<li><strong>连接管理配置问题</strong>：<ul>
<li><code>TIME_WAIT</code> 是 TCP 协议中规定的一种状态，当一方主动关闭连接时，会进入 <code>TIME_WAIT</code> 状态，等待 2MSL（Maximum Segment Lifetime）时间，以确保对方接收到了最后的 ACK 确认。这段时间内，端口仍然被占用。</li>
<li>如果服务频繁建立和关闭连接，<code>TIME_WAIT</code> 状态的连接会大量增加，导致可用端口不足。</li>
</ul>
</li>
<li><strong><code>Keep-Alive</code> 配置问题</strong>：<ul>
<li>虽然 <code>keep-alive</code> 设置了，但如果服务端或客户端的连接池管理不当，可能仍会导致连接频繁关闭。</li>
<li>HTTP 的 <code>Keep-Alive</code> 机制可以维持 TCP 连接，但需要配合合理的连接池配置，确保连接不会过早关闭。</li>
</ul>
</li>
<li><strong>服务器负载和资源限制</strong>：<ul>
<li>高负载情况下，服务器可能会主动关闭连接，尤其是在连接数超过设定阈值时。</li>
<li>可以检查系统资源（如文件描述符、网络缓冲区）是否足够。</li>
</ul>
</li>
<li><strong>配置参数调整</strong>：<ul>
<li><code>tcp_tw_reuse</code> 和 <code>tcp_tw_recycle</code> 是 Linux 内核中的两个参数，可以调整 <code>TIME_WAIT</code> 状态的处理方式，但不建议在生产环境中随意更改，因为可能引入其他问题。</li>
<li>调整 <code>MaxIdleConns</code> 和 <code>MaxIdleConnsPerHost</code>，增加连接池的连接数，减少新建连接的频率。</li>
</ul>
</li>
</ol>
<h2 id="解决方案建议"><a href="#解决方案建议" class="headerlink" title="解决方案建议"></a><strong>解决方案建议</strong></h2><ol>
<li><p><strong>调整连接池配置</strong>：</p>
<ul>
<li>确保 Golang 的客户端和服务端都配置了合理的连接池，避免频繁创建和销毁连接。</li>
<li>例如，客户端可以通过增加 <code>DefaultMaxIdleConnsPerHost</code> 或 <code>MaxIdleConnsPerHost</code> 参数来保持更多的空闲连接。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">client := &amp;http.Client&#123;</span><br><span class="line">    Transport: &amp;http.Transport&#123;</span><br><span class="line">        MaxIdleConns:        <span class="number">100</span>,</span><br><span class="line">        MaxIdleConnsPerHost: <span class="number">100</span>,</span><br><span class="line">        IdleConnTimeout:     <span class="number">90</span> * time.Second,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用长连接（Keep-Alive）</strong>：</p>
<ul>
<li>确保 HTTP 请求使用了 <code>Keep-Alive</code>，并且服务端正确地支持并配置了 <code>Keep-Alive</code>。</li>
<li>如果是 RESTful 服务，尽量减少短连接的使用。</li>
</ul>
</li>
<li><p><strong>调节服务器的资源配置</strong>：</p>
<ul>
<li>检查服务器的 <code>ulimit</code> 设置，确保文件描述符足够多。</li>
<li>查看并优化服务器的网络配置，例如增大连接追踪表的大小，减少 <code>TIME_WAIT</code> 的持续时间。</li>
</ul>
</li>
<li><p><strong>负载均衡与反向代理</strong>：</p>
<ul>
<li>如果服务部署在负载均衡器或反向代理之后，确保这些中间件的连接管理配置合理，以减少对后端服务的连接压力。</li>
</ul>
</li>
<li><p><strong>监控和日志分析</strong>：</p>
<ul>
<li>通过监控工具和日志分析，确认哪些请求导致了连接的频繁关闭，并针对性地进行优化。</li>
</ul>
</li>
</ol>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a><strong>最后</strong></h2><p>大量的 <code>TIME_WAIT</code> 状态通常表明连接管理不当或负载过高。通过合理配置连接池、优化服务器资源配置、并确保 <code>Keep-Alive</code> 正确使用，可以显著减少不必要的连接关闭，并降低 <code>TIME_WAIT</code> 的积累。持续监控系统表现并进行相应的调整，将有助于保持服务的稳定性和性能。</p>
]]></content>
      <categories>
        <category>后端开发</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>后端开发</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>命名规则规范</title>
    <url>/2025/08/28/%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<h2 id="Go-语言命名规范"><a href="#Go-语言命名规范" class="headerlink" title="Go 语言命名规范"></a>Go 语言命名规范</h2><p>你好，欢迎来到 Go 语言的世界！在你开始编写惊艳的代码之前，我们先来聊一个看似简单却至关重要的话题：<strong>命名</strong>。</p>
<p>好的命名就像是给你的代码画一张清晰的地图，不仅你自己看着舒服，将来和其他人合作时，别人也能轻松看懂你的“地图”，快速上手。Go 语言有一套简洁、优雅的命名哲学，掌握了它，你的代码会变得更加专业。</p>
<p>别担心，这不复杂，让我们一步步来拆解。</p>
<h3 id="核心总则：大道至简"><a href="#核心总则：大道至简" class="headerlink" title="核心总则：大道至简"></a>核心总则：大道至简</h3><p>记住这几条黄金法则，你就掌握了 Go 命名的精髓：</p>
<ol>
<li><strong>简洁直观</strong>：名字要能一眼看懂是干嘛的。比如 <code>calculateScore</code> 就比 <code>calcScr</code> 好一万倍。</li>
<li><strong>驼峰命名法 (CamelCase)<strong>：这是 Go 的标准姿势。当一个名字由多个单词组成时，把它们拼在一起，每</strong>个单词的首字母大写</strong>，就是<strong>大驼峰</strong>（<code>CamelCase</code> 或 <code>PascalCase</code>）；如果第一个单词的首字母小写，那就是<strong>小驼峰</strong>（<code>camelCase</code>）。</li>
<li><strong>首字母大小写 &#x3D; “可见性”</strong>：这是 Go <strong>最最最重要</strong>的特性！如果一个名字（比如变量、函数、结构体）的<strong>首字母是大写的</strong>，就好像你在对大家说：“嘿，这个东西你们谁都能用！”。这在 Go 里叫<strong>导出 (Exported)<strong>，是</strong>公开的 (public)<strong>。反之，如果是</strong>小写字母开头</strong>，就等于在说：“这是我的私人用品，别碰！”，这叫**未导出 (unexported)<strong>，是</strong>私有的 (private)**。</li>
<li><strong>避免无意义的缩写</strong>：除非是像 <code>ID</code>, <code>URL</code>, <code>HTTP</code> 这样全世界程序员都认识的“暗号”，否则别自己创造缩写。没人喜欢猜谜语。</li>
</ol>
<hr>
<h3 id="1-包-Package-命名：你的代码工具箱"><a href="#1-包-Package-命名：你的代码工具箱" class="headerlink" title="1. 包 (Package) 命名：你的代码工具箱"></a>1. 包 (Package) 命名：你的代码工具箱</h3><p><strong>什么是包？</strong> 你可以把“包”想象成一个专门放某一类工具的工具箱。比如，一个叫 <code>cache</code> 的包，里面可能就放满了各种和缓存操作相关的工具（函数、结构体等）。</p>
<p><strong>命名规则：</strong></p>
<ul>
<li><strong>一律小写</strong>：简单、干净。</li>
<li><strong>简短且有意义</strong>：用一个单词说清楚这个工具箱的用途。</li>
<li><strong>不要用下划线 <code>_</code> 或驼峰</strong>：这是约定俗成的规矩。</li>
<li><strong>不要和标准库重名</strong>：你总不想把你自己的 <code>http</code> 包和 Go 官方的 <code>http</code> 包搞混吧？</li>
</ul>
<p><strong>示例：</strong></p>
<p>Go</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 导入一个处理字符串的标准库包</span><br><span class="line">import &quot;strings&quot;</span><br><span class="line"></span><br><span class="line">// 导入一个处理网络请求的标准库包</span><br><span class="line">import &quot;net/http&quot;</span><br><span class="line"></span><br><span class="line">// 导入一个你项目中自己写的，用于日志记录的包</span><br><span class="line">import &quot;github.com/your-project/logger&quot;</span><br></pre></td></tr></table></figure>

<p>✅ <strong>推荐</strong>：<code>net</code>, <code>http</code>, <code>cache</code>, <code>logger</code>, <code>config</code> ❌ <strong>避免</strong>：<code>Net</code>, <code>my_cache</code>, <code>stringUtils</code>, <code>LoggerPackage</code></p>
<hr>
<h3 id="2-文件命名：整理你的工具"><a href="#2-文件命名：整理你的工具" class="headerlink" title="2. 文件命名：整理你的工具"></a>2. 文件命名：整理你的工具</h3><p><strong>什么是文件？</strong> 如果说包是工具箱，那文件就是工具箱里的一个个小格子，用来分类存放你的工具。</p>
<p><strong>命名规则：</strong></p>
<ul>
<li><strong>全小写</strong>：保持队形。</li>
<li><strong>用下划线 <code>_</code> 分隔单词</strong>：如果文件名需要多个单词，用下划线连接，这在 Go 文件命名中是允许且常见的。</li>
<li><strong>功能导向</strong>：文件名要说清楚这个文件是干嘛的。</li>
<li><strong>测试文件是特殊的</strong>：所有测试代码都必须放在以 <code>_test.go</code> 结尾的文件里，这是 Go 的硬性规定。</li>
</ul>
<p><strong>示例：</strong></p>
<p><code>http_server.go</code>  &#x2F;&#x2F; 存放 HTTP 服务器相关代码 <code>user_model.go</code>   &#x2F;&#x2F; 存放用户数据模型相关代码 <code>utils.go</code>        &#x2F;&#x2F; 存放一些通用的小工具函数</p>
<p><code>http_server_test.go</code> &#x2F;&#x2F; 这是上面 http_server.go 对应的测试文件</p>
<hr>
<h3 id="3-变量与常量：存放数据的盒子"><a href="#3-变量与常量：存放数据的盒子" class="headerlink" title="3. 变量与常量：存放数据的盒子"></a>3. 变量与常量：存放数据的盒子</h3><p><strong>命名规则：</strong></p>
<ul>
<li>**小驼峰命名 (camelCase)**：对于函数内部的局部变量，或者包内私有的变量，统一使用小驼峰。</li>
<li><strong>首字母大写 &#x3D; 导出</strong>：如果你想让一个变量或常量在项目其他包中也能被使用，就把它首字母大写。</li>
<li><strong>短小精悍</strong>：特别是对于局部变量，名字短一点没关系。比如在循环里，大家都默认用 <code>i</code>, <code>j</code>, <code>k</code>。</li>
<li>**常量组 <code>iota</code>**：当需要定义一组递增的常量（比如枚举）时，使用 <code>iota</code> 这个神奇的关键字，它能让你的代码更简洁。通常会给这类常量加上一个共同的前缀。</li>
</ul>
<p><strong>示例：</strong></p>
<p>Go</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 这是一个只能在当前包使用的私有变量</span><br><span class="line">var userCount int</span><br><span class="line"></span><br><span class="line">// 这是一个可以在任何地方使用的公开常量</span><br><span class="line">const MaxConnections = 100</span><br><span class="line"></span><br><span class="line">// 一个简单的循环变量</span><br><span class="line">for i := 0; i &lt; 5; i++ &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用 iota 定义一组状态常量，它们的值会从 0 开始自动递增</span><br><span class="line">type Status int</span><br><span class="line">const (</span><br><span class="line">    StatusPending Status = iota // 值为 0</span><br><span class="line">    StatusRunning               // 值为 1</span><br><span class="line">    StatusSuccess               // 值为 2</span><br><span class="line">    StatusFailed                // 值为 3</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-函数与方法：执行动作的指令"><a href="#4-函数与方法：执行动作的指令" class="headerlink" title="4. 函数与方法：执行动作的指令"></a>4. 函数与方法：执行动作的指令</h3><p><strong>什么是函数&#x2F;方法？</strong> 函数是一段可以执行特定任务的代码。方法是“绑定”在某个特定类型（如结构体）上的函数。</p>
<p><strong>命名规则：</strong></p>
<ul>
<li>**小驼峰命名 (camelCase)**：和变量一样，私有函数用小驼峰。</li>
<li><strong>首字母大写 &#x3D; 导出</strong>：公开的、可以给别人用的函数，首字母大写。</li>
<li><strong>像动词一样</strong>：函数名最好是一个动作，比如 <code>GetUser</code>, <code>CalculatePrice</code>, <code>DeleteUser</code>。</li>
</ul>
<p><strong>示例：</strong></p>
<p>Go</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 这是一个私有函数，只能在包内调用，用来创建一个新的服务器实例</span><br><span class="line">func newServer(port int) *Server &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 这是一个公开的方法，绑定在 *Server 类型上，用来启动服务器</span><br><span class="line">// 任何能拿到 Server 实例的地方都可以调用它</span><br><span class="line">func (s *Server) Start() error &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="5-结构体与接口：代码的蓝图与契约"><a href="#5-结构体与接口：代码的蓝图与契约" class="headerlink" title="5. 结构体与接口：代码的蓝图与契约"></a>5. 结构体与接口：代码的蓝图与契约</h3><p><strong>什么是结构体 (Struct)？</strong> 结构体是自定义的数据类型“蓝图”。比如，你可以定义一个 <code>User</code> 结构体，它有 <code>ID</code>、<code>Name</code>、<code>Email</code> 这些属性。</p>
<p><strong>什么是接口 (Interface)？</strong> 接口是一种“契约”或“规范”。它只定义了“需要做什么”（有哪些方法），但不关心“具体怎么做”。比如，一个 <code>Reader</code> 接口规定了任何实现它的类型都必须有一个 <code>Read</code> 方法。</p>
<p><strong>命名规则：</strong></p>
<ul>
<li>**结构体：大驼峰 (CamelCase)**。它是一个类型，所以通常用大驼峰。</li>
<li><strong>接口：通常以 <code>-er</code> 结尾</strong>。这是一个非常 Go-Style 的习惯！如果一个接口定义了一种能力，就用 “能力动词 + er” 来命名。比如能 <code>Read</code> 的就是 <code>Reader</code>，能 <code>Write</code> 的就是 <code>Writer</code>。如果接口包含多个方法，也可以用一个名词来命名，如 <code>http.Handler</code>。</li>
</ul>
<p><strong>示例：</strong></p>
<p>Go</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 定义一个公开的 User 结构体</span><br><span class="line">type User struct &#123;</span><br><span class="line">    ID   int</span><br><span class="line">    Name string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 定义一个“可读取”的接口契约</span><br><span class="line">// 任何类型只要实现了 Read 方法，就被认为是一个 Reader</span><br><span class="line">type Reader interface &#123;</span><br><span class="line">    Read(p []byte) (n int, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="6-处理常见缩写：不成文的规矩"><a href="#6-处理常见缩写：不成文的规矩" class="headerlink" title="6. 处理常见缩写：不成文的规矩"></a>6. 处理常见缩写：不成文的规矩</h3><p>对于像 <code>URL</code>, <code>ID</code>, <code>HTTP</code>, <code>API</code>, <code>JSON</code> 这类广为人知的缩写，有一个约定俗成的规则：<strong>保持它们全大写</strong>。</p>
<p><strong>错误示范</strong>：<code>UrlParser</code>, <code>HttpServer</code> <strong>正确姿势</strong>：<code>URLParser</code>, <code>HTTPServer</code></p>
<p>这让代码在视觉上更容易区分出这些常见的技术术语。</p>
<p><strong>示例：</strong></p>
<p>Go</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var userID int</span><br><span class="line">var defaultURL string</span><br><span class="line"></span><br><span class="line">type HTTPServer struct &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="7-错误-Error-命名：清晰地告诉我们“出错了”"><a href="#7-错误-Error-命名：清晰地告诉我们“出错了”" class="headerlink" title="7. 错误 (Error) 命名：清晰地告诉我们“出错了”"></a>7. 错误 (Error) 命名：清晰地告诉我们“出错了”</h3><p>在 Go 中，错误处理非常重要。好的错误命名能让调试事半功倍。</p>
<p><strong>命名规则：</strong></p>
<ul>
<li><strong>错误变量</strong>：以 <code>Err</code> 开头。它们通常是公开的，用于让调用者判断具体的错误类型。</li>
<li><strong>自定义错误类型</strong>：以 <code>Error</code> 结尾的结构体。</li>
</ul>
<p><strong>示例：</strong></p>
<p>Go</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 一个预定义的错误变量</span><br><span class="line">var ErrNotFound = errors.New(&quot;record not found&quot;)</span><br><span class="line"></span><br><span class="line">// 一个自定义的错误类型</span><br><span class="line">type SyntaxError struct &#123;</span><br><span class="line">    Line int</span><br><span class="line">    Col  int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (e *SyntaxError) Error() string &#123;</span><br><span class="line">    return fmt.Sprintf(&quot;syntax error at line %d, column %d&quot;, e.Line, e.Col)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="8-测试-Test-命名：保证代码质量的守护神"><a href="#8-测试-Test-命名：保证代码质量的守护神" class="headerlink" title="8. 测试 (Test) 命名：保证代码质量的守护神"></a>8. 测试 (Test) 命名：保证代码质量的守护神</h3><p><strong>命名规则：</strong></p>
<ul>
<li><strong>测试函数</strong>：以 <code>Test</code> 开头，后面跟上你要测试的函数名，同样使用大驼峰。</li>
<li><strong>性能测试（基准测试）</strong>：以 <code>Benchmark</code> 开头。</li>
</ul>
<p><strong>示例：</strong></p>
<p>Go</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 这是对 AddUser 函数的测试</span><br><span class="line">func TestAddUser(t *testing.T) &#123;</span><br><span class="line">    // ... 测试逻辑</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 这是对 Sort 函数的性能测试</span><br><span class="line">func BenchmarkSort(b *testing.B) &#123;</span><br><span class="line">    // ... 性能测试逻辑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="9-项目目录结构：给你的项目一个家"><a href="#9-项目目录结构：给你的项目一个家" class="headerlink" title="9. 项目目录结构：给你的项目一个家"></a>9. 项目目录结构：给你的项目一个家</h3><p>一个清晰的目录结构能让项目井井有条。虽然没有强制规定，但社区形成了一些最佳实践：</p>
<ul>
<li><code>cmd/</code>：存放项目的主程序入口（<code>main</code> 函数就在这里）。</li>
<li><code>internal/</code>：存放项目内部私有的代码，别的项目无法导入这里面的包，非常安全。</li>
<li><code>pkg/</code>：存放可以被外部项目安全引用的公共代码库。</li>
<li><code>api/</code>：存放 API 定义文件（比如 <code>.proto</code> 文件）。</li>
<li><code>configs/</code>：存放配置文件。</li>
<li><code>scripts/</code>：存放各种脚本（编译、部署、分析等）。</li>
</ul>
<hr>
<h3 id="10-注释-Comments-：代码的“使用说明书”"><a href="#10-注释-Comments-：代码的“使用说明书”" class="headerlink" title="10. 注释 (Comments)：代码的“使用说明书”"></a>10. 注释 (Comments)：代码的“使用说明书”</h3><p>好的代码会说话，但有时也需要注释来补充说明。</p>
<p><strong>注释规则：</strong></p>
<ul>
<li><strong>给每个公开的（导出的）东西写注释</strong>：每个公开的函数、方法、类型、常量都应该有一段简短的注释，解释它的用途。</li>
<li><strong>注释要以被注释的对象名开头</strong>。</li>
<li><strong>用 <code>//</code> 写单行注释</strong>，这是 Go 的首选。</li>
</ul>
<p><strong>示例：</strong></p>
<p>Go</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Package cache 提供了一个简单的内存缓存功能。</span><br><span class="line">package cache</span><br><span class="line"></span><br><span class="line">// MaxSize 是缓存可以存储的最大项目数。</span><br><span class="line">const MaxSize = 100</span><br><span class="line"></span><br><span class="line">// Cache 是一个线程安全的缓存结构体。</span><br><span class="line">type Cache struct &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Add 方法向缓存中添加一个键值对。</span><br><span class="line">// 如果键已存在，它会覆盖旧的值。</span><br><span class="line">func (c *Cache) Add(key string, value interface&#123;&#125;) &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>后端开发</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>后端开发</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Unreal为例的游戏模式学习</title>
    <url>/2024/11/23/Unreal%E4%B8%BA%E4%BE%8B%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="读前须知"><a href="#读前须知" class="headerlink" title="读前须知"></a>读前须知</h1><p>​	在学习这篇笔记之前需要先搭好Unreal Engine的环境，最好是源码版的可以跟着源码一起学习。如果没有相关的环境可以看一下我的这一篇笔记：<a href="/2024/11/20/UE5%E5%BC%95%E6%93%8E%E6%BA%90%E7%A0%81%E7%89%88%E7%BC%96%E8%AF%91%E5%92%8CWindows%E7%89%88%E6%9C%AC%E6%89%93%E5%8C%85/" title="UE5引擎源码版编译和Windows版本打包">UE5引擎源码版编译和Windows版本打包</a></p>
<p><strong>附：</strong></p>
<p>​	本笔记也作为我本人的课程作业的一种提交方式。可以直接点击：“<a href="#%E4%BD%9C%E4%B8%9A%E9%83%A8%E5%88%86">作业部分</a>”，跳转到对应的章节。</p>
<h1 id="什么是游戏模式："><a href="#什么是游戏模式：" class="headerlink" title="什么是游戏模式："></a>什么是游戏模式：</h1><p>​	游戏模式是游戏世界里面组织数据和运作规则的方式，例如：</p>
<ol>
<li>这些物体的共同点，不同点，怎么抽象？</li>
<li>世间万物以什么规则运行？</li>
<li>数据如何组织、描述？（就是想要变得内容以什么数据结构进行描述和组织？）</li>
</ol>
<p>这些都是游戏模式所要思考设计的内容。</p>
<h1 id="UE的Gameplay框架："><a href="#UE的Gameplay框架：" class="headerlink" title="UE的Gameplay框架："></a>UE的Gameplay框架：</h1><p>​	UE中的Gameplay框架包括核心系统和用于处理通用Gameplay元素的框架，如Actor、摄像机、组件、控制器、游戏规则、游戏模式、玩家输入、Gameplay定时器和用户界面。</p>
<h2 id="UE的万物之源：UObject"><a href="#UE的万物之源：UObject" class="headerlink" title="UE的万物之源：UObject"></a>UE的万物之源：UObject</h2><blockquote>
<p>参考：<a href="https://dev.epicgames.com/documentation/en-us/unreal-engine/API">Unreal Engine C++ API Reference</a></p>
</blockquote>
<table>
<thead>
<tr>
<th align="center"></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="center">Module</td>
<td>CoreUObject</td>
</tr>
<tr>
<td align="center">Header</td>
<td>&#x2F;Engine&#x2F;Source&#x2F;Runtime&#x2F;CoreUObject&#x2F;Public&#x2F;UObject&#x2F;Object.h</td>
</tr>
<tr>
<td align="center">Include</td>
<td>#include “UObject&#x2F;Object.h”</td>
</tr>
<tr>
<td align="center">Source</td>
<td>&#x2F;Engine&#x2F;Source&#x2F;Runtime&#x2F;CoreUObject&#x2F;Private&#x2F;UObject&#x2F;UObjectGlobals.cpp</td>
</tr>
</tbody></table>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UObject</span>  </span><br><span class="line">(  </span><br><span class="line">    <span class="type">const</span> FObjectInitializer &amp; ObjectInitializer  </span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>​	其中的特性有：</p>
<ul>
<li>元数据、反射生成、GC垃圾回收、序列化</li>
<li>通⽤属性和接⼝（Equals、Clone、GetHashCode、ToString、GetName、GetMetaData<br>等等）</li>
<li>每个物体是由原⼦构成的⸺uobject&#x3D;原⼦</li>
</ul>
<h2 id="物体的表达：Actor-ActorComponent"><a href="#物体的表达：Actor-ActorComponent" class="headerlink" title="物体的表达：Actor+ActorComponent"></a>物体的表达：Actor+ActorComponent</h2><p>​	所有可以放入关卡的对象都是 <strong>Actor</strong>，比如摄像机、静态网格体、玩家起始位置。Actor支持三维变换，例如平移、旋转和缩放。你可以通过游戏逻辑代码（C++或蓝图）创建（生成）或销毁Actor。</p>
<p>在C++中，AActor是所有Actor的基类。</p>
<p>注意：Actor不直接保存变换（位置、旋转和缩放）数据；如Actor的根组件存在，则使用它的变换数据。</p>
<p>​	Components是一种特殊类型的对象，Actor可以将其作为子对象附加到自己身上。Components对于共享公共行为非常有用，例如显示可视表示、播放声音等功能。它们还可以表示特定于项目的概念，例如车辆解释输入并改变自身速度和方向的方式。例如，一个包含用户可控制的汽车、飞机和船只的项目可以通过改变车辆Actor使用的组件来实现车辆控制和移动的差异。</p>
<blockquote>
<p>To be precise : <strong>Components</strong> are a special type of <strong>Object</strong> that <strong>Actors</strong> can attach to themselves as sub-objects. Components are useful for sharing common behaviors, such as the ability to display a visual representation, play sounds. They can also represent project-specific concepts, such as the way a vehicle interprets input and changes its own velocity and orientation. For example, a project with user-controllable cars, aircraft, and boats could implement the differences in vehicle control and movement by changing which Component a vehicle Actor uses.</p>
</blockquote>
<ul>
<li>EC架构（Entity-Component Framework）:⼀个实体和多种能⼒组合的设计模式。<ul>
<li>就像是⼀款即插即⽤，有了设备（Actor），插⼊设备（Component）就能⽤。</li>
</ul>
</li>
<li>SceneComponent赋予Actor空间变化信息:FTransform: Location, Rotation, Scale</li>
<li>舞台上的演员（Actor），各⾃⾝怀绝技（Component），为玩家上演⼀场精彩的游戏。</li>
</ul>
<h2 id="世界的表达：UWorld-ULevel"><a href="#世界的表达：UWorld-ULevel" class="headerlink" title="世界的表达：UWorld + ULevel"></a>世界的表达：UWorld + ULevel</h2><ul>
<li><p>平⾏世界:GameWorld、PIEWorld（编辑器世界）、PreviewWorld(预览）</p>
</li>
<li><p>关卡构成主⼲卡PersistentLevel+⼦关卡</p>
</li>
<li><p>关卡加载LevelStreaming流式异步加载</p>
<ol>
<li>WorldPartition(UE5)<ol>
<li>分成了许多layer（像是切割了许多⽔平⾯，位于不同的⽔平⾯上就会加载加载不同的范围）</li>
<li>每个layer会设置不同的加载范围，在范围内的就会加载</li>
</ol>
</li>
<li>WorldComposition</li>
<li>LoadByLogic</li>
</ol>
</li>
<li><p>关卡⼤⼩和加载距离</p>
<ul>
<li>LevelBounds + StreamingDistance分层</li>
<li>有多少个关卡，最⼤的覆盖的那个盒⼦</li>
</ul>
</li>
<li><p>关卡蓝图LevelScriptActor</p>
<ul>
<li>定义关卡规则⸺⽐如进⼊该关卡速度变慢之类的</li>
</ul>
</li>
</ul>
<h2 id="世界之上⸺UGameInstance-UEngine"><a href="#世界之上⸺UGameInstance-UEngine" class="headerlink" title="世界之上⸺UGameInstance + UEngine"></a>世界之上⸺UGameInstance + UEngine</h2><ul>
<li><p>UGameInstance</p>
<ul>
<li>信息存在于整个游戏的⽣命周期，不随着地图的切换和销毁</li>
<li>⾮常适合⾮业务逻辑的全局管理操作，如全局UI、设置、预加载</li>
</ul>
</li>
<li><p>UEngine</p>
<ul>
<li>管理GameInstance</li>
<li>拉起游戏重要流程</li>
<li>Browse、LoadMap、SetClientTrave…</li>
</ul>
</li>
<li><p>UE游戏拉起流程</p>
<ul>
<li>init–&gt;start–&gt;loadMap</li>
<li>loadMap中加载了许多内容，⽐如world、模型、player之类的</li>
</ul>
</li>
</ul>
<h1 id="UE游戏模式中的重要对象"><a href="#UE游戏模式中的重要对象" class="headerlink" title="UE游戏模式中的重要对象"></a>UE游戏模式中的重要对象</h1><h2 id="AActor：游戏中最重要的实体"><a href="#AActor：游戏中最重要的实体" class="headerlink" title="AActor：游戏中最重要的实体"></a>AActor：游戏中最重要的实体</h2><ul>
<li>根组件提供世界变化信息</li>
<li>作为⽹络同步的基础单位</li>
<li>标志所有权的Owner指针<ul>
<li>通过owner层层追溯，发射⼦弹伤害了某个敌⼈，追溯是谁伤害了敌⼈：⼦弹⸺枪⸺⻆⾊</li>
</ul>
</li>
<li>标志本地权限的Role枚举<ul>
<li>权威端，你说了算，服务器</li>
<li>主控端，本机</li>
<li>模拟端，看到的别的玩家的游玩</li>
</ul>
</li>
<li>⽣命周期<ul>
<li>分类</li>
<li>关卡内摆放的静态Actor<ul>
<li>从map⾥资源⾥拜访来的</li>
<li>最终还是会回到initially component⾥</li>
</ul>
</li>
</ul>
</li>
<li>SpawnActor创建的动态Actor<ol>
<li>本地Spawn</li>
<li>⽹络序列化</li>
</ol>
</li>
<li>重要的⽣命周期函数<ul>
<li>BeginPlay</li>
<li>EndPlay</li>
<li>Tick</li>
</ul>
</li>
<li>重要的⽣命周期函数<ul>
<li>BeginPlay◦ </li>
<li>Tick</li>
<li>EndPlay：在某些条件达成之后就误了<ul>
<li>处理结束之后怎么做</li>
</ul>
</li>
<li>GC完成收尾⼯作<ul>
<li>注意有效性的判断<ul>
<li>从level的数组⾥丢出去，⽆⼈认领</li>
<li>最后被GC回收了</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="APawn：例如国际象棋中的小兵"><a href="#APawn：例如国际象棋中的小兵" class="headerlink" title="APawn：例如国际象棋中的小兵"></a>APawn：例如国际象棋中的小兵</h2><blockquote>
<p>The <strong>Pawn</strong> class is the base class of all Actors that can be controlled by players or AI. A Pawn is the physical representation of a player or AI entity within the world. This not only means that the Pawn determines what the player or AI entity looks like visually, but also how it interacts with the world in terms of collisions and other physical interactions. This can be confusing in certain circumstances as some types of games may not have a visible player mesh or avatar within the game. Regardless, the Pawn still represents the physical location, rotation, etc. of a player or entity within the game. A Character is a special type of Pawn that has the ability to walk around.</p>
<p>By default, there is a one-to-one relationship between Controllers and Pawns; meaning, each Controller controls only one Pawn at any given time. Also, Pawns spawned during gameplay are not automatically possessed by a Controller.</p>
</blockquote>
<p>Pawn类是所有可以由玩家或AI控制的Actor的基类。棋子是玩家或AI实体在世界中的物理表示。这不仅意味着Pawn决定了玩家或AI实体在视觉上的样子，而且还决定了它在碰撞和其他物理交互方面如何与世界互动。这在某些情况下可能会令人困惑，因为某些类型的游戏可能在游戏内没有可见的玩家网格或化身。无论如何，棋子仍然代表游戏中玩家或实体的物理位置，旋转等。角色是一种特殊类型的棋子，有能力四处走动。</p>
<p>默认情况下，控制器和兵之间是一对一的关系;这意味着，每个控制器在任何给定时间只能控制一个兵。此外，游戏过程中产生的棋子不会自动被控制器拥有。</p>
<ul>
<li>可操控的</li>
<li>多种多样的形式<ul>
<li>⻋⼦、机甲（载具）</li>
</ul>
</li>
<li>被controller控制</li>
<li>基础的输⼊、移动框架的⽀持<ul>
<li>⽣产者消费者模型框架</li>
</ul>
</li>
<li>常⽤派⽣类<ul>
<li>ADefaultPawn<ul>
<li>简单球形碰撞 USphereComponent</li>
<li>简单外显 UStaticMeshComponent</li>
<li>简单移动组件 UFloatingPawnMovement</li>
<li>基础的键盘、⼿柄映射</li>
</ul>
</li>
</ul>
</li>
<li>ASpectatorPawn<ul>
<li>去掉外显 UStaticMeshComponent，不应该被别⼈看到</li>
<li>移动组件替换成忽略时间缩放的USpectatorPawnMovement<ul>
<li>观战的时候可以把全局暂停</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="ACharacter-人型角色"><a href="#ACharacter-人型角色" class="headerlink" title="ACharacter 人型角色"></a>ACharacter 人型角色</h2><ul>
<li>近似仿真⼈形的胶囊体碰撞盒UCapsuleComponent<ul>
<li>在保证⼀定真实性的同时，节约性能</li>
<li>缺点：⽐如脚已经离地但是仍然没掉下去，因为胶囊体还没离开</li>
</ul>
</li>
<li>⻣骼模型USkeletalMeshComponent<ul>
<li>⽐如射击的时候要知道打到的是头还是脚</li>
<li>动画蓝图赋予⼈物⽣动表现</li>
</ul>
</li>
<li>⼈物移动组件UCharacterMovementComponent<ol>
<li>配合胶囊体完成Walking\Falling\Swimming\Flying等多种仿真移动计算</li>
<li>提供Custom⾃定义移动模式供扩展</li>
<li>⽹络游戏移动同步架构<ol>
<li>主控端预表现</li>
<li>服务器端校验</li>
<li>模拟端预测<ol>
<li>match进⾏⼀个差值，减少位置的突变，移动不是⼀帧⼀帧的</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ul>
<h1 id="AController和APawn的双向奔赴"><a href="#AController和APawn的双向奔赴" class="headerlink" title="AController和APawn的双向奔赴"></a>AController和APawn的双向奔赴</h1><ul>
<li>通过Possess和PossessedBy你就是个有主的Pawn了。</li>
<li>Controller、PlayerState指针赋值</li>
<li>网络游戏中Role的改变</li>
</ul>
<h1 id="AplayerController"><a href="#AplayerController" class="headerlink" title="AplayerController"></a>AplayerController</h1><p>​	<strong>可以理解为提线木偶的操控者</strong></p>
<ul>
<li>UInputComponent</li>
</ul>
<p>​		绑定输入映射</p>
<ul>
<li>APlayerCameraManager</li>
</ul>
<p>​		通过ViewTarget上相机臂作⽤后的UCameraComponent计算相机位置</p>
<ul>
<li>AHUD (heads-up display) 头显</li>
</ul>
<p>​		注意和UI的区别，逐渐被更灵活的UMG取代</p>
<ul>
<li>⽹络连接所有权</li>
</ul>
<p>​		注意仅在主控端及服务器存在PlayerController</p>
<h1 id="AGameMode"><a href="#AGameMode" class="headerlink" title="AGameMode"></a>AGameMode</h1><p><strong>这个是真的游戏模式</strong></p>
<ul>
<li>仅服务器拥有，掌控整体游戏流程</li>
<li>定义游戏模式⽤的基础类型</li>
<li>纯服务器逻辑的操作，如AI</li>
<li>AGameMode和AGameModeBase区别<ul>
<li>AGameModeBase，这是所有GameMode的基类，是经典的AGameMode简化版本。</li>
<li>AGameMode是AGameModeBase的⼦类。AGameMode更适⽤于标准对抗类游戏（如多⼈射击游戏），完善了对局和⽐赛的概念。</li>
</ul>
</li>
</ul>
<h1 id="AGameState-游戏状态"><a href="#AGameState-游戏状态" class="headerlink" title="AGameState 游戏状态"></a>AGameState 游戏状态</h1><ul>
<li>所有端都共享同步的游戏数据</li>
<li>AGameState和AGameStateBase的区别。</li>
<li>类似AGameMode和AGameModeBase的关系。</li>
<li>AGameState是AGameStateBase的⼦类。</li>
<li>AGameMode更适⽤于标准对抗类游戏（如多⼈射击游戏），完善了对局和⽐赛的概念。</li>
</ul>
<h1 id="APlayerState玩家状态"><a href="#APlayerState玩家状态" class="headerlink" title="APlayerState玩家状态"></a>APlayerState玩家状态</h1><ul>
<li>所有端都共享同步的游戏数据</li>
<li>PlayerState、Character、Controller的职责区别</li>
</ul>
<h1 id="作业部分："><a href="#作业部分：" class="headerlink" title="作业部分："></a><span id = "作业部分">作业部分：<span></h1><p>作业是在第一人称设计模板项目中实现以下功能：</p>
<p>一、物件规则：</p>
<ul>
<li>设计命中方块，获得积分X分</li>
<li>方块被子弹命中后缩放为Y倍，再次被命中后销毁</li>
</ul>
<p>二、游戏流程：</p>
<ol>
<li>游戏开始时随机N个方块成为“重要目标”，射击命中后获得双倍积分。</li>
<li>游戏开始后限时T秒，时间到后游戏结算，打印日志输出每个玩家获得的积分和所有玩家获得的总积分</li>
</ol>
<p>三、附加题</p>
<ol>
<li>利用UMG制作结算UI替代日志打印</li>
<li>支持多人联机</li>
</ol>
<p><strong>（目前还不太懂UE的C++的代码规范和继承调用结构，就先用蓝图做一做😭）</strong></p>
<h2 id="效果视频"><a href="#效果视频" class="headerlink" title="效果视频"></a>效果视频</h2><p><strong>如果您不想看细节那么可以直接看我的效果视频：</strong></p>
<iframe src="//player.bilibili.com/player.html?isOutside=true&aid=113565109459051&bvid=BV1cNzqYCETp&cid=27089309655&p=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"></iframe>

<h2 id="一、物件规则："><a href="#一、物件规则：" class="headerlink" title="一、物件规则："></a>一、物件规则：</h2><p>​	首先对于“设计命中方块，获得积分X分；方块被子弹命中后缩放为Y倍，再次被命中后销毁”我做以下操作：</p>
<ol>
<li>​	为了实现这个操作，那么我需要先在我的Character中设置一个变量：例如我是在BP_FirstPersonCharacter中进行设置，添加变量Score,类型为Integer。并且将其设置为Public,默认值设置为0。这表示我目前这个角色所得的所有积分。</li>
</ol>
<p><img data-src="https://raw.githubusercontent.com/jianingdai/Blog_img/main/img202411291011934.png" alt="image-20241129101113865"></p>
<p><img data-src="https://raw.githubusercontent.com/jianingdai/Blog_img/main/img202411291013668.png" alt="image-20241129101310590"></p>
<ol start="2">
<li>​	其次我们需要对于我们要射击的方块针对性的进行一下小小的修改。我们可以先创建一个继承于Actor的蓝图IBox。对于该类我们，首先我们先改一下材质，来和地图中的其他的方块从外形上来进行分割。这个材质的外形如下面所示：</li>
</ol>
<p>​					<img data-src="https://raw.githubusercontent.com/jianingdai/Blog_img/main/img202411291024975.png" alt="image-20241129102444784"></p>
<ol start="3">
<li>​	然后给该蓝图设置：可以被命中，并且产生碰撞。并且设置以下的变量：</li>
</ol>
<ul>
<li>缩放倍数Y，float型。默认设置为0.5</li>
</ul>
<blockquote>
<p>0.5表示第一次被击中后该方块会进行缩放，变成原来的0.5倍</p>
</blockquote>
<ul>
<li>hitcount，Integer型，默认值设置为0</li>
</ul>
<blockquote>
<p>该变量可以进行记录我们的该方块的被击打次数。默认被击打次数为0</p>
</blockquote>
<ul>
<li>方块得分X，Integer型，默认值为10</li>
</ul>
<blockquote>
<p>表示我们如果命中该方块，那么命中该方块的角色的得分Score会进行增加X分，此时若要实现多人联机模式，那么就需要对于产生EventHit的“子弹”进行溯源找到对应的Charactor。</p>
</blockquote>
<ul>
<li>IsImportant，Boolean型，默认值为False，设置为Public。</li>
</ul>
<blockquote>
<p>表示该目标实例是否是重要目标，若击中重要目标那么就会产生双倍得分并且这一变量可以在外部调用和编辑，以便我们可以在游戏开始的时候对于地图中的重要目标进行初始化，来随机选取特定个方块设置为重要目标</p>
</blockquote>
<p>IBox中变量的全家福如下：</p>
<p><img data-src="https://raw.githubusercontent.com/jianingdai/Blog_img/main/img202411291052816.png" alt="image-20241129105252722"></p>
<ol start="4">
<li>​	首先在IBox的蓝图中，我们先生成一个EventHit事件检查碰撞，并且检查碰撞的Other对象是否为子弹实例，如果是那么就找到对应的射击角色然后进入流程并且接入判断本实例是否是important实例的Branch：</li>
</ol>
<p><img data-src="https://raw.githubusercontent.com/jianingdai/Blog_img/main/img202411291413133.png" alt="image-20241129141320002"></p>
<ol start="5">
<li>​	然后根据本目标是否是重要目标进行加分操作，如果是重要目标那么就对对应的Charactor的Score变量加上双倍的对应得分，如果不是那么就加上单倍得分。</li>
</ol>
<p><img data-src="https://raw.githubusercontent.com/jianingdai/Blog_img/main/img202411291416810.png" alt="image-20241129141624694"></p>
<ol start="6">
<li>​	之后再对本实例中的hitcount变量进行加一操作并且每次加一结束后要进行判断，判断该物体的受打击次数并且转跳到对应的分支。</li>
</ol>
<p><img data-src="https://raw.githubusercontent.com/jianingdai/Blog_img/main/img202411291419347.png" alt="image-20241129141911259"></p>
<ol start="7">
<li>​	最后根据被击中的次数来对箱子产生销毁或者缩放操作。</li>
</ol>
<p><img data-src="https://raw.githubusercontent.com/jianingdai/Blog_img/main/img202411291420702.png" alt="image-20241129142027582"></p>
<ol start="8">
<li>​	同时我也对于BP_FirstPersonProjectile类进行了一些修改。关闭了子弹的“抛射物反弹”功能和“重力功能”。还有就是碰撞检测到后即可销毁等一些操作。</li>
</ol>
<p>至此物件规则这一部分就已经完成了。</p>
<h2 id="二、游戏流程"><a href="#二、游戏流程" class="headerlink" title="二、游戏流程"></a>二、游戏流程</h2><blockquote>
<ol>
<li>游戏开始时随机N个方块成为“重要目标”，射击命中后获得双倍积分。</li>
<li>游戏开始后限时T秒，时间到后游戏结算，打印日志输出每个玩家获得的积分和所有玩家获得的总积分</li>
</ol>
</blockquote>
<p>​	对于该目标我需要对于游戏的GameMode蓝图进行操作，并且在其中添加一些规则。</p>
<p>为了实现以上的功能我在BP_FirstPersonGameMode中设置了以下变量：</p>
<p><img data-src="https://raw.githubusercontent.com/jianingdai/Blog_img/main/img202411291435655.png" alt="image-20241129143528584"></p>
<p>其中GameTimeLimit指定了游戏的限时规则。在蓝图中这样子显示</p>
<p><img data-src="https://raw.githubusercontent.com/jianingdai/Blog_img/main/img202411291437539.png" alt="image-20241129143733448"></p>
<p>其中OnGameTimerTick函数我做出的设计如下：</p>
<p><img data-src="https://raw.githubusercontent.com/jianingdai/Blog_img/main/img202411291438914.png" alt="image-20241129143847788"></p>
<p>其中的末尾函数OnGameEnd函数我的设计如下，就是简单的打印输入总积分。</p>
<blockquote>
<p>这里没有设置UI和跳出是因为我个人学校课业压力和科研压力和时间紧迫的原因，（更多是因为我自己菜😭）</p>
</blockquote>
<p><img data-src="https://raw.githubusercontent.com/jianingdai/Blog_img/main/img202411291441875.png" alt="image-20241129144158763"></p>
<p>之后在主逻辑蓝图中取出所有的实例并且对于其中的实例循环N次找出其中的N个随机的重要目标并进行相关操作：</p>
<p><img data-src="https://raw.githubusercontent.com/jianingdai/Blog_img/main/img202411291452639.png" alt="image-20241129145226565"></p>
<p><img data-src="https://raw.githubusercontent.com/jianingdai/Blog_img/main/img202411291454280.png" alt="image-20241129145401201"></p>
<p>至此所有的主逻辑设计都完成了。</p>
<h2 id="三、附加：简单UI设计"><a href="#三、附加：简单UI设计" class="headerlink" title="三、附加：简单UI设计"></a>三、附加：简单UI设计</h2><p>设计结果如下图所示：</p>
<p><img data-src="https://raw.githubusercontent.com/jianingdai/Blog_img/main/img202411291509578.png" alt="image-20241129150902463"></p>
<p>其中两个TextBlock函数分别绑定：Score（位于Charactor）、CurrentGameTime(位于GameMode)两个变量。</p>
<p>总结下来还是比较简陋的完成了作业。</p>
<p>演示图片：</p>
<p>以下为场景摆放</p>
<p><img data-src="https://raw.githubusercontent.com/jianingdai/Blog_img/main/img202411291515872.png" alt="image-20241129151556625"></p>
<p>开始游戏后材质变成草皮的方块就是被系统选定的重要目标。</p>
<p><img data-src="https://raw.githubusercontent.com/jianingdai/Blog_img/main/img202411291516354.png" alt="image-20241129151647094"></p>
<p>当第一次击中目标后方块会产生缩放效果</p>
<p><img data-src="https://raw.githubusercontent.com/jianingdai/Blog_img/main/img202411291519881.png" alt="image-20241129151928706"></p>
<p>第二次击中后会销毁方块（这里没抓住timing就没截到图）建议还是查看录屏。</p>
]]></content>
      <categories>
        <category>UE5</category>
      </categories>
      <tags>
        <tag>UE5</tag>
      </tags>
  </entry>
  <entry>
    <title>GNN_Learing</title>
    <url>/2024/11/25/GNN-Learing/</url>
    <content><![CDATA[<h1 id="文档说明："><a href="#文档说明：" class="headerlink" title="文档说明："></a>文档说明：</h1><p>​	我本身的研究方向就是利用<strong>GNN（图神经网络 Graph neural network）</strong>解决<code>软件运维问题/产业链风险问题</code>的，这篇文章就主要是偏向于技术报告似的学习文章，同时也包含一些相关的实验作为支撑。本文章主要以供应链来为例进行说明GNN在供应链等现实实例上面的具体应用方法。</p>
<h1 id="图神经网络"><a href="#图神经网络" class="headerlink" title="图神经网络"></a>图神经网络</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>​	首先就是图无处不在；现实世界中的物体通常用它们与其他事物的联系来定义。一组物体以及它们之间的联系自然地表示为图。我们在这里先明确一下，本文章所提到所有的图（Graph）不是指的 “图像（image）” 中的图，图表示一组实体（节点）之间的关系（边）。【A graph represents the relations (<em>edges</em>) between a collection of entities (<em>nodes</em>).】一个标准的图包括（V,E,U），其中V代表Vertex（节点），E代表Edge（边），U代表Global attributes（全局属性）。如下图（image）中显示的就是一个典型的图：</p>
<p><img data-src="https://raw.githubusercontent.com/jianingdai/Blog_img/main/img202412151605608.png" alt="image-20241215160506512"></p>
<p>​	图中的信息可以通过顶点（Vertex）嵌入或者边（Edge）嵌入等方式来利用图存储信息。全局（或主节点）嵌入。图分为有向图和无向图。</p>
<p>​	目前的研究方向中除了经典的图数据对象，还有例如图像可以化为图【Images as graphs】、文本作为图【Text as graphs】 等等一些意想不到的更为广泛的应用。</p>
<h2 id="典型问题"><a href="#典型问题" class="headerlink" title="典型问题"></a>典型问题</h2><p>​	我们已经描述了一些图的简单介绍，但我们在这些数据上想执行哪些任务呢？在图上，有三种一般的预测任务类型：图级别、节点级别和边级别。</p>
<ol>
<li>在图级任务中，我们预测整个图的一个属性。</li>
<li>对于节点级任务，我们预测图中每个节点的某些属性。</li>
<li>对于边级任务，我们想要预测图中边的属性或存在性。</li>
</ol>
<p>​	对于上述描述的三个预测级别问题（图级别、节点级别和边级别），我们将展示所有这些问题都可以使用单个模型类别，即 GNN 来解决。但首先，让我们在下一章节【<a href="#GNNInSupplyChain">GNN在供应链中的应用</a>】为每个问题提供具体的例子。</p>
<h2 id="机器学习中使用图面临的挑战"><a href="#机器学习中使用图面临的挑战" class="headerlink" title="机器学习中使用图面临的挑战"></a>机器学习中使用图面临的挑战</h2><p>​	那么，我们如何使用神经网络来解决这些不同的图任务呢？第一步是考虑我们如何表示图以与神经网络兼容。</p>
<p>​	机器学习模型通常以矩形或网格状数组作为输入。因此，如何将它们表示为与深度学习兼容的格式并不直观。图有四种类型的信息，我们可能会想要使用它们来进行预测：节点、边、全局上下文和连通性。前三种相对简单：例如，使用节点，我们可以形成一个节点特征矩阵 $N$ ，通过为每个节点分配一个索引 $i$ 并将特征 $node_i$存储在 $N$ 中。虽然这些矩阵具有可变数量的示例，但它们可以无需任何特殊技术进行处理。</p>
<p>​	然而，表示图的连接性更为复杂。最明显的选择可能是使用邻接矩阵，因为这种表示很容易张量化。然而，这种表示有几个缺点。从示例数据集表中，我们看到图中节点的数量可以达到数百万，每个节点的边数可能高度可变。通常，这会导致非常稀疏的邻接矩阵，这会导致空间效率低下。</p>
<p>​	另一个问题是，存在许多可以编码相同连接的邻接矩阵，并且无法保证这些不同的矩阵在深度神经网络中会产生相同的结果（也就是说，它们不是排列不变的）。</p>
<p>​	一种优雅且内存高效的稀疏矩阵表示方法是作为邻接表。这些描述了节点之间的边连接性，例如在邻接表的第 k 个条目中，边 $e_k$ 之间的连接性用元组（i,j）表示。由于我们预计边的数量远低于邻接矩阵的条目数量 $\left( n_{\text{nodes}}^2 \right)$，我们避免了在图的不连通部分进行计算和存储。</p>
<p>应注意，该图使用每个节点&#x2F;边&#x2F;全局的标量值，但大多数实际张量表示具有每个图属性的向量。我们将处理的节点张量大小为 $\left[ n_{\text{n}odes} \right]$ ，而不是 $[n_{\text{nodes}}, node_{\text{dim}}]$ 大小的节点张量。其他图属性也是如此。</p>
<h2 id="最简单的图神经网络："><a href="#最简单的图神经网络：" class="headerlink" title="最简单的图神经网络："></a>最简单的图神经网络：</h2><p>​	使用向量代替标量，我们现在可以构建一个 GNN 了。我们将从最简单的 GNN 架构开始，其中一个我们为所有图属性（节点、边、全局）学习新的嵌入，但我们还没有使用图的连接性。</p>
<p>​	该 GNN 在每个图的组件上使用一个单独的多层感知器（MLP）；我们称这为 GNN 层。对于每个节点向量，我们应用 MLP 并得到一个学习的节点向量。对于每个边，我们学习一个边的嵌入，并且对于全局上下文向量，我们学习整个图的单一嵌入。</p>
<p><img data-src="https://raw.githubusercontent.com/jianingdai/Blog_img/main/img202412151708305.png" alt="image-20241215170814254"></p>
<blockquote>
<p>一个简单 GNN 的单层。图是输入，每个组件（V,E,U）通过 MLP 更新以生成新的图。每个函数下标表示 GNN 模型第 n 层不同图属性的独立函数。</p>
</blockquote>
<p>​	和其他的神经网络模块或者层的常见情况一样，我们可以将这些图神经网络堆叠在一起。</p>
<p>​	因为图神经网络（GNN）不会更新输入图的连接性，所以我们可以用与输入图相同的邻接表和相同数量的特征向量来描述 GNN 的输出图。但是，输出图具有更新的嵌入，因为 GNN 已经更新了每个节点、边和全局上下文表示。</p>
<p>​	现在我们可以构建一个简单的 GNN 模型，并通过在图的不同部分之间路由信息来进行二元预测。这种池化技术将作为构建更复杂 GNN 模型的基石。如果我们有新的图属性，我们只需定义如何从一个属性传递信息到另一个属性。</p>
<h1 id="GNN在供应链中的应用"><a href="#GNN在供应链中的应用" class="headerlink" title="GNN在供应链中的应用"></a><span id="GNNInSupplyChain">GNN在供应链中的应用<span></h1><h2 id="供应链与GNN"><a href="#供应链与GNN" class="headerlink" title="供应链与GNN"></a>供应链与GNN</h2><p>​	供应链是一个动态的组织网络，这些组织参与各种过程和活动，通过上下游的链接为消费者生产以产品和服务形式的价值，涉及信息、商品和资金在其各个阶段的持续流动。由于供应链由复杂网络中的相互连接实体组成，它涉及复杂的相互依赖和决策过程。此外，现代供应链产生大量数据，实体之间的关系和依赖需要复杂的模型来捕捉。使用计算方法解决供应链问题的潜在好处包括提高协调性、高效物流和有效的供应链解决方案。</p>
<p><img data-src="https://raw.githubusercontent.com/jianingdai/Blog_img/main/img202412161345113.png" alt="image-20241216134516991"></p>
<blockquote>
<p>图1：供应链作为相互连接的公司、产品、分销商和客户的图。</p>
</blockquote>
<p>​	GNN在研究领域用于知识图谱推理和异常检测。它们的优势在于有效地捕捉非欧几里得数据中的依赖关系，使它们适用于涉及连接实体的任务。与供应链相连，GNNs 可以实现对供应链中复杂关系和依赖关系的建模，促进销售预测、生产计划、风险评估和揭示潜在风险等任务。 通过利用图神经网络方法，可以优化供应链运营，增强风险管理，并通过从图数据中提取相关信息和推断多种类型的隐藏关系风险来改善决策过程。</p>
<p>​	生产计划在供应链管理中起着关键作用，通过预测未来产品或服务需求，帮助组织优化库存水平、生产计划和资源配置。需求预测的准确性对公司收入有重大影响，促使人们探索各种深度学习和机器学习模型。虽然传统模型已显示出潜力，但图神经网络（GNNs）在模拟供应链中固有的网络结构方面具有独特优势，例如全球贸易流动或社交网络，如图 1 所示。尽管在供应链中关于 GNNs 的研究有限，但最近的研究已经证明了它们在隐藏链接预测等任务中的实用性，以减轻风险和揭示隐藏的依赖关系。 然而，仍存在几个挑战：缺乏针对 GNN 在供应链应用中的全面概念基础和特定公式，研究人员往往缺乏对 GNN 在此领域可以解决的多样化任务的意识。此外，公开可用数据集和适当基准的稀缺阻碍了对供应链中 GNN 模型进行彻底评估和发展的工作。这些差距强调了详细方法和稳健数据集对于推进 GNN 在供应链优化中的研究和实际应用的重要性。</p>
<p>​	近年来，图神经网络（GNN）的进步提高了需求预测和运营弹性，从而实现了更高效和自适应的供应链管理。图表示学习通过揭示供应链网络中的隐藏依赖关系并建立在之前的 GNN 链接预测研究的基础上，进一步提高了链接预测。这些发展突出了机器学习在优化需求预测和生产计划方面的有效性。显著的贡献包括基于 GNN 的隐藏链接预测以减轻风险以及将 GNN 与知识图谱推理相结合以识别潜在风险和提取见解。</p>
<p>​	图神经网络已被应用于供应商推荐，通过分析网络数据在供应链中断期间建议替代供应商。分层可迁移图神经网络简化了复杂的供应链，并使用基于中心性的知识迁移模块进行风险评估。图神经网络还提高了基于供应链数据的行业分类精度，并在供应链金融的欺诈检测和解释中使用了异构图神经网络，利用多视角信息。</p>
<p>​	图可以分为不同类型，包括同构图，其中所有节点和边都是同一类型，以及异构图，涉及多种类型的节点和边。每种类型都针对特定的应用进行定制，具体取决于所表示的结构和关系。同构图适用于更简单的关系，例如社交网络，其中节点代表人物，边代表友谊。然而，异构图具有多种类型的节点和边，可以捕捉更复杂的交互，如以节点代表员工、部门和项目的商业网络。超图通过允许超边连接超过两个节点来进一步扩展这种复杂性，这对于建模多方交互很有用。为不同类型的图设计的不同类型的 GNN 可以用于供应链应用。</p>
<p>​	图神经网络可以分为三种主要类型：卷积型、注意力型和消息传递型。</p>
<ul>
<li><p>​	在供应链分析中，卷积图神经网络可用于需求预测和库存优化等任务，其中各种实体（例如，供应商和分销商）之间的关系相对均匀。这种方法简单直接且计算效率高，使其适用于大规模图。然而，它往往忽略了不同邻居的重要性差异，可能导致在某些关系中比其他关系更重要的情况下性能不佳。在供应链分析中，卷积图神经网络可用于需求预测和库存优化等任务，其中各种实体（例如，供应商和分销商）之间的关系相对均匀。</p>
</li>
<li><p>​	注意力图神经网络通过引入可学习的自注意力机制，为不同的邻居分配不同的重要性，从而解决了卷积图神经网络（GNNs）的局限性。在这种类型中，交互是隐式的。这种方法允许模型专注于更相关的连接，从而提高预测准确性。缺点是计算成本和复杂性的增加。在供应链分析中，注意力图神经网络（Attentional GNNs）特别适用于异常检测和风险管理，能够优先考虑关键关系的能力可以导致更准确的见解。</p>
</li>
<li><p>消息传递图神经网络采用更灵活的方法，允许在边之间传递任意消息。这相当于在边之间计算任意向量（消息）。这种方法高度表达性，能够捕捉图中复杂的依赖关系。然而，它可能计算密集，并且可能需要大量的训练数据才能实现良好的性能。在供应链分析中，消息传递图神经网络可以应用于生产预测和动态路由，其中建模复杂交互的能力至关重要。</p>
</li>
</ul>
<p>​	另一个有趣且有效的用于供应链分析的 GNN 模型是时序图神经网络（Temporal GNN）。时序 GNN 通过引入时间维度扩展了传统的 GNN，使它们能够模拟动态图，其中关系和特征随时间变化。时序 GNN 的一般方程可以表示为：</p>
<p><img data-src="https://raw.githubusercontent.com/jianingdai/Blog_img/main/img202412161426067.png" alt="image-20241216142645029"></p>
<p>​	$𝐡<em>v^{(t)}$表示节点 v 在时间 t 的隐藏状态， 𝒩⁢(v) 表示 v 的邻居， $𝐀</em>{u⁢v}^{(t)}$ 是时间邻接矩阵， $𝐖^{(t)}$ 和 $𝐁^{(t)}$ 是可学习的权重矩阵， σ 是激活函数。时间图神经网络对于建模动态系统至关重要，在这些系统中，关系和特征随时间演变。在供应链分析中，它们能够预测时间依赖现象，如需求波动、运输延误和库存水平。通过捕捉时间模式，这些模型有助于洞察未来趋势，帮助企业优化运营并预测中断。</p>
<p>​	时空图神经网络，作为时间图神经网络的一个子集，结合了空间和时间信息，使它们在供应链分析中特别强大。这些模型不仅能捕捉实体之间不断变化的关系，还能捕捉它们的时空依赖性。在供应链中，时空图神经网络可以显著提高诸如需求预测、动态路线优化和实时库存管理任务的预测准确性。利用空间和时间动态，这些模型能够实现更明智的决策，从而提高供应链运营的效率和弹性。</p>
<p>​	供应链由众多相互连接的组件组成，包括生产设施、产品和原材料。一个行业中存在各种生产设施，每个设施负责生产不同类型的产品或不同库存单位的产品。每个组件，无论是不同的生产设施还是同一生产设施内的不同产品组，都可以表示为图中的一个节点。此图形模型中的连接（边）表示节点之间的关系。同一组内的产品或在同一设施生产的产品由于共同因素（如生产能力、原材料需求和需求趋势）而共享连接。此外，由于共享资源、生产依赖性或物流联系，生产设施之间也可能相互关联。通过采用基于图的方法，可以系统地分析这些复杂关系。这种图形表示允许整合每个节点的各种数据属性，包括需求、生产能力、销售指标，从而实现对供应链网络的全面分析。</p>
<p><img data-src="https://raw.githubusercontent.com/jianingdai/Blog_img/main/img202412161442294.png" alt="image-20241216144207246"></p>
<blockquote>
<p>图 2：同构图中的供应链问题表述。方框代表各种产品类型，颜色表示不同的组别。它们根据产品组和生产设施紧密排列。不同的关系连接表示共享的原材料需求、产品间的相互依赖以及其他影响。</p>
</blockquote>
<p>​	为了说明概念，考虑一家薯片制造公司。这家公司运营两个生产基地，生产四种类型的薯片：普通薯片、三角形薯片、环形薯片和条状薯片，如图 2 所示，每种薯片用不同的颜色表示。每种薯片都有各种包装尺寸，如 30 克、50 克和 100 克，图中的不同盒子表示。在这个图形模型中，连接表示薯片、设施和生产过程之间的关系。例如，同一组的产品或在同一设施生产的产品由于共同因素（如生产能力、原材料需求和需求趋势）而共享连接。如果某薯片组的日生产能力限制为 500 公斤，增加 500 克包装的生产可能需要减少 30 克包装的产量，这表明了内部组之间的依赖性。此外，如果一台机器一次只能生产一种口味，那么在同一天生产多种口味会因为更换时间而效率低下。 如果一个设施专注于特定类型的芯片，在同一设施内生产不同类型可能会导致效率低下。这些相互依赖关系如图 2 所示，在同一设施内以连接的形式呈现。设施间也存在关系，其中在一个设施中生产特定类型的芯片可能会影响另一个设施的生产能力。产品组之间共享的原料可以创造依赖关系，其中一个组的生产会影响另一个组。</p>
<p>​	通过利用基于图的方法，这些复杂关系可以系统性地进行分析。图神经网络利用这种结构化表示来增强生产预测和规划，为供应链管理挑战提供全面解决方案。将供应链问题表述为图，使得供应链元素之间复杂关系的可视化和分析成为可能。图 3 展示了表示供应链网络的异构图。它包括产品（米色）、工厂（青色）和存储位置（紫色）的节点，以及表示这些实体之间关系的边。实线表示产品和工厂之间的连接，而虚线表示产品和存储位置之间的链接，展示了供应链内部的复杂性和相互依赖性。</p>
<p><img data-src="https://raw.githubusercontent.com/jianingdai/Blog_img/main/img202412161443836.png" alt="image-20241216144356771"></p>
<blockquote>
<p>图 3：使用 SCG 数据集的异构图示例。产品、工厂和存储位置是节点，它们之间的关系是边。</p>
</blockquote>
<h2 id="实验部分："><a href="#实验部分：" class="headerlink" title="实验部分："></a>实验部分：</h2><p>这里采用了SCG数据集：该数据集可在 GitHub 上公开获取，网址为 <a href="https://github.com/CIOL-SUST/SCG">https://github.com/CIOL-SUST/SCG</a> ，遵循 LGPL-2.1 许可证。</p>
<p>数据集中的图。数据集包含同构（见图 4 中的示例）和异构（见图 3 中的示例）格式的图，节点特征包含四个时间数据点。图的构建、实现、特征选择以及不同图属性的使用取决于具体的应用和需求。在本文中，我们简要描述了这些方面。</p>
<p><img data-src="https://raw.githubusercontent.com/jianingdai/Blog_img/main/img202412161457262.png" alt="image-20241216145745216"></p>
<blockquote>
<p>图4（a）在这里，节点是子组产品，工厂是边。颜色表示不同类型的节点和边。</p>
</blockquote>
<p><img data-src="https://raw.githubusercontent.com/jianingdai/Blog_img/main/img202412161458631.png" alt="image-20241216145815587"></p>
<blockquote>
<p>图4（b）在这里，节点包括产品和存储位置，边表示它们之间的关系。颜色表示不同类型节点和边的不同。</p>
</blockquote>
<blockquote>
<p>图 4：使用 SCG 数据集的均匀图示例。</p>
</blockquote>
<p>​	<strong>数据集统计信息</strong></p>
<table>
<thead>
<tr>
<th>Edge Classes</th>
<th>Edge Count</th>
</tr>
</thead>
<tbody><tr>
<td>Total Edge Types</td>
<td>62</td>
</tr>
<tr>
<td>Total Unique Edges</td>
<td>684</td>
</tr>
<tr>
<td>Class (Group)</td>
<td>5</td>
</tr>
<tr>
<td>Count (Group)</td>
<td>188</td>
</tr>
<tr>
<td>Class (Sub-group)</td>
<td>19</td>
</tr>
<tr>
<td>Count (Sub-group)</td>
<td>52</td>
</tr>
<tr>
<td>Class (Plant)</td>
<td>25</td>
</tr>
<tr>
<td>Count (Plant)</td>
<td>1647</td>
</tr>
<tr>
<td>Class (Storage)</td>
<td>13</td>
</tr>
<tr>
<td>Count (Storage)</td>
<td>3046</td>
</tr>
</tbody></table>
<p>​	在 SCG 中，节点对应不同的产品，而边代表连接这些产品的各种联系：同一产品组或子组，同一工厂或存储位置。</p>
<p>​	在时间数据中，节点特征包括生产、销售订单、分销商的交付和工厂问题。我们有两种模式的所有时间数据：生产单位数量（例如：500 个单位）和生产总重量（例如：10 公吨）。</p>
<p>时间特征的定义：</p>
<ul>
<li>生产，考虑销售订单、客户需求、车辆装载率和交付紧迫性的产品产出量。这个数量通常以单位或公吨来衡量。例如，在一定时间内可能生产了 500 个单位或 10 公吨的产品。</li>
<li>销售订单表示分销商要求的数量，待财务部门批准。它反映了整体产品需求。例如，销售订单可能表明要求 300 个单位或 6 公吨。</li>
<li>发货给分销商表示与订单相符的派送产品，对公司收入有显著影响。例如，发货数据可能显示已向分销商发送了 450 个单位或 9 公吨。</li>
<li>工厂问题涵盖从制造设施发出的所有产品，其中一部分发往分销商，其余的送往仓储仓库。例如，工厂问题报告可能显示已发出 700 个单位或 14 公吨，其中 500 个单位发往分销商，剩余的 200 个单位送往仓库。</li>
</ul>
<h3 id="异常检测："><a href="#异常检测：" class="headerlink" title="异常检测："></a>异常检测：</h3><p>​	为了异常检测，我们以销售订单作为动态时间节点特征，应用具有均方误差损失的模型来识别时间序列数据中的异常。在特定时间段内，图中数据波动增加被视为异常，并需要与公司沟通。这是一种监督方法；遵循 GDN。在模型中，PCA 是一种统计模型；ANN、AE和 LSTM-VAE是基于深度学习的模型；GANF和 GDN是基于 GNN 的时间异常检测模型。在异构任务中，我们利用销售订单数据作为动态时间节点特征。在特定时间段内，图中显著的数据波动被标记为异常，需要与公司沟通。Ad-EHG和 HRGCN是这里的异构 GNN 模型。</p>
<table>
<thead>
<tr>
<th>Models and Type</th>
<th>Model</th>
<th>(k) Anomaly Det. <sup>Hm</sup></th>
<th></th>
<th>(l) Anomaly Det. <sup>Ht</sup></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td>Precision</td>
<td>Recall</td>
<td>Precision</td>
<td>Recall</td>
</tr>
<tr>
<td>Statistical</td>
<td>PCA</td>
<td>31.33%</td>
<td>27.34%</td>
<td>27.24%</td>
<td>28.43%</td>
</tr>
<tr>
<td>Deep Learning</td>
<td>ANN</td>
<td>55.24%</td>
<td>47.75%</td>
<td>53.43%</td>
<td>49.24%</td>
</tr>
<tr>
<td>Deep Learning</td>
<td>AE</td>
<td>75.78%</td>
<td>71.78%</td>
<td>71.22%</td>
<td>69.32%</td>
</tr>
<tr>
<td>Deep Learning</td>
<td>LSTM-VAE</td>
<td>91.87%</td>
<td>86.58%</td>
<td>89.23%</td>
<td>87.24%</td>
</tr>
<tr>
<td>GNN-based</td>
<td>GANF<sup>Hm</sup>&#x2F;Ad-EHG<sup>Ht</sup></td>
<td>85.45%</td>
<td>76.33%</td>
<td>90.34%</td>
<td>89.13%</td>
</tr>
<tr>
<td>GNN-based</td>
<td>GDN<sup>Hm</sup>&#x2F;HRGCN<sup>Ht</sup></td>
<td>94.15%</td>
<td>87.76%</td>
<td>92.43%</td>
<td>89.34%</td>
</tr>
</tbody></table>
<blockquote>
<p>Hm: Homgeneous Graph modelling ( 同构图建模 )，Ht: Heterogeneous Graph modelling ( 异构图建模 )，Det. &#x3D; Detection 检测</p>
</blockquote>
<p>​	在上表中显示，在实验中，基于图模型的得分始终高于其他模型。实验进行了多次，并取平均值。</p>
<p>​	异常检测涉及识别时间序列中与预期模式不符的偏差。在本任务中，表中显示，在精确度和召回率方面，LSTM-VAE 和 GDN 处于领先地位，突显了它们在定位异常方面的有效性。GANF 模型也表现出强劲的性能，强调了基于 GNN 的方法在异常检测中的潜力。</p>
<p>​	在异构异常检测中，目标是检测动态异构图中与预期模式不符的偏差。表中突出显示，基于 GNN 的 HRGCN和 Ad-EHG实现了更高的精确度和召回率，展示了它们在识别异常和突出基于 GNN 的异常检测方法潜力方面的有效性。</p>
]]></content>
      <categories>
        <category>AI</category>
        <category>GNN</category>
      </categories>
      <tags>
        <tag>GNN</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务_gRPC与Protobuf</title>
    <url>/2025/08/06/%E5%BE%AE%E6%9C%8D%E5%8A%A1-gRPC%E4%B8%8EProtobuf/</url>
    <content><![CDATA[<h1 id="微服务与-RPC-概述"><a href="#微服务与-RPC-概述" class="headerlink" title="微服务与 RPC 概述"></a>微服务与 RPC 概述</h1><h2 id="什么是微服务？"><a href="#什么是微服务？" class="headerlink" title="什么是微服务？"></a>什么是微服务？</h2><p>微服务是一种软件架构风格，它将应用程序构建为一组小型、独立的服务。每个服务：</p>
<ul>
<li>运行在自己的进程中</li>
<li>围绕业务功能构建</li>
<li>能够独立部署</li>
<li>通过轻量级机制（通常是 HTTP&#x2F;RPC）通信</li>
</ul>
<h3 id="微服务的优势"><a href="#微服务的优势" class="headerlink" title="微服务的优势"></a>微服务的优势</h3><ol>
<li><strong>独立开发和部署</strong><ul>
<li>不同团队可以独立开发不同服务</li>
<li>服务可以使用最适合的技术栈</li>
<li>可以独立部署和扩展，客户端不用关注服务端实现细节。</li>
</ul>
</li>
<li><strong>故障隔离</strong><ul>
<li>单个服务故障不会导致整个系统崩溃（例如：文档中图片服务异常，不影响正常的文档编辑）</li>
<li>更容易进行故障排查和修复</li>
<li>系统更具弹性，服务可以独立扩缩容（例如：签到服务，遇到紧急运营活动，可以独立扩缩容）</li>
</ul>
</li>
</ol>
<h3 id="微服务面临的挑战"><a href="#微服务面临的挑战" class="headerlink" title="微服务面临的挑战"></a>微服务面临的挑战</h3><ol>
<li><p><strong>服务间通信</strong></p>
<ul>
<li>需要处理网络延迟（例如：网络抖动，导致请求超时）</li>
<li>要考虑服务发现，就是要知道对方服务在哪台机器上</li>
<li>需要处理部分失败，就是对方服务可能挂了，需要有重试机制</li>
</ul>
</li>
<li><p><strong>运维复杂性</strong></p>
<ul>
<li>服务数量增多</li>
<li>部署和监控更复杂</li>
<li>需要更好的运维工具</li>
</ul>
<blockquote>
<p>微服务的粒度要合理设计，不是越细越好，也不是越粗越好。</p>
</blockquote>
</li>
</ol>
<h2 id="微服务与-RPC-的关系"><a href="#微服务与-RPC-的关系" class="headerlink" title="微服务与 RPC 的关系"></a>微服务与 RPC 的关系</h2><p>在微服务架构中，RPC（远程过程调用）扮演着关键角色：</p>
<ol>
<li><strong>服务间通信</strong><ul>
<li>RPC 提供了服务间通信的标准方式</li>
<li>使远程服务调用像本地调用一样简单</li>
<li>处理网络通信的复杂性</li>
</ul>
</li>
<li><strong>接口定义</strong><ul>
<li>RPC 框架（如 gRPC）提供接口定义语言</li>
<li>清晰定义服务间的契约</li>
<li>支持多语言代码生成</li>
</ul>
</li>
<li><strong>性能优化</strong><ul>
<li>二进制协议提高传输效率</li>
<li>支持连接复用</li>
<li>提供流式传输能力</li>
</ul>
</li>
<li><strong>可靠性保证</strong><ul>
<li>内置重试机制</li>
<li>提供超时控制</li>
<li>支持负载均衡</li>
</ul>
</li>
</ol>
<h1 id="RPC-与-gRPC-基础"><a href="#RPC-与-gRPC-基础" class="headerlink" title="RPC 与 gRPC 基础"></a>RPC 与 gRPC 基础</h1><h2 id="什么是-RPC？"><a href="#什么是-RPC？" class="headerlink" title="什么是 RPC？"></a>什么是 RPC？</h2><p>远程过程调用(Remote Procedure Call, RPC)是一种分布式计算的通信协议，允许程序调用另一个地址空间(通常是网络上的另一台计算机)的函数或方法，就像调用本地函数一样。</p>
<p><strong>RPC（Remote Procedure Call）</strong> 的意思是：</p>
<blockquote>
<p><strong>“像调用本地函数一样，去调用远程服务器上的函数。”</strong></p>
</blockquote>
<p><strong>举例：</strong></p>
<p>你写了一个函数 <code>add(a, b)</code> 来求两个数之和。你在本地这样写：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">result := add(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>RPC 让你可以这样调用远程服务器上的 <code>add</code> 函数，<strong>看起来就像是本地函数，但其实它在网络另一端执行。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">你（客户端）               网络               服务器</span><br><span class="line">   |                                            |</span><br><span class="line">   |--- 调用 add(1, 2) ------------------------&gt;|</span><br><span class="line">   |                                            |</span><br><span class="line">   |&lt;---------- 返回结果 3 ---------------------|</span><br></pre></td></tr></table></figure>

<h2 id="为什么用-RPC？"><a href="#为什么用-RPC？" class="headerlink" title="为什么用 RPC？"></a>为什么用 RPC？</h2><ol>
<li>RPC 框架封装了复杂的网络请求逻辑，让你用函数方式去调用远程服务。</li>
<li>微服务架构中，服务之间通过 RPC 通信，可以提高系统的可扩展性和可维护性。</li>
</ol>
<h2 id="RPC-和-HTTP-有啥区别？"><a href="#RPC-和-HTTP-有啥区别？" class="headerlink" title="RPC 和 HTTP 有啥区别？"></a>RPC 和 HTTP 有啥区别？</h2><table>
<thead>
<tr>
<th>项目</th>
<th>RPC</th>
<th>HTTP API</th>
</tr>
</thead>
<tbody><tr>
<td>调用方式</td>
<td>像调用函数</td>
<td>像访问 URL</td>
</tr>
<tr>
<td>数据格式</td>
<td>二进制（如 protobuf）</td>
<td>一般是 JSON 或者表单数据</td>
</tr>
<tr>
<td>性能</td>
<td>通常更高（小体积、低延迟）</td>
<td>相对较低</td>
</tr>
<tr>
<td>接口定义</td>
<td>使用 <code>.proto</code> 或 IDL 文件</td>
<td>通常用 OpenAPI、Swagger 等或者文档</td>
</tr>
</tbody></table>
<h2 id="RPC-的基本工作流程"><a href="#RPC-的基本工作流程" class="headerlink" title="RPC 的基本工作流程"></a>RPC 的基本工作流程</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">你（客户端）               网络               服务器</span><br><span class="line">   |                                            |</span><br><span class="line">   |--- 调用 add(1, 2) ------------------------&gt;|</span><br><span class="line">   |                                            |</span><br><span class="line">   |&lt;---------- 返回结果 3 ---------------------|</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>客户端调用</strong>：客户端调用本地函数</li>
<li><strong>参数序列化</strong>：客户端将参数打包(序列化)，也就是将参数转换为二进制数据</li>
<li><strong>网络传输</strong>：二进制数据通过网络发送到服务端</li>
<li><strong>参数反序列化</strong>：服务端将二进制数据转换为参数。参数包含函数名、参数值、参数类型等。</li>
<li><strong>执行调用</strong>：反序列化后，服务端知道客户端想调用哪个函数，直接执行实际函数，并返回结果（结构体数据）</li>
<li><strong>结果序列化</strong>：服务端将结果（结构体数据）打包，也就是将结果转换为二进制数据</li>
<li><strong>网络传输</strong>：二进制数据通过网络发送回客户端</li>
<li><strong>结果反序列化</strong>：客户端解包结果数据，也就是将二进制数据转换为结构体数据。</li>
<li><strong>返回结果</strong>：客户端程序获得结构体数据，也就是获得函数返回值。</li>
</ol>
<h2 id="常见的-RPC-框架"><a href="#常见的-RPC-框架" class="headerlink" title="常见的 RPC 框架"></a>常见的 RPC 框架</h2><table>
<thead>
<tr>
<th>框架</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>gRPC</td>
<td>Google 出品，支持多语言、基于 HTTP&#x2F;2 和 protobuf</td>
</tr>
<tr>
<td>Thrift</td>
<td>Facebook 出品，灵活多语言</td>
</tr>
<tr>
<td>Dubbo</td>
<td>阿里出品，主要用于 Java 服务</td>
</tr>
<tr>
<td>JSON-RPC</td>
<td>使用 JSON 格式传输</td>
</tr>
</tbody></table>
<h3 id="微服务要解决的主要问题"><a href="#微服务要解决的主要问题" class="headerlink" title="微服务要解决的主要问题"></a>微服务要解决的主要问题</h3><ul>
<li>服务注册与发现（要知道对方在哪）</li>
<li>数据传输</li>
</ul>
<h2 id="数据传输：为什么需要编解码？"><a href="#数据传输：为什么需要编解码？" class="headerlink" title="数据传输：为什么需要编解码？"></a>数据传输：为什么需要编解码？</h2><h3 id="JSON-数据的问题"><a href="#JSON-数据的问题" class="headerlink" title="JSON 数据的问题"></a>JSON 数据的问题</h3><p>JSON确实可以作为RPC场景下的数据传输方案。</p>
<ol>
<li>体积大</li>
<li>解析慢</li>
<li>针对二进制数据，没有很好的解决方案。</li>
</ol>
<h3 id="二进制数据的问题"><a href="#二进制数据的问题" class="headerlink" title="二进制数据的问题"></a>二进制数据的问题</h3><p>在上面的 RPC 工作流程中，我们可以看到序列化（编码）和反序列化（解码）是非常重要的步骤。那么为什么需要编解码呢？在分布式系统和网络通信中，编解码（序列化和反序列化）解决了以下关键问题：</p>
<ol>
<li><strong>数据传输问题</strong><ul>
<li>计算机内存中的数据结构（如对象、数组）无法直接在网络上传输</li>
<li>不同编程语言的数据表示方式不同</li>
<li>网络传输只能传输字节流，需要将复杂数据结构转换为字节序列</li>
</ul>
</li>
<li><strong>跨语言通信问题</strong><ul>
<li>Java、Go、Python 等语言的数据类型实现方式不同</li>
<li>编解码提供了一种统一的数据交换格式</li>
<li>使不同语言编写的系统能够相互通信</li>
</ul>
</li>
<li><strong>数据存储问题</strong><ul>
<li>内存中的数据结构需要持久化到磁盘</li>
<li>数据库存储需要将对象转换为可存储的格式</li>
<li>编解码提供了数据持久化的标准方式</li>
</ul>
</li>
<li><strong>性能优化</strong><ul>
<li>减少网络传输的数据量</li>
<li>提高数据处理速度</li>
<li>节省存储空间</li>
</ul>
</li>
<li><strong>版本兼容问题</strong><ul>
<li>数据结构随时间演进</li>
<li>需要保持向前和向后兼容</li>
<li>编解码协议（如 Protobuf）提供了版本兼容机制</li>
</ul>
</li>
</ol>
<h1 id="Protocol-Buffers-详解"><a href="#Protocol-Buffers-详解" class="headerlink" title="Protocol Buffers 详解"></a>Protocol Buffers 详解</h1><p>ProtoBuffer 是 Google 的语言中立、平台中立、可扩展的结构化数据序列化机制</p>
<h2 id="Protobuf-背景与优势"><a href="#Protobuf-背景与优势" class="headerlink" title="Protobuf 背景与优势"></a>Protobuf 背景与优势</h2><ul>
<li><strong>诞生背景</strong>：Google 最初为内部分布式系统设计了一套高效的序列化格式，2008 年将其开源。设计目标是简单高效，生成的二进制数据比 XML 更小、更快。Protobuf 在 Google 内部广泛用于存储和交换结构化信息，并作为其 RPC 系统（即 gRPC 的前身）的基础。</li>
</ul>
<p>一个简单的 .proto 文件示例：</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"><span class="keyword">package</span> example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int32</span> id = <span class="number">2</span>;</span><br><span class="line">  <span class="type">float</span> height = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Protobuf 优势</strong>：<ul>
<li><strong>紧凑体积</strong>：二进制编码格式使消息体积远小于等价的 JSON&#x2F;XML 文本。例如，同一结构的数据，Protobuf 序列化后仅约 99 字节，而 JSON 约 214 字节，提高网络传输效率。</li>
<li><strong>高性能</strong>：Protobuf 的序列化&#x2F;反序列化开销低。实测中，Protobuf 序列化时间约为 JSON 的一半（133ns 对比 249ns），反序列化优势更明显（294ns 对比 1457ns）。</li>
<li><strong>严格模式与兼容性</strong>：通过 <code>.proto</code> 文件定义模式(schema)，Protobuf 强类型检查、明确字段编号和类型，使数据结构变化时可以平滑演进。新增字段时旧客户端可忽略不识别的字段（TLV 形式跳过未知字段），保证向前&#x2F;向后兼容。</li>
<li><strong>多语言和代码生成</strong>：Protobuf 支持多种编程语言，可以用同一 <code>.proto</code> 定义生成各语言的数据访问类和 RPC 接口代码。这在异构微服务环境中非常有用，服务端和客户端可用不同语言开发。</li>
<li><strong>额外注意</strong>：二进制格式可读性差于 JSON，但在追求性能和效率的场景下优势明显。</li>
</ul>
</li>
</ul>
<p><strong>示例性能对比</strong>：下表基于一个简单 <code>Person&#123;name, id, height&#125;</code> 示例进行的测试，比较了 Protobuf 与 JSON 的序列化结果和时间。可以看出，在体积和速度上，Protobuf 均优于 JSON。</p>
<table>
<thead>
<tr>
<th>编码格式</th>
<th>序列化输出大小</th>
<th>序列化时间</th>
<th>反序列化时间</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Protobuf</strong></td>
<td>99 字节</td>
<td>133 纳秒</td>
<td>294 纳秒</td>
</tr>
<tr>
<td><strong>JSON</strong></td>
<td>214 字节</td>
<td>249 纳秒</td>
<td>1457 纳秒</td>
</tr>
</tbody></table>
<h2 id="编码与解码原理"><a href="#编码与解码原理" class="headerlink" title="编码与解码原理"></a>编码与解码原理</h2><h3 id="Varint-编码"><a href="#Varint-编码" class="headerlink" title="Varint 编码"></a>Varint 编码</h3><p>Varint 是一种可变长度整数编码方式，最大支持 64 位整数，用于将<strong>整数编码为变长字节序列</strong>。它通过将整数表示为一系列字节块，每个字节块的<strong>最高位表示是否继续</strong>，其余位表示数值。</p>
<blockquote>
<p>注意：1个字节8位，最高位是符号位，所以实际能表示的整数范围是0-127。</p>
</blockquote>
<p>对于整数、布尔、enum 等类型（Wire Type 0），Protobuf 采用可变长度整数（Varint）编码。较小的数字只占用少量字节，大数字占用更多字节。每个字节的最高位为“继续”标志位：若为 1 表示后续字节仍在，0 表示结束。下图中，将十进制数 300（<code>100101100₂</code>）拆分为两个 7 位块并添加续航位，最终编码成字节序列 <code>[172, 2]</code>。</p>
<blockquote>
<p>注意： Varint 是用的小端序，所以是反着读的。</p>
</blockquote>
<p><img data-src="https://raw.githubusercontent.com/jianingdai/Blog_img/main/img202508071003311.png" alt="image-20250807100352119"></p>
<p><img data-src="https://raw.githubusercontent.com/jianingdai/Blog_img/main/img202508071004721.png" alt="image-20250807100414653"></p>
<p><a href="https://zhuanlan.zhihu.com/p/84250836">详解varint编码原理</a></p>
<p><strong>Protobuf 序列化原理</strong><br>Protobuf 序列化时，将每个消息视为一系列 <code>字段号+类型+值</code> 的键值对（Key-Value）组合。不过二进制流中不包含字段名、类型等描述信息，只有字段编号（Tag）和对应值，解码时必须借助 <code>.proto</code> 模式文件。具体原理包括：</p>
<ul>
<li><strong>Tag 编码</strong>：每个字段由字段号（field number）和 Wire Type（线束类型）共同决定一个 Tag 值。计算公式为：<code>Tag = (field_number &lt;&lt; 3) | wire_type</code>。<strong>Tag 本身以 Varint 格式编码</strong>。<br>字段编号与 Wire Type 组合生成 Tag（例如 <code>(1&lt;&lt;3|2)=10</code>）。</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1000</span><br><span class="line">0010</span><br><span class="line">————</span><br><span class="line">1010</span><br></pre></td></tr></table></figure>

<blockquote>
<p>根据上图，字段号最大是15（想一下为什么？），所以字段号和wire type 可以共用一个字节。</p>
</blockquote>
<p>计算机根据 Tag 的值，可以知道字段号和类型。</p>
<ul>
<li><strong>Wire Type 分类</strong>：Protobuf 定义了几种基本的 Wire Type ：<ul>
<li>**Varint (0)**：用于 <code>int32/64</code>、<code>uint32/64</code>、<code>sint32/64</code>、<code>bool</code>、<code>enum</code> 等整型和枚举类型。</li>
<li>**64-bit (1)**：用于 <code>fixed64</code>、<code>sfixed64</code>、<code>double</code> 等 64 位定长类型。</li>
<li>**Length-delimited (2)**：用于字符串、字节数组、嵌套消息以及打包的重复字段。长度使用 Varint 表示，然后紧跟实际内容字节。</li>
<li>**32-bit (5)**：用于 <code>fixed32</code>、<code>sfixed32</code>、<code>float</code> 等 32 位定长类型。<br>（类型 3 和 4 预留用于分组，现已弃用。）</li>
</ul>
</li>
<li><strong>TLV 结构</strong>：每个字段的序列化形式本质上是 <em>Tag-Length-Value</em> 格式：先编码 Tag，再编码值。对于 Length-delimited 类型，会额外先写入长度 Varint，再写入数据。这种设计使得解码器遇到未知字段时可以跳过，旧版本程序可忽略新字段。</li>
<li><strong>模式依赖</strong>：Protobuf 编码流本身不包含字段名或类型信息，只由 <code>.proto</code> 描述文件定义的字段编号来识别每个字段，所以需要外部模式文件才能解读数据。这一点使得序列化结果高效紧凑，但也意味着 Protobuf 数据本身<strong>不可自描述</strong>，必须有匹配的模式才能解析。</li>
</ul>
<h2 id="Protobuf-序列化示例"><a href="#Protobuf-序列化示例" class="headerlink" title="Protobuf 序列化示例"></a>Protobuf 序列化示例</h2><p>在 <strong>Protocol Buffers（Protobuf）</strong> 中，<strong>字符串（<code>string</code>）类型是以长度前缀（length-prefixed）方式进行编码的</strong>。这种方式属于 <strong>wire type &#x3D; 2（length-delimited）</strong> 类型。下面是它的编码细节：</p>
<h3 id="编码结构"><a href="#编码结构" class="headerlink" title="编码结构"></a>编码结构</h3><p>一个字符串字段的编码由以下三部分组成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Tag][Length][Data]</span><br></pre></td></tr></table></figure>

<h3 id="各部分说明："><a href="#各部分说明：" class="headerlink" title="各部分说明："></a>各部分说明：</h3><ol>
<li><strong>Tag（字段编号 + wire type）</strong><ul>
<li>计算方式：<code>(field_number &lt;&lt; 3) | wire_type</code></li>
<li>字符串的 wire type 是 <code>2</code>（length-delimited）</li>
<li>然后用 Varint 编码这个 tag</li>
</ul>
</li>
<li><strong>Length</strong><ul>
<li>表示字符串字节数（不是字符数！）</li>
<li>使用 Varint 编码表示字符串的字节长度（UTF-8 编码后的字节数）</li>
</ul>
</li>
<li><strong>Data</strong><ul>
<li>字符串本身的内容，<strong>以 UTF-8 编码</strong>保存</li>
<li>原样写入，没有压缩</li>
</ul>
</li>
</ol>
<h3 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h3><figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发送 <code>&quot;张三&quot;</code>：</p>
<ul>
<li>字段号：1，wire type：2 → tag &#x3D; <code>(1 &lt;&lt; 3) | 2 = 10</code> → Varint 编码为 <code>0x0A</code></li>
<li>“张三” 的 UTF-8 编码是 6 个字节：<code>E5 BC A0 E4 B8 89</code></li>
<li>Length &#x3D; 6 → Varint 编码为 <code>0x06</code></li>
</ul>
<p>最终编码为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0A 06 E5 BC A0 E4 B8 89</span><br></pre></td></tr></table></figure>

<h3 id="解码过程"><a href="#解码过程" class="headerlink" title="解码过程"></a>解码过程</h3><ol>
<li><strong>Tag</strong>：<ul>
<li>从二进制流中读取 Varint 编码的 Tag</li>
<li>解码为 <code>(field_number &lt;&lt; 3) | wire_type</code></li>
</ul>
</li>
<li><strong>Length</strong>：<ul>
<li>从二进制流中读取 Varint 编码的 Length</li>
<li>解码为字符串的字节长度</li>
</ul>
</li>
<li><strong>Data</strong>：<ul>
<li>从二进制流中读取指定长度的字节</li>
<li>解码为字符串内容</li>
</ul>
</li>
</ol>
<p>在线工具：<a href="https://protobuf-decoder.netlify.app/">https://protobuf-decoder.netlify.app/</a></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><table>
<thead>
<tr>
<th>编码部分</th>
<th>内容</th>
<th>编码方式</th>
</tr>
</thead>
<tbody><tr>
<td>Tag</td>
<td>字段号 + 类型</td>
<td>Varint</td>
</tr>
<tr>
<td>Length</td>
<td>字节长度</td>
<td>Varint</td>
</tr>
<tr>
<td>Data</td>
<td>UTF-8 字节流</td>
<td>原样写入</td>
</tr>
</tbody></table>
<h1 id="gRPC-深入剖析"><a href="#gRPC-深入剖析" class="headerlink" title="gRPC 深入剖析"></a>gRPC 深入剖析</h1><h2 id="gRPC-的优势"><a href="#gRPC-的优势" class="headerlink" title="gRPC 的优势"></a>gRPC 的优势</h2><ol>
<li><strong>高性能</strong>：使用 HTTP&#x2F;2 作为传输协议，支持多路复用</li>
<li><strong>强类型 IDL</strong>：使用 Protocol Buffers 进行接口定义和数据序列化</li>
<li><strong>多语言支持</strong>：自动生成多种语言的客户端和服务端代码</li>
<li><strong>双向流</strong>：支持流式处理，适用于大数据传输和实时通信</li>
<li><strong>内置认证</strong>：提供 SSL&#x2F;TLS 集成和多种认证机制</li>
</ol>
<h2 id="gRPC-与-Protobuf-的协同机制"><a href="#gRPC-与-Protobuf-的协同机制" class="headerlink" title="gRPC 与 Protobuf 的协同机制"></a>gRPC 与 Protobuf 的协同机制</h2><p>gRPC 是基于 Protobuf 的高性能 RPC 框架，Protobuf 在其中既作为接口描述语言 (IDL) 又作为消息交换格式。其配合机制主要包括：</p>
<ul>
<li><p><strong>服务和消息定义</strong>：在 <code>.proto</code> 文件中定义服务（service）和消息（message）。例如：</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">service </span><span class="title class_">Greeter</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> SayHello (HelloRequest) <span class="keyword">returns</span> (HelloReply)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">message </span><span class="title class_">HelloRequest</span> &#123;</span><br><span class="line">  <span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int32</span> age = <span class="number">2</span>;</span><br><span class="line">  <span class="type">float</span> height = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">message </span><span class="title class_">HelloReply</span> &#123;</span><br><span class="line">  <span class="type">string</span> message = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上所示，通过 <code>service</code> 和 <code>rpc</code> 关键字指定可远程调用的方法及其请求&#x2F;响应类型。</p>
</li>
<li><p><strong>生成客户端&#x2F;服务器代码</strong>：使用 <code>protoc</code> 编译器配合 gRPC 插件从 <code>.proto</code> 生成代码。该过程会生成各语言的消息类和 RPC 接口代码，包括客户端存根（stub）和服务器端骨架。生成的服务器端代码通常包含用于注册服务的函数（如 Go 的 <code>RegisterGreeterServer</code>）。开发者在服务器实现类中填充业务逻辑，并通过调用注册函数将服务注册到 gRPC 服务器上。客户端则通过生成的存根调用服务方法，存根会将请求参数打包成Protobuf 消息并发送到服务器。</p>
</li>
<li><p><strong>运行时通信流程</strong>：客户端调用存根方法，本地代码被转换成 RPC 请求，通过 HTTP&#x2F;2 传输承载的二进制帧发送给服务端。服务端的 gRPC 基础设施接收请求，解码 Protobuf 消息并调用相应的服务实现方法，方法返回值再编码为 Protobuf 响应发送回客户端。整个过程对开发者透明，就像在本地调用函数一样。</p>
</li>
</ul>
<h3 id="定义服务"><a href="#定义服务" class="headerlink" title="定义服务"></a>定义服务</h3><p>Protocol Buffers 不仅可以定义数据结构，还可以定义 RPC 服务：</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">service </span><span class="title class_">UserService</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> GetUser(UserRequest) <span class="keyword">returns</span> (UserResponse)</span>;</span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> ListUsers(ListUsersRequest) <span class="keyword">returns</span> (stream UserResponse)</span>;</span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> UpdateUser(stream UserUpdateRequest) <span class="keyword">returns</span> (UserResponse)</span>;</span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> ChatWithUsers(stream ChatMessage) <span class="keyword">returns</span> (stream ChatMessage)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面例子展示了四种调用模式：</p>
<ul>
<li>一元 RPC：单个请求和响应</li>
<li>服务端流式 RPC：客户端发送一个请求，服务端返回流式响应</li>
<li>客户端流式 RPC：客户端发送流式请求，服务端返回单个响应</li>
<li>双向流式 RPC：双方都发送消息流</li>
</ul>
<h2 id="gRPC-工作原理"><a href="#gRPC-工作原理" class="headerlink" title="gRPC 工作原理"></a>gRPC 工作原理</h2><h3 id="gRPC-架构"><a href="#gRPC-架构" class="headerlink" title="gRPC 架构"></a>gRPC 架构</h3><p>gRPC 的基本架构由以下几个重要组件组成：</p>
<ol>
<li><strong>客户端 Stub</strong>：调用方使用的桩代码，隐藏 RPC 细节</li>
<li><strong>服务端 Skeleton</strong>：服务实现方的骨架代码</li>
<li><strong>序列化&#x2F;反序列化层</strong>：使用 Protocol Buffers 处理数据</li>
<li><strong>传输层</strong>：基于 HTTP&#x2F;2 协议的网络传输</li>
</ol>
<h3 id="gRPC-调用类型"><a href="#gRPC-调用类型" class="headerlink" title="gRPC 调用类型"></a>gRPC 调用类型</h3><p>gRPC 支持四种调用类型，满足不同场景需求：</p>
<ol>
<li><strong>一元 RPC(Unary RPC)</strong><ul>
<li>客户端发送单个请求并获得单个响应</li>
<li>类似于传统的 HTTP 请求&#x2F;响应模式</li>
<li>适用于简单的请求处理</li>
</ul>
</li>
<li><strong>服务端流式 RPC(Server Streaming RPC)</strong><ul>
<li>客户端发送单个请求，服务端返回消息流</li>
<li>适用于大数据传输：如下载大文件或获取大量数据</li>
</ul>
</li>
<li><strong>客户端流式 RPC(Client Streaming RPC)</strong><ul>
<li>客户端发送消息流，服务端返回单个响应</li>
<li>适用于上传数据或实时处理：如文件上传或实时数据采集</li>
</ul>
</li>
<li><strong>双向流式 RPC(Bidirectional Streaming RPC)</strong><ul>
<li>客户端和服务端同时发送和接收消息流</li>
<li>适用于实时双向通信：如聊天应用或实时协作</li>
</ul>
</li>
</ol>
<h1 id="使用-gRPC-构建微服务"><a href="#使用-gRPC-构建微服务" class="headerlink" title="使用 gRPC 构建微服务"></a>使用 gRPC 构建微服务</h1><p>本章将介绍如何使用 Go 语言和 gRPC 构建微服务，包括服务定义、代码生成、服务端与客户端实现，以及 gRPC 拦截器的使用。</p>
<h2 id="gRPC-服务定义与代码生成"><a href="#gRPC-服务定义与代码生成" class="headerlink" title="gRPC 服务定义与代码生成"></a>gRPC 服务定义与代码生成</h2><h3 id="安装必要工具"><a href="#安装必要工具" class="headerlink" title="安装必要工具"></a>安装必要工具</h3><p>在使用 gRPC 前，需要安装 Protocol Buffers 编译器和 Go 语言的 gRPC 插件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装protoc编译器</span></span><br><span class="line"><span class="comment"># 可从 https://github.com/protocolbuffers/protobuf/releases 下载</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装Go的protoc插件</span></span><br><span class="line">go install google.golang.org/protobuf/cmd/protoc-gen-go@latest</span><br><span class="line">go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest</span><br></pre></td></tr></table></figure>

<h3 id="定义服务-1"><a href="#定义服务-1" class="headerlink" title="定义服务"></a>定义服务</h3><p>创建一个<code>.proto</code>文件，定义服务和消息结构：</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> product;</span><br><span class="line"><span class="keyword">option</span> go_package = <span class="string">&quot;github.com/username/microservice/product&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 商品服务</span></span><br><span class="line"><span class="keyword">service </span><span class="title class_">ProductService</span> &#123;</span><br><span class="line">  <span class="comment">// 获取商品详情</span></span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> GetProduct(GetProductRequest) <span class="keyword">returns</span> (ProductResponse)</span>;</span><br><span class="line">  <span class="comment">// 查询商品列表</span></span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> ListProducts(ListProductsRequest) <span class="keyword">returns</span> (stream ProductResponse)</span>;</span><br><span class="line">  <span class="comment">// 创建商品</span></span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> CreateProduct(CreateProductRequest) <span class="keyword">returns</span> (ProductResponse)</span>;</span><br><span class="line">  <span class="comment">// 批量更新商品</span></span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> UpdateProducts(stream UpdateProductRequest) <span class="keyword">returns</span> (UpdateProductsResponse)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取商品请求</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">GetProductRequest</span> &#123;</span><br><span class="line">  <span class="type">string</span> product_id = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 商品列表请求</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">ListProductsRequest</span> &#123;</span><br><span class="line">  <span class="type">int32</span> page_size = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int32</span> page_number = <span class="number">2</span>;</span><br><span class="line">  <span class="type">string</span> category = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建商品请求</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">CreateProductRequest</span> &#123;</span><br><span class="line">  <span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">  <span class="type">string</span> description = <span class="number">2</span>;</span><br><span class="line">  <span class="type">double</span> price = <span class="number">3</span>;</span><br><span class="line">  <span class="type">string</span> category = <span class="number">4</span>;</span><br><span class="line">  <span class="type">int32</span> stock = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新商品请求</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">UpdateProductRequest</span> &#123;</span><br><span class="line">  <span class="type">string</span> product_id = <span class="number">1</span>;</span><br><span class="line">  <span class="type">string</span> name = <span class="number">2</span>;</span><br><span class="line">  <span class="type">string</span> description = <span class="number">3</span>;</span><br><span class="line">  <span class="type">double</span> price = <span class="number">4</span>;</span><br><span class="line">  <span class="type">int32</span> stock = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 批量更新响应</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">UpdateProductsResponse</span> &#123;</span><br><span class="line">  <span class="type">int32</span> updated_count = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">repeated</span> <span class="type">string</span> failed_ids = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 商品响应</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">ProductResponse</span> &#123;</span><br><span class="line">  <span class="type">string</span> id = <span class="number">1</span>;</span><br><span class="line">  <span class="type">string</span> name = <span class="number">2</span>;</span><br><span class="line">  <span class="type">string</span> description = <span class="number">3</span>;</span><br><span class="line">  <span class="type">double</span> price = <span class="number">4</span>;</span><br><span class="line">  <span class="type">string</span> category = <span class="number">5</span>;</span><br><span class="line">  <span class="type">int32</span> stock = <span class="number">6</span>;</span><br><span class="line">  <span class="type">string</span> created_at = <span class="number">7</span>;</span><br><span class="line">  <span class="type">string</span> updated_at = <span class="number">8</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="生成代码"><a href="#生成代码" class="headerlink" title="生成代码"></a>生成代码</h3><p>使用以下命令生成 Go 代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">protoc --go_out=. --go-grpc_out=. product.proto</span><br></pre></td></tr></table></figure>

<p>这将生成两个文件：</p>
<ul>
<li><code>product.pb.go</code>: 包含所有消息类型的 Go 结构体</li>
<li><code>product_grpc.pb.go</code>: 包含 gRPC 客户端和服务端接口</li>
</ul>
<h2 id="实现-gRPC-服务端"><a href="#实现-gRPC-服务端" class="headerlink" title="实现 gRPC 服务端"></a>实现 gRPC 服务端</h2><h3 id="基本服务实现"><a href="#基本服务实现" class="headerlink" title="基本服务实现"></a>基本服务实现</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">	pb <span class="string">&quot;github.com/username/microservice/product&quot;</span></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc/codes&quot;</span></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc/status&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> server <span class="keyword">struct</span> &#123;</span><br><span class="line">	pb.UnimplementedProductServiceServer</span><br><span class="line">	products <span class="keyword">map</span>[<span class="type">string</span>]*pb.ProductResponse <span class="comment">// 简化示例，实际应使用数据库</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现GetProduct方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span></span> GetProduct(ctx context.Context, req *pb.GetProductRequest) (*pb.ProductResponse, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> product, exists := s.products[req.ProductId]; exists &#123;</span><br><span class="line">		<span class="keyword">return</span> product, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, status.Errorf(codes.NotFound, <span class="string">&quot;产品ID %s 不存在&quot;</span>, req.ProductId)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现ListProducts方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span></span> ListProducts(req *pb.ListProductsRequest, stream pb.ProductService_ListProductsServer) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, product := <span class="keyword">range</span> s.products &#123;</span><br><span class="line">		<span class="comment">// 如果指定了分类，则过滤</span></span><br><span class="line">		<span class="keyword">if</span> req.Category != <span class="string">&quot;&quot;</span> &amp;&amp; product.Category != req.Category &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 发送产品到流</span></span><br><span class="line">		<span class="keyword">if</span> err := stream.Send(product); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现CreateProduct方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span></span> CreateProduct(ctx context.Context, req *pb.CreateProductRequest) (*pb.ProductResponse, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// 生成ID (简化示例)</span></span><br><span class="line">	id := fmt.Sprintf(<span class="string">&quot;prod-%d&quot;</span>, time.Now().Unix())</span><br><span class="line"></span><br><span class="line">	product := &amp;pb.ProductResponse&#123;</span><br><span class="line">		Id:          id,</span><br><span class="line">		Name:        req.Name,</span><br><span class="line">		Description: req.Description,</span><br><span class="line">		Price:       req.Price,</span><br><span class="line">		Category:    req.Category,</span><br><span class="line">		Stock:       req.Stock,</span><br><span class="line">		CreatedAt:   time.Now().Format(time.RFC3339),</span><br><span class="line">		UpdatedAt:   time.Now().Format(time.RFC3339),</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	s.products[id] = product</span><br><span class="line">	<span class="keyword">return</span> product, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现UpdateProducts方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span></span> UpdateProducts(stream pb.ProductService_UpdateProductsServer) <span class="type">error</span> &#123;</span><br><span class="line">	updatedCount := <span class="number">0</span></span><br><span class="line">	failedIds := []<span class="type">string</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		req, err := stream.Recv()</span><br><span class="line">		<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">			<span class="comment">// 完成接收，返回结果</span></span><br><span class="line">			<span class="keyword">return</span> stream.SendAndClose(&amp;pb.UpdateProductsResponse&#123;</span><br><span class="line">				UpdatedCount: <span class="type">int32</span>(updatedCount),</span><br><span class="line">				FailedIds:    failedIds,</span><br><span class="line">			&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 尝试更新产品</span></span><br><span class="line">		<span class="keyword">if</span> product, exists := s.products[req.ProductId]; exists &#123;</span><br><span class="line">			product.Name = req.Name</span><br><span class="line">			product.Description = req.Description</span><br><span class="line">			product.Price = req.Price</span><br><span class="line">			product.Stock = req.Stock</span><br><span class="line">			product.UpdatedAt = time.Now().Format(time.RFC3339)</span><br><span class="line">			updatedCount++</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			failedIds = <span class="built_in">append</span>(failedIds, req.ProductId)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	lis, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:50051&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;监听端口失败: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	s := grpc.NewServer()</span><br><span class="line">	productServer := &amp;server&#123;</span><br><span class="line">		products: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]*pb.ProductResponse),</span><br><span class="line">	&#125;</span><br><span class="line">	pb.RegisterProductServiceServer(s, productServer)</span><br><span class="line"></span><br><span class="line">	log.Println(<span class="string">&quot;gRPC服务器已启动，监听端口50051...&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err := s.Serve(lis); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;服务运行失败: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="添加-TLS-安全认证"><a href="#添加-TLS-安全认证" class="headerlink" title="添加 TLS 安全认证"></a>添加 TLS 安全认证</h3><p>在生产环境中，应使用 TLS 加密通信：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 加载TLS证书</span></span><br><span class="line">	creds, err := credentials.NewServerTLSFromFile(<span class="string">&quot;server.crt&quot;</span>, <span class="string">&quot;server.key&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;加载TLS证书失败: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建安全的gRPC服务器</span></span><br><span class="line">	s := grpc.NewServer(grpc.Creds(creds))</span><br><span class="line">	<span class="comment">// ... 其他代码相同</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现-gRPC-客户端"><a href="#实现-gRPC-客户端" class="headerlink" title="实现 gRPC 客户端"></a>实现 gRPC 客户端</h2><h3 id="基本客户端实现"><a href="#基本客户端实现" class="headerlink" title="基本客户端实现"></a>基本客户端实现</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">	pb <span class="string">&quot;github.com/username/microservice/product&quot;</span></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc/credentials/insecure&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 建立连接</span></span><br><span class="line">	conn, err := grpc.Dial(<span class="string">&quot;localhost:50051&quot;</span>, grpc.WithTransportCredentials(insecure.NewCredentials()))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;无法连接服务器: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建客户端</span></span><br><span class="line">	client := pb.NewProductServiceClient(conn)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置上下文</span></span><br><span class="line">	ctx, cancel := context.WithTimeout(context.Background(), <span class="number">10</span>*time.Second)</span><br><span class="line">	<span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建商品</span></span><br><span class="line">	createResp, err := client.CreateProduct(ctx, &amp;pb.CreateProductRequest&#123;</span><br><span class="line">		Name:        <span class="string">&quot;Go编程实战&quot;</span>,</span><br><span class="line">		Description: <span class="string">&quot;学习Go语言的最佳实践指南&quot;</span>,</span><br><span class="line">		Price:       <span class="number">59.9</span>,</span><br><span class="line">		Category:    <span class="string">&quot;书籍&quot;</span>,</span><br><span class="line">		Stock:       <span class="number">100</span>,</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;创建商品失败: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	log.Printf(<span class="string">&quot;创建的商品: %v&quot;</span>, createResp)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取商品</span></span><br><span class="line">	getResp, err := client.GetProduct(ctx, &amp;pb.GetProductRequest&#123;</span><br><span class="line">		ProductId: createResp.Id,</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;获取商品失败: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	log.Printf(<span class="string">&quot;获取到的商品: %v&quot;</span>, getResp)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 列出商品（使用流）</span></span><br><span class="line">	stream, err := client.ListProducts(ctx, &amp;pb.ListProductsRequest&#123;</span><br><span class="line">		Category: <span class="string">&quot;书籍&quot;</span>,</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;获取商品列表失败: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		product, err := stream.Recv()</span><br><span class="line">		<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">			<span class="keyword">break</span> <span class="comment">// 流结束</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatalf(<span class="string">&quot;接收商品流失败: %v&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">		log.Printf(<span class="string">&quot;列表中商品: %v&quot;</span>, product)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="添加-TLS-安全连接"><a href="#添加-TLS-安全连接" class="headerlink" title="添加 TLS 安全连接"></a>添加 TLS 安全连接</h3><p>生产环境中应使用 TLS：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 加载TLS证书</span></span><br><span class="line">	creds, err := credentials.NewClientTLSFromFile(<span class="string">&quot;server.crt&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;加载TLS证书失败: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用TLS连接</span></span><br><span class="line">	conn, err := grpc.Dial(<span class="string">&quot;localhost:50051&quot;</span>, grpc.WithTransportCredentials(creds))</span><br><span class="line">	<span class="comment">// ... 其他代码相同</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="处理客户端流式调用"><a href="#处理客户端流式调用" class="headerlink" title="处理客户端流式调用"></a>处理客户端流式调用</h3><p>更新多个商品的示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">updateProducts</span><span class="params">(client pb.ProductServiceClient, ctx context.Context)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建客户端流</span></span><br><span class="line">	stream, err := client.UpdateProducts(ctx)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;创建更新流失败: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 发送多个更新请求</span></span><br><span class="line">	<span class="keyword">for</span> i, prodId := <span class="keyword">range</span> []<span class="type">string</span>&#123;<span class="string">&quot;prod-1&quot;</span>, <span class="string">&quot;prod-2&quot;</span>, <span class="string">&quot;prod-3&quot;</span>&#125; &#123;</span><br><span class="line">		err := stream.Send(&amp;pb.UpdateProductRequest&#123;</span><br><span class="line">			ProductId:   prodId,</span><br><span class="line">			Name:        fmt.Sprintf(<span class="string">&quot;更新产品 %d&quot;</span>, i),</span><br><span class="line">			Description: <span class="string">&quot;产品已更新&quot;</span>,</span><br><span class="line">			Price:       <span class="number">99.9</span> + <span class="type">float64</span>(i*<span class="number">10</span>),</span><br><span class="line">			Stock:       <span class="number">50</span> - i*<span class="number">5</span>,</span><br><span class="line">		&#125;)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatalf(<span class="string">&quot;发送更新失败: %v&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">		time.Sleep(<span class="number">100</span> * time.Millisecond) <span class="comment">// 模拟处理时间</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 关闭发送并获取结果</span></span><br><span class="line">	resp, err := stream.CloseAndRecv()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;接收更新结果失败: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	log.Printf(<span class="string">&quot;更新结果: 成功 %d, 失败 %v&quot;</span>, resp.UpdatedCount, resp.FailedIds)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>后端开发</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>后端开发</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>网络监控命令行工具</title>
    <url>/2025/04/11/%E7%BD%91%E7%BB%9C%E7%9B%91%E6%8E%A7%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h1 id="网络监控命令行工具"><a href="#网络监控命令行工具" class="headerlink" title="网络监控命令行工具"></a>网络监控命令行工具</h1><p>项目地址：<a href="https://github.com/jianingdai/network-monitor">https://github.com/jianingdai/network-monitor</a></p>
<h2 id="项目简介"><a href="#项目简介" class="headerlink" title="项目简介"></a>项目简介</h2><p>这是一个基于 Go 语言开发的网络监控命令行工具，旨在帮助用户监控指定的目标（如网站或 IP 地址）的可用性和响应时间。通过该工具，用户可以方便地添加、删除监控目标，启动监控任务，并生成监控报告。</p>
<h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">network-monitor/</span><br><span class="line">├── cmd/         # 命令行定义</span><br><span class="line">├── core/        # 核心业务逻辑</span><br><span class="line">├── models/      # 数据模型</span><br><span class="line">├── utils/       # 通用工具</span><br><span class="line">├── config/      # 配置文件</span><br><span class="line">├── tests/       # 测试目录</span><br><span class="line">├── main.go      # 程序入口</span><br></pre></td></tr></table></figure>

<h2 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h2><ol>
<li><strong>添加监控目标</strong>：通过命令行添加需要监控的网站或 IP 地址。</li>
<li><strong>删除监控目标</strong>：移除不再需要监控的目标。</li>
<li><strong>列出监控目标</strong>：查看当前所有监控目标。</li>
<li><strong>启动监控任务</strong>：并发监控所有目标的可用性和响应时间。</li>
<li><strong>生成监控报告</strong>：统计监控结果，生成详细的报告。</li>
</ol>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><ol>
<li><p>确保已安装 Go 开发环境。</p>
</li>
<li><p>克隆项目到本地：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> &lt;repository-url&gt;</span><br><span class="line"><span class="built_in">cd</span> network-monitor</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go run main.go add -n <span class="string">&quot;Google&quot;</span> -u <span class="string">&quot;https://google.com&quot;</span></span><br><span class="line">go run main.go start</span><br><span class="line">go run main.go report</span><br></pre></td></tr></table></figure>
</li>
<li><p>或者运行以下命令</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go build .</span><br><span class="line">network-mintor.exe [<span class="built_in">command</span>]</span><br></pre></td></tr></table></figure>

<p>（先构建出监控工具然后就可以带上参数使用监控工具了）</p>
<h2 id="开发计划"><a href="#开发计划" class="headerlink" title="开发计划"></a>开发计划</h2><ul>
<li>支持多种检查方式（如 HTTP、Ping、DNS）。</li>
<li>集成报警功能（如邮件或短信通知）。</li>
<li>提供 Web 界面，展示监控数据。</li>
</ul>
]]></content>
      <categories>
        <category>后端开发</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>后端开发</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>企业圈系统设计</title>
    <url>/2025/08/21/%E4%BC%81%E4%B8%9A%E5%9C%88%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1(todo)/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">根据需求，出一份符合规范的设计文档。</span><br><span class="line"></span><br><span class="line"># 需求</span><br><span class="line">仿造微信朋友圈，设计并实现以下能力：</span><br><span class="line">- **需求1**： 企业用户可以发布或删除企业圈内容</span><br><span class="line">- **需求2** 同企业成员互相可见</span><br><span class="line">- **需求3**支持点赞企业圈内容，24小时内发布且点赞数超过10的企业圈内容中，点赞数前三的自动置顶，置顶的内容按点赞数高到低排序</span><br><span class="line">- **需求4** (可选)支持企业圈内容评论</span><br><span class="line"></span><br><span class="line">参考数据</span><br><span class="line">- **企业数量**：1w</span><br><span class="line">- **每日新增内容**：50w条</span><br><span class="line">- **日活用户数**：500w</span><br><span class="line"></span><br><span class="line"># 设计文档规范</span><br><span class="line">## 文档结构</span><br><span class="line">```</span><br><span class="line">一、 引言</span><br><span class="line">文档变更日志 </span><br><span class="line">二、 项目概述 </span><br><span class="line">2.1 需求背景</span><br><span class="line">三、详细设计</span><br><span class="line">3.1 系统架构设计</span><br><span class="line">系统架构设计图，当涉及到多模块架构时，需按总系统架构图-&gt;各子模块系统架构图的层级关系表示</span><br><span class="line">    3.1.1系统架构图</span><br><span class="line">    3.1.2子模块1架构图</span><br><span class="line">    3.1.3子模块2架构图</span><br><span class="line">3.2 数据库设计</span><br><span class="line">3.3 系统功能设计</span><br><span class="line">3.4 接口设计</span><br><span class="line">五、附录</span><br><span class="line">5.1 名词解释 </span><br><span class="line">4.2 参考资料</span><br><span class="line">参考资料链接列表</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line"># 技术选型</span><br><span class="line">- **编程语言**： golang</span><br><span class="line">- **网络框架**：gin</span><br><span class="line">- **数据库**： mysql</span><br><span class="line"></span><br><span class="line"># 注意！</span><br><span class="line">- 设计文档请严格按照规范输出</span><br><span class="line">- 流程图格式使用 mermaid 绘制</span><br><span class="line">- 注意，请认真阅读4个需求，接口和数据库设计都必须要实现</span><br><span class="line">- 文档内容要足够清晰详细，前端需要看接口文档对接联通，测试需要看文档写测试用例</span><br><span class="line">- 你的所有回答、方案、实现都需要谨慎、专业、深入的思考。</span><br></pre></td></tr></table></figure>

<h1 id="企业圈系统设计文档"><a href="#企业圈系统设计文档" class="headerlink" title="企业圈系统设计文档"></a>企业圈系统设计文档</h1><h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><p>本设计文档描述了企业圈系统的整体架构设计、数据库设计、功能模块设计以及API接口设计。该系统旨在为企业内部员工提供类似微信朋友圈的社交功能，支持企业内容发布、点赞、评论等功能，并通过智能置顶算法提升优质内容的曝光度。</p>
<h3 id="文档变更日志"><a href="#文档变更日志" class="headerlink" title="文档变更日志"></a>文档变更日志</h3><table>
<thead>
<tr>
<th><em><strong>*版本*</strong></em></th>
<th><em><strong>*变更日期*</strong></em></th>
<th><em><strong>*变更内容*</strong></em></th>
<th><em><strong>*变更人*</strong></em></th>
</tr>
</thead>
<tbody><tr>
<td>v1.0</td>
<td>2024-12-19</td>
<td>初始版本，包含系统架构、数据库设计、API设计</td>
<td>系统架构师</td>
</tr>
<tr>
<td>v1.1</td>
<td>2024-12-19</td>
<td>优化架构图为Mermaid格式，完善技术实现细节</td>
<td>系统架构师</td>
</tr>
</tbody></table>
<h2 id="二、项目概述"><a href="#二、项目概述" class="headerlink" title="二、项目概述"></a>二、项目概述</h2><h3 id="2-1-需求背景"><a href="#2-1-需求背景" class="headerlink" title="2.1 需求背景"></a>2.1 需求背景</h3><p>随着企业数字化转型的推进，企业内部员工之间的信息交流和协作需求日益增长。传统的企业内部沟通方式往往缺乏互动性和即时性，难以满足现代企业的沟通需求。</p>
<p>本项目旨在构建一个企业级的内部社交平台，具体实现以下核心需求：</p>
<p>****核心功能需求****：</p>
<ol>
<li>****内容管理****：企业用户可以发布或删除企业圈内容</li>
<li>****权限控制****：同企业成员互相可见，跨企业内容隔离</li>
<li>****智能置顶****：24小时内发布且点赞数超过10的内容中，点赞数前三的自动置顶</li>
<li>****互动功能****：支持企业圈内容评论，增强用户互动</li>
</ol>
<p>****系统规模指标****：</p>
<ul>
<li>****企业数量****：10,000家企业</li>
<li>****每日新增内容****：500,000条</li>
<li>****日活用户数****：5,000,000人</li>
<li>****峰值QPS预估****：~15,000 QPS（考虑高峰时段集中访问）</li>
<li>****存储预估****：每日新增约100GB数据（包含文本、图片、元数据等）</li>
</ul>
<h2 id="三、详细设计"><a href="#三、详细设计" class="headerlink" title="三、详细设计"></a>三、详细设计</h2><h3 id="3-1-系统架构设计"><a href="#3-1-系统架构设计" class="headerlink" title="3.1 系统架构设计"></a>3.1 系统架构设计</h3><h4 id="3-1-1-系统整体架构图"><a href="#3-1-1-系统整体架构图" class="headerlink" title="3.1.1 系统整体架构图"></a>3.1.1 系统整体架构图</h4><p>系统采用微服务架构，分为客户端层、网关层、应用服务层、数据存储层和基础设施层。通过水平分层和垂直拆分，确保系统的高可用性和可扩展性。</p>
<p><img data-src="https://raw.githubusercontent.com/jianingdai/Blog_img/main/img202508281428715.png" alt="image-20250828142839440"></p>
<pre class="mermaid">graph TB
    subgraph "客户端层"
        WebClient["Web客户端"]
        MobileApp["移动端APP"]
        ThirdParty["第三方应用"]
    end
    
    subgraph "网关层"
        Gateway["API网关<br/>负载均衡<br/>限流熔断"]
    end
    
    subgraph "应用服务层"
        AuthService["认证服务<br/>- 用户登录注册<br/>- JWT令牌管理<br/>- 权限验证"]
        ContentService["内容服务<br/>- 企业圈CRUD<br/>- 动态Feed生成<br/>- 置顶算法"]
        LikeService["点赞服务<br/>- 点赞/取消<br/>- 计数统计<br/>- 热度计算"]
        CommentService["评论服务<br/>- 评论CRUD<br/>- 二级回复<br/>- 内容审核"]
    end
    
    subgraph "数据存储层"
        MySQL["MySQL集群<br/>- 主从分离<br/>- 分库分表<br/>- 读写分离"]
        Redis["Redis集群<br/>- 缓存热点数据<br/>- 计数器<br/>- 分布式锁"]
        FileStorage["文件存储<br/>- 图片存储<br/>- CDN加速"]
    end
    
    subgraph "基础设施层"
        MQ["消息队列<br/>- 异步处理<br/>- 削峰填谷"]
        Monitor["监控告警<br/>- 性能监控<br/>- 业务监控"]
        Schedule["定时任务<br/>- 置顶更新<br/>- 数据同步"]
    end
    
    WebClient --> Gateway
    MobileApp --> Gateway
    ThirdParty --> Gateway
    
    Gateway --> AuthService
    Gateway --> ContentService
    Gateway --> LikeService
    Gateway --> CommentService
    
    AuthService --> MySQL
    AuthService --> Redis
    
    ContentService --> MySQL
    ContentService --> Redis
    ContentService --> FileStorage
    ContentService --> MQ
    
    LikeService --> MySQL
    LikeService --> Redis
    LikeService --> MQ
    
    CommentService --> MySQL
    CommentService --> Redis
    
    MQ --> Schedule
    Schedule --> ContentService
    
    Monitor --> AuthService
    Monitor --> ContentService
    Monitor --> LikeService
    Monitor --> CommentService</pre>

<h4 id="3-1-2-核心业务流程时序图"><a href="#3-1-2-核心业务流程时序图" class="headerlink" title="3.1.2 核心业务流程时序图"></a>3.1.2 核心业务流程时序图</h4><p>主要展示用户登录、内容发布、点赞等核心业务流程的交互时序。</p>
<p><img data-src="https://raw.githubusercontent.com/jianingdai/Blog_img/main/img202508281429118.png" alt="image-20250828142944999"></p>
<pre class="mermaid">sequenceDiagram
    participant Client as 客户端
    participant Gateway as API网关
    participant Auth as 认证服务
    participant Content as 内容服务
    participant Like as 点赞服务
    participant MySQL as MySQL数据库
    participant Redis as Redis缓存

    Note over Client,Redis: 用户登录流程
    Client->>Gateway: POST /api/v1/auth/login
    Gateway->>Auth: 转发登录请求
    Auth->>MySQL: 验证用户凭证
    MySQL-->>Auth: 返回用户信息
    Auth->>Redis: 缓存用户会话
    Auth-->>Gateway: 返回JWT令牌
    Gateway-->>Client: 登录成功响应

    Note over Client,Redis: 发布内容流程
    Client->>Gateway: POST /api/v1/posts
    Gateway->>Auth: 验证JWT令牌
    Auth-->>Gateway: 令牌有效
    Gateway->>Content: 转发发布请求
    Content->>MySQL: 插入内容记录
    MySQL-->>Content: 插入成功
    Content->>Redis: 更新Feed缓存
    Content-->>Gateway: 发布成功
    Gateway-->>Client: 返回成功响应

    Note over Client,Redis: 点赞流程
    Client->>Gateway: POST /api/v1/posts/{id}/like
    Gateway->>Auth: 验证权限
    Auth-->>Gateway: 权限验证通过
    Gateway->>Like: 处理点赞请求
    Like->>Redis: 检查点赞状态
    Redis-->>Like: 返回当前状态
    Like->>MySQL: 更新点赞记录
    Like->>Redis: 更新点赞计数
    Like->>Content: 异步检查置顶条件
    Like-->>Gateway: 点赞操作完成
    Gateway-->>Client: 返回操作结果</pre>

<h4 id="3-1-3-智能置顶算法流程图"><a href="#3-1-3-智能置顶算法流程图" class="headerlink" title="3.1.3 智能置顶算法流程图"></a>3.1.3 智能置顶算法流程图</h4><p>展示自动置顶机制的具体执行流程，确保24小时内高质量内容能够获得更多曝光。</p>
<p><img data-src="https://raw.githubusercontent.com/jianingdai/Blog_img/main/img202508281433768.png" alt="mermaid-diagram-2025-08-28-143154"></p>
<pre class="mermaid">flowchart TD
    A[定时任务启动<br/>每小时执行] --> B[获取所有企业列表]
    B --> C{遍历每个企业}
    C --> D[查询24小时内<br/>点赞数>10的内容]
    D --> E{是否有符合条件的内容?}
    E -->|否| F[清空当前置顶内容]
    E -->|是| G[按点赞数降序排序]
    G --> H[取前3名内容]
    H --> I[清空旧置顶状态]
    I --> J[设置新置顶内容]
    J --> K[更新is_pinned=1<br/>设置pinned_at时间]
    K --> L[清理Redis置顶缓存]
    L --> M[预热新置顶内容到缓存]
    F --> N[继续下一个企业]
    M --> N
    N --> C
    C -->|所有企业处理完成| O[任务完成<br/>等待下次执行]
    
    style A fill:#e1f5fe
    style O fill:#c8e6c9
    style K fill:#fff3e0</pre>

<h3 id="3-2-数据库设计"><a href="#3-2-数据库设计" class="headerlink" title="3.2 数据库设计"></a>3.2 数据库设计</h3><h4 id="3-2-1-数据库ER图"><a href="#3-2-1-数据库ER图" class="headerlink" title="3.2.1 数据库ER图"></a>3.2.1 数据库ER图</h4><p>系统核心实体关系图，展示企业、用户、内容、点赞、评论之间的关联关系。</p>
<p><img data-src="https://raw.githubusercontent.com/jianingdai/Blog_img/main/img202508281434001.png" alt="mermaid-diagram-2025-08-28-143437"></p>
<pre class="mermaid">erDiagram
    enterprises {
        bigint id PK "企业ID"
        varchar name "企业名称"
        varchar code "企业代码"
        varchar logo "企业logo"
        tinyint status "状态"
        timestamp created_at "创建时间"
        timestamp updated_at "更新时间"
    }
    
    users {
        bigint id PK "用户ID"
        bigint enterprise_id FK "企业ID"
        varchar username "用户名"
        varchar email "邮箱"
        varchar nickname "昵称"
        varchar avatar "头像URL"
        varchar password_hash "密码哈希"
        tinyint status "状态"
        timestamp created_at "创建时间"
        timestamp updated_at "更新时间"
    }
    
    posts {
        bigint id PK "内容ID"
        bigint user_id FK "发布用户ID"
        bigint enterprise_id FK "企业ID"
        text content "内容文本"
        json images "图片URL列表"
        int like_count "点赞数"
        int comment_count "评论数"
        tinyint is_pinned "是否置顶"
        timestamp pinned_at "置顶时间"
        tinyint status "状态"
        timestamp created_at "创建时间"
        timestamp updated_at "更新时间"
    }
    
    likes {
        bigint id PK "点赞ID"
        bigint post_id FK "内容ID"
        bigint user_id FK "用户ID"
        timestamp created_at "点赞时间"
    }
    
    comments {
        bigint id PK "评论ID"
        bigint post_id FK "内容ID"
        bigint user_id FK "评论用户ID"
        bigint parent_id FK "父评论ID"
        text content "评论内容"
        tinyint status "状态"
        timestamp created_at "创建时间"
        timestamp updated_at "更新时间"
    }
    
    enterprises ||--o{ users : "包含"
    enterprises ||--o{ posts : "拥有"
    users ||--o{ posts : "发布"
    users ||--o{ likes : "点赞"
    users ||--o{ comments : "评论"
    posts ||--o{ likes : "被点赞"
    posts ||--o{ comments : "被评论"
    comments ||--o{ comments : "回复"</pre>

<h4 id="3-2-2-分库分表策略"><a href="#3-2-2-分库分表策略" class="headerlink" title="3.2.2 分库分表策略"></a>3.2.2 分库分表策略</h4><p>****分表策略****：</p>
<ul>
<li>按企业ID进行分表，每个企业的数据存储在独立的表中</li>
<li>分表规则：<code>posts_$&#123;enterprise_id % 100&#125;</code></li>
<li>支持最大10,000个企业，平均每表100个企业</li>
</ul>
<p>****索引优化策略****：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 企业圈动态查询优化索引</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_posts_enterprise_created <span class="keyword">ON</span> posts_$&#123;shard&#125; (enterprise_id, created_at <span class="keyword">DESC</span>, status);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 置顶内容查询优化索引  </span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_posts_pinned_likes <span class="keyword">ON</span> posts_$&#123;shard&#125; (enterprise_id, is_pinned <span class="keyword">DESC</span>, like_count <span class="keyword">DESC</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 24小时热门内容查询索引</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_posts_hot_24h <span class="keyword">ON</span> posts_$&#123;shard&#125; (enterprise_id, created_at, like_count, status);</span><br></pre></td></tr></table></figure>

<h4 id="3-2-3-企业表-enterprises"><a href="#3-2-3-企业表-enterprises" class="headerlink" title="3.2.3 企业表 (enterprises)"></a>3.2.3 企业表 (enterprises)</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `enterprises` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;企业ID&#x27;</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;企业名称&#x27;</span>,</span><br><span class="line">  `code` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;企业代码&#x27;</span>,</span><br><span class="line">  `logo` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;企业logo&#x27;</span>,</span><br><span class="line">  `description` text <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;企业描述&#x27;</span>,</span><br><span class="line">  `industry` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;所属行业&#x27;</span>,</span><br><span class="line">  `employee_count` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;员工数量&#x27;</span>,</span><br><span class="line">  `status` tinyint(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="number">1</span> COMMENT <span class="string">&#x27;状态: 1-正常, 0-禁用&#x27;</span>,</span><br><span class="line">  `created_at` <span class="type">timestamp</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `updated_at` <span class="type">timestamp</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;更新时间&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_code` (`code`),</span><br><span class="line">  KEY `idx_name` (`name`),</span><br><span class="line">  KEY `idx_status` (`status`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 COMMENT<span class="operator">=</span><span class="string">&#x27;企业表&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-4-用户表-users"><a href="#3-2-4-用户表-users" class="headerlink" title="3.2.4 用户表 (users)"></a>3.2.4 用户表 (users)</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `users` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;用户ID&#x27;</span>,</span><br><span class="line">  `enterprise_id` <span class="type">bigint</span>(<span class="number">20</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;企业ID&#x27;</span>,</span><br><span class="line">  `username` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户名&#x27;</span>,</span><br><span class="line">  `email` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;邮箱&#x27;</span>,</span><br><span class="line">  `password_hash` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;密码哈希&#x27;</span>,</span><br><span class="line">  `nickname` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;昵称&#x27;</span>,</span><br><span class="line">  `avatar` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;头像URL&#x27;</span>,</span><br><span class="line">  `department` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;部门&#x27;</span>,</span><br><span class="line">  `position` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;职位&#x27;</span>,</span><br><span class="line">  `phone` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;手机号&#x27;</span>,</span><br><span class="line">  `last_login_at` <span class="type">timestamp</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;最后登录时间&#x27;</span>,</span><br><span class="line">  `status` tinyint(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="number">1</span> COMMENT <span class="string">&#x27;状态: 1-正常, 0-禁用&#x27;</span>,</span><br><span class="line">  `created_at` <span class="type">timestamp</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `updated_at` <span class="type">timestamp</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;更新时间&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_username` (`username`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_email` (`email`),</span><br><span class="line">  KEY `idx_enterprise_id` (`enterprise_id`),</span><br><span class="line">  KEY `idx_status` (`status`),</span><br><span class="line">  KEY `idx_last_login` (`last_login_at`),</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> `fk_users_enterprise` <span class="keyword">FOREIGN</span> KEY (`enterprise_id`) <span class="keyword">REFERENCES</span> `enterprises` (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 COMMENT<span class="operator">=</span><span class="string">&#x27;用户表&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-5-企业圈内容表-posts"><a href="#3-2-5-企业圈内容表-posts" class="headerlink" title="3.2.5 企业圈内容表 (posts)"></a>3.2.5 企业圈内容表 (posts)</h4><p>支持分表存储，按企业ID取模分布到不同表中，提升查询性能。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 分表模板，实际会创建 posts_0 到 posts_99 共100个表</span><br><span class="line">CREATE TABLE `posts_$&#123;shard&#125;` (</span><br><span class="line">  `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT &#x27;内容ID&#x27;,</span><br><span class="line">  `user_id` bigint(20) unsigned NOT NULL COMMENT &#x27;发布用户ID&#x27;,</span><br><span class="line">  `enterprise_id` bigint(20) unsigned NOT NULL COMMENT &#x27;企业ID&#x27;,</span><br><span class="line">  `content` text NOT NULL COMMENT &#x27;内容文本&#x27;,</span><br><span class="line">  `images` json DEFAULT NULL COMMENT &#x27;图片URL列表&#x27;,</span><br><span class="line">  `video_url` varchar(255) DEFAULT &#x27;&#x27; COMMENT &#x27;视频URL&#x27;,</span><br><span class="line">  `location` varchar(200) DEFAULT &#x27;&#x27; COMMENT &#x27;发布位置&#x27;,</span><br><span class="line">  `tags` json DEFAULT NULL COMMENT &#x27;标签列表&#x27;,</span><br><span class="line">  `like_count` int(11) DEFAULT 0 COMMENT &#x27;点赞数&#x27;,</span><br><span class="line">  `comment_count` int(11) DEFAULT 0 COMMENT &#x27;评论数&#x27;,</span><br><span class="line">  `share_count` int(11) DEFAULT 0 COMMENT &#x27;分享数&#x27;,</span><br><span class="line">  `view_count` int(11) DEFAULT 0 COMMENT &#x27;浏览数&#x27;,</span><br><span class="line">  `is_pinned` tinyint(1) DEFAULT 0 COMMENT &#x27;是否置顶: 1-是, 0-否&#x27;,</span><br><span class="line">  `pinned_at` timestamp NULL DEFAULT NULL COMMENT &#x27;置顶时间&#x27;,</span><br><span class="line">  `pinned_order` int(11) DEFAULT 0 COMMENT &#x27;置顶排序: 1,2,3&#x27;,</span><br><span class="line">  `status` tinyint(1) DEFAULT 1 COMMENT &#x27;状态: 1-正常, 0-删除&#x27;,</span><br><span class="line">  `created_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;,</span><br><span class="line">  `updated_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#x27;更新时间&#x27;,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `idx_user_enterprise` (`user_id`, `enterprise_id`),</span><br><span class="line">  KEY `idx_enterprise_created` (`enterprise_id`, `created_at` DESC, `status`),</span><br><span class="line">  KEY `idx_enterprise_pinned` (`enterprise_id`, `is_pinned` DESC, `like_count` DESC),</span><br><span class="line">  KEY `idx_hot_content_24h` (`enterprise_id`, `created_at`, `like_count`, `status`),</span><br><span class="line">  CONSTRAINT `fk_posts_user` FOREIGN KEY (`user_id`) REFERENCES `users` (`id`),</span><br><span class="line">  CONSTRAINT `fk_posts_enterprise` FOREIGN KEY (`enterprise_id`) REFERENCES `enterprises` (`id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT=&#x27;企业圈内容表&#x27;;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-6-点赞表-likes"><a href="#3-2-6-点赞表-likes" class="headerlink" title="3.2.6 点赞表 (likes)"></a>3.2.6 点赞表 (likes)</h4><p>支持分表存储，与posts表采用相同的分片策略。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 分表模板，与posts表保持一致的分片策略</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `likes_$&#123;shard&#125;` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;点赞ID&#x27;</span>,</span><br><span class="line">  `post_id` <span class="type">bigint</span>(<span class="number">20</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;内容ID&#x27;</span>,</span><br><span class="line">  `user_id` <span class="type">bigint</span>(<span class="number">20</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户ID&#x27;</span>,</span><br><span class="line">  `enterprise_id` <span class="type">bigint</span>(<span class="number">20</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;企业ID&#x27;</span>,</span><br><span class="line">  `created_at` <span class="type">timestamp</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;点赞时间&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_post_user` (`post_id`, `user_id`),</span><br><span class="line">  KEY `idx_user_enterprise` (`user_id`, `enterprise_id`),</span><br><span class="line">  KEY `idx_post_created` (`post_id`, `created_at`),</span><br><span class="line">  KEY `idx_enterprise_created` (`enterprise_id`, `created_at`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 COMMENT<span class="operator">=</span><span class="string">&#x27;点赞表&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-7-评论表-comments"><a href="#3-2-7-评论表-comments" class="headerlink" title="3.2.7 评论表 (comments)"></a>3.2.7 评论表 (comments)</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 分表模板，与posts表保持一致的分片策略</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `comments_$&#123;shard&#125;` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;评论ID&#x27;</span>,</span><br><span class="line">  `post_id` <span class="type">bigint</span>(<span class="number">20</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;内容ID&#x27;</span>,</span><br><span class="line">  `user_id` <span class="type">bigint</span>(<span class="number">20</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;评论用户ID&#x27;</span>,</span><br><span class="line">  `enterprise_id` <span class="type">bigint</span>(<span class="number">20</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;企业ID&#x27;</span>,</span><br><span class="line">  `parent_id` <span class="type">bigint</span>(<span class="number">20</span>) unsigned <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;父评论ID,0为顶级评论&#x27;</span>,</span><br><span class="line">  `root_id` <span class="type">bigint</span>(<span class="number">20</span>) unsigned <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;根评论ID&#x27;</span>,</span><br><span class="line">  `reply_to_user_id` <span class="type">bigint</span>(<span class="number">20</span>) unsigned <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;回复的用户ID&#x27;</span>,</span><br><span class="line">  `content` text <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;评论内容&#x27;</span>,</span><br><span class="line">  `like_count` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;评论点赞数&#x27;</span>,</span><br><span class="line">  `reply_count` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;回复数&#x27;</span>,</span><br><span class="line">  `status` tinyint(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="number">1</span> COMMENT <span class="string">&#x27;状态: 1-正常, 0-删除&#x27;</span>,</span><br><span class="line">  `created_at` <span class="type">timestamp</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `updated_at` <span class="type">timestamp</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;更新时间&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `idx_post_id` (`post_id`, `status`, `created_at`),</span><br><span class="line">  KEY `idx_user_enterprise` (`user_id`, `enterprise_id`),</span><br><span class="line">  KEY `idx_parent_id` (`parent_id`),</span><br><span class="line">  KEY `idx_root_id` (`root_id`),</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> `fk_comments_post` <span class="keyword">FOREIGN</span> KEY (`post_id`) <span class="keyword">REFERENCES</span> `posts_$&#123;shard&#125;` (`id`),</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> `fk_comments_user` <span class="keyword">FOREIGN</span> KEY (`user_id`) <span class="keyword">REFERENCES</span> `users` (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 COMMENT<span class="operator">=</span><span class="string">&#x27;评论表&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-8-数据库设计总结"><a href="#3-2-8-数据库设计总结" class="headerlink" title="3.2.8 数据库设计总结"></a>3.2.8 数据库设计总结</h4><p>****设计原则****：</p>
<ol>
<li>****数据隔离****：通过enterprise_id实现严格的企业数据隔离</li>
<li>****水平扩展****：采用分表策略支持大规模数据存储</li>
<li>****查询优化****：针对核心查询场景设计复合索引</li>
<li>****数据完整性****：使用外键约束保证数据一致性</li>
<li>****软删除****：重要数据采用status字段实现软删除</li>
</ol>
<p>****核心查询场景及优化****：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 场景1：获取企业圈动态（置顶+普通内容）</span></span><br><span class="line"><span class="comment">-- 查询策略：先查置顶，再查普通，合并结果</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> posts_$&#123;shard&#125; </span><br><span class="line"><span class="keyword">WHERE</span> enterprise_id <span class="operator">=</span> ? <span class="keyword">AND</span> status <span class="operator">=</span> <span class="number">1</span> <span class="keyword">AND</span> is_pinned <span class="operator">=</span> <span class="number">1</span> </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> like_count <span class="keyword">DESC</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> posts_$&#123;shard&#125; </span><br><span class="line"><span class="keyword">WHERE</span> enterprise_id <span class="operator">=</span> ? <span class="keyword">AND</span> status <span class="operator">=</span> <span class="number">1</span> <span class="keyword">AND</span> is_pinned <span class="operator">=</span> <span class="number">0</span> </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> created_at <span class="keyword">DESC</span> </span><br><span class="line">LIMIT ? <span class="keyword">OFFSET</span> ?;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 场景2：24小时热门内容查询（置顶算法核心）</span></span><br><span class="line"><span class="keyword">SELECT</span> id, like_count, created_at </span><br><span class="line"><span class="keyword">FROM</span> posts_$&#123;shard&#125; </span><br><span class="line"><span class="keyword">WHERE</span> enterprise_id <span class="operator">=</span> ? </span><br><span class="line">  <span class="keyword">AND</span> created_at <span class="operator">&gt;=</span> DATE_SUB(NOW(), <span class="type">INTERVAL</span> <span class="number">24</span> <span class="keyword">HOUR</span>)</span><br><span class="line">  <span class="keyword">AND</span> like_count <span class="operator">&gt;</span> <span class="number">10</span> </span><br><span class="line">  <span class="keyword">AND</span> status <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> like_count <span class="keyword">DESC</span>, created_at <span class="keyword">DESC</span> </span><br><span class="line">LIMIT <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 场景3：用户点赞状态批量查询</span></span><br><span class="line"><span class="keyword">SELECT</span> post_id </span><br><span class="line"><span class="keyword">FROM</span> likes_$&#123;shard&#125; </span><br><span class="line"><span class="keyword">WHERE</span> user_id <span class="operator">=</span> ? <span class="keyword">AND</span> post_id <span class="keyword">IN</span> (?, ?, ?);</span><br></pre></td></tr></table></figure>

<h3 id="3-3-系统功能设计"><a href="#3-3-系统功能设计" class="headerlink" title="3.3 系统功能设计"></a>3.3 系统功能设计</h3><h4 id="3-3-1-用户认证与权限管理"><a href="#3-3-1-用户认证与权限管理" class="headerlink" title="3.3.1 用户认证与权限管理"></a>3.3.1 用户认证与权限管理</h4><p>****功能描述****：</p>
<ul>
<li>用户注册：企业员工通过企业邀请码注册</li>
<li>用户登录：用户名&#x2F;邮箱 + 密码登录，返回JWT令牌</li>
<li>权限验证：基于企业ID的数据隔离，确保跨企业数据安全</li>
<li>会话管理：JWT令牌有效期管理，支持令牌刷新</li>
</ul>
<p>****技术实现方案****：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> AuthService <span class="keyword">struct</span> &#123;</span><br><span class="line">    userRepo     repository.UserRepository</span><br><span class="line">    redisClient  redis.Client</span><br><span class="line">    jwtSecret    <span class="type">string</span></span><br><span class="line">    tokenExpiry  time.Duration</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户登录</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *AuthService)</span></span> Login(ctx context.Context, req *LoginRequest) (*LoginResponse, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 1. 验证用户凭证</span></span><br><span class="line">    user, err := s.userRepo.GetByUsername(ctx, req.Username)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> || !s.verifyPassword(req.Password, user.PasswordHash) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;用户名或密码错误&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 生成JWT令牌</span></span><br><span class="line">    token, err := s.generateJWT(user.ID, user.EnterpriseID)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 缓存用户会话信息</span></span><br><span class="line">    s.cacheUserSession(ctx, user.ID, user)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 更新最后登录时间</span></span><br><span class="line">    s.userRepo.UpdateLastLogin(ctx, user.ID)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> &amp;LoginResponse&#123;</span><br><span class="line">        Token: token,</span><br><span class="line">        User:  s.buildUserVO(user),</span><br><span class="line">    &#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 企业权限验证中间件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *AuthService)</span></span> EnterpriseAuthMiddleware() gin.HandlerFunc &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        userID := c.GetInt64(<span class="string">&quot;user_id&quot;</span>)</span><br><span class="line">        enterpriseID := c.GetInt64(<span class="string">&quot;enterprise_id&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从缓存中获取用户信息</span></span><br><span class="line">        user := s.getUserFromCache(c.Request.Context(), userID)</span><br><span class="line">        <span class="keyword">if</span> user == <span class="literal">nil</span> || user.EnterpriseID != enterpriseID &#123;</span><br><span class="line">            c.JSON(<span class="number">403</span>, gin.H&#123;<span class="string">&quot;error&quot;</span>: <span class="string">&quot;无权访问该企业内容&quot;</span>&#125;)</span><br><span class="line">            c.Abort()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        c.Set(<span class="string">&quot;user&quot;</span>, user)</span><br><span class="line">        c.Next()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-2-企业圈内容管理"><a href="#3-3-2-企业圈内容管理" class="headerlink" title="3.3.2 企业圈内容管理"></a>3.3.2 企业圈内容管理</h4><p>****功能描述****：</p>
<ul>
<li>内容发布：支持文本、图片、视频、位置等多媒体内容</li>
<li>内容删除：用户只能删除自己发布的内容</li>
<li>内容编辑：支持发布后24小时内编辑</li>
<li>动态Feed：获取企业内容动态，置顶内容优先展示</li>
</ul>
<p>****核心业务逻辑****：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ContentService <span class="keyword">struct</span> &#123;</span><br><span class="line">    postRepo     repository.PostRepository</span><br><span class="line">    userRepo     repository.UserRepository</span><br><span class="line">    redisClient  redis.Client</span><br><span class="line">    messageQueue mq.MessageQueue</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发布内容</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *ContentService)</span></span> CreatePost(ctx context.Context, req *CreatePostRequest) (*PostVO, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 1. 参数验证</span></span><br><span class="line">    <span class="keyword">if</span> err := s.validateCreateRequest(req); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 构建内容对象</span></span><br><span class="line">    post := &amp;model.Post&#123;</span><br><span class="line">        UserID:       req.UserID,</span><br><span class="line">        EnterpriseID: req.EnterpriseID,</span><br><span class="line">        Content:      req.Content,</span><br><span class="line">        Images:       req.Images,</span><br><span class="line">        VideoURL:     req.VideoURL,</span><br><span class="line">        Location:     req.Location,</span><br><span class="line">        Tags:         req.Tags,</span><br><span class="line">        Status:       <span class="number">1</span>,</span><br><span class="line">        CreatedAt:    time.Now(),</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 数据库写入</span></span><br><span class="line">    shard := s.getShardByEnterpriseID(req.EnterpriseID)</span><br><span class="line">    <span class="keyword">if</span> err := s.postRepo.Create(ctx, shard, post); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 异步更新Feed缓存</span></span><br><span class="line">    s.messageQueue.Publish(<span class="string">&quot;feed.update&quot;</span>, &amp;FeedUpdateMessage&#123;</span><br><span class="line">        PostID:       post.ID,</span><br><span class="line">        EnterpriseID: req.EnterpriseID,</span><br><span class="line">        Action:       <span class="string">&quot;create&quot;</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> s.buildPostVO(ctx, post), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取企业圈动态Feed</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *ContentService)</span></span> GetEnterpriseFeed(ctx context.Context, enterpriseID <span class="type">int64</span>, userID <span class="type">int64</span>, page, size <span class="type">int</span>) (*FeedResponse, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 1. 尝试从缓存获取</span></span><br><span class="line">    cacheKey := fmt.Sprintf(<span class="string">&quot;feed:%d:%d:%d&quot;</span>, enterpriseID, page, size)</span><br><span class="line">    <span class="keyword">if</span> cachedFeed := s.getFeedFromCache(ctx, cacheKey); cachedFeed != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cachedFeed, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 获取置顶内容（仅第一页显示）</span></span><br><span class="line">    <span class="keyword">var</span> pinnedPosts []*model.Post</span><br><span class="line">    <span class="keyword">if</span> page == <span class="number">1</span> &#123;</span><br><span class="line">        pinnedPosts = s.getPinnedPosts(ctx, enterpriseID)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 获取普通内容</span></span><br><span class="line">    shard := s.getShardByEnterpriseID(enterpriseID)</span><br><span class="line">    offset := (page - <span class="number">1</span>) * size</span><br><span class="line">    normalPosts, total, err := s.postRepo.GetByEnterpriseID(ctx, shard, enterpriseID, offset, size)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 合并结果</span></span><br><span class="line">    allPosts := <span class="built_in">append</span>(pinnedPosts, normalPosts...)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5. 构建响应对象，包含用户点赞状态</span></span><br><span class="line">    posts := <span class="built_in">make</span>([]*PostVO, <span class="number">0</span>, <span class="built_in">len</span>(allPosts))</span><br><span class="line">    <span class="keyword">for</span> _, post := <span class="keyword">range</span> allPosts &#123;</span><br><span class="line">        postVO := s.buildPostVO(ctx, post)</span><br><span class="line">        postVO.IsLiked = s.checkUserLiked(ctx, post.ID, userID)</span><br><span class="line">        posts = <span class="built_in">append</span>(posts, postVO)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    response := &amp;FeedResponse&#123;</span><br><span class="line">        Posts: posts,</span><br><span class="line">        Pagination: &amp;PaginationVO&#123;</span><br><span class="line">            Page:    page,</span><br><span class="line">            Size:    size,</span><br><span class="line">            Total:   total,</span><br><span class="line">            HasMore: offset+size &lt; <span class="type">int</span>(total),</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 6. 缓存结果（缓存5分钟）</span></span><br><span class="line">    s.cacheFeedResult(ctx, cacheKey, response, <span class="number">5</span>*time.Minute)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> response, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-3-智能点赞系统"><a href="#3-3-3-智能点赞系统" class="headerlink" title="3.3.3 智能点赞系统"></a>3.3.3 智能点赞系统</h4><p>****功能描述****：</p>
<ul>
<li>点赞&#x2F;取消点赞：支持快速响应，防止重复点赞</li>
<li>实时计数：使用Redis实现高性能计数器</li>
<li>点赞列表：支持分页获取点赞用户列表</li>
<li>并发安全：使用分布式锁防止并发问题</li>
</ul>
<p>****技术实现****：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type LikeService struct &#123;</span><br><span class="line">    likeRepo    repository.LikeRepository</span><br><span class="line">    postRepo    repository.PostRepository</span><br><span class="line">    redisClient redis.Client</span><br><span class="line">    lockManager distributed.LockManager</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 点赞/取消点赞 - 支持高并发</span><br><span class="line">func (s *LikeService) ToggleLike(ctx context.Context, postID, userID, enterpriseID int64) (*LikeResult, error) &#123;</span><br><span class="line">    // 1. 分布式锁防止并发点赞</span><br><span class="line">    lockKey := fmt.Sprintf(&quot;like:lock:%d:%d&quot;, postID, userID)</span><br><span class="line">    lock, err := s.lockManager.Acquire(ctx, lockKey, 5*time.Second)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        return nil, errors.New(&quot;系统繁忙，请稍后重试&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    defer lock.Release()</span><br><span class="line">    </span><br><span class="line">    // 2. 检查当前点赞状态</span><br><span class="line">    shard := s.getShardByEnterpriseID(enterpriseID)</span><br><span class="line">    exists, err := s.likeRepo.CheckExists(ctx, shard, postID, userID)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        return nil, err</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    var isLiked bool</span><br><span class="line">    var likeCount int64</span><br><span class="line">    </span><br><span class="line">    if exists &#123;</span><br><span class="line">        // 取消点赞</span><br><span class="line">        if err := s.likeRepo.Delete(ctx, shard, postID, userID); err != nil &#123;</span><br><span class="line">            return nil, err</span><br><span class="line">        &#125;</span><br><span class="line">        likeCount = s.decrementLikeCount(ctx, postID)</span><br><span class="line">        isLiked = false</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 添加点赞</span><br><span class="line">        like := &amp;model.Like&#123;</span><br><span class="line">            PostID:       postID,</span><br><span class="line">            UserID:       userID,</span><br><span class="line">            EnterpriseID: enterpriseID,</span><br><span class="line">            CreatedAt:    time.Now(),</span><br><span class="line">        &#125;</span><br><span class="line">        if err := s.likeRepo.Create(ctx, shard, like); err != nil &#123;</span><br><span class="line">            return nil, err</span><br><span class="line">        &#125;</span><br><span class="line">        likeCount = s.incrementLikeCount(ctx, postID)</span><br><span class="line">        isLiked = true</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 3. 异步检查置顶条件</span><br><span class="line">    go s.checkPinnedCondition(postID, enterpriseID, likeCount)</span><br><span class="line">    </span><br><span class="line">    return &amp;LikeResult&#123;</span><br><span class="line">        IsLiked:   isLiked,</span><br><span class="line">        LikeCount: likeCount,</span><br><span class="line">    &#125;, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 高性能点赞计数器</span><br><span class="line">func (s *LikeService) incrementLikeCount(ctx context.Context, postID int64) int64 &#123;</span><br><span class="line">    key := fmt.Sprintf(&quot;post:like_count:%d&quot;, postID)</span><br><span class="line">    count := s.redisClient.Incr(ctx, key).Val()</span><br><span class="line">    </span><br><span class="line">    // 设置过期时间24小时</span><br><span class="line">    s.redisClient.Expire(ctx, key, 24*time.Hour)</span><br><span class="line">    </span><br><span class="line">    return count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-4-智能置顶算法系统"><a href="#3-3-4-智能置顶算法系统" class="headerlink" title="3.3.4 智能置顶算法系统"></a>3.3.4 智能置顶算法系统</h4><p>****功能描述****：</p>
<ul>
<li>自动检测：24小时内发布且点赞数超过10的内容</li>
<li>智能排序：点赞数前三的内容自动置顶</li>
<li>动态更新：每小时重新计算置顶内容</li>
<li>公平机制：相同点赞数的内容按发布时间排序</li>
</ul>
<p>****核心算法实现****：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> PinnedService <span class="keyword">struct</span> &#123;</span><br><span class="line">    postRepo    repository.PostRepository</span><br><span class="line">    redisClient redis.Client</span><br><span class="line">    scheduler   *cron.Cron</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定时任务：更新置顶内容</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *PinnedService)</span></span> UpdatePinnedPosts() &#123;</span><br><span class="line">    enterprises, err := s.getAllActiveEnterprises()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Error(<span class="string">&quot;获取企业列表失败&quot;</span>, zap.Error(err))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _, enterpriseID := <span class="keyword">range</span> enterprises &#123;</span><br><span class="line">        <span class="keyword">if</span> err := s.updateEnterpriseTopPosts(enterpriseID); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Error(<span class="string">&quot;更新企业置顶内容失败&quot;</span>, </span><br><span class="line">                zap.Int64(<span class="string">&quot;enterprise_id&quot;</span>, enterpriseID), </span><br><span class="line">                zap.Error(err))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新单个企业的置顶内容</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *PinnedService)</span></span> updateEnterpriseTopPosts(enterpriseID <span class="type">int64</span>) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 获取24小时内的热门内容（点赞数&gt;10）</span></span><br><span class="line">    shard := s.getShardByEnterpriseID(enterpriseID)</span><br><span class="line">    start := time.Now().Add(<span class="number">-24</span> * time.Hour)</span><br><span class="line">    </span><br><span class="line">    hotPosts, err := s.postRepo.GetHotPostsByTimeRange(context.Background(), shard, enterpriseID, start, <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 获取实时点赞数（从Redis获取最新数据）</span></span><br><span class="line">    <span class="keyword">for</span> _, post := <span class="keyword">range</span> hotPosts &#123;</span><br><span class="line">        realLikeCount := s.getRealTimeLikeCount(post.ID)</span><br><span class="line">        <span class="keyword">if</span> realLikeCount &gt; <span class="number">0</span> &#123;</span><br><span class="line">            post.LikeCount = <span class="type">int</span>(realLikeCount)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 按点赞数排序（点赞数相同时按创建时间排序）</span></span><br><span class="line">    sort.Slice(hotPosts, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> hotPosts[i].LikeCount == hotPosts[j].LikeCount &#123;</span><br><span class="line">            <span class="keyword">return</span> hotPosts[i].CreatedAt.After(hotPosts[j].CreatedAt)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hotPosts[i].LikeCount &gt; hotPosts[j].LikeCount</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 清空旧的置顶状态</span></span><br><span class="line">    <span class="keyword">if</span> err := s.postRepo.ClearPinnedStatus(context.Background(), shard, enterpriseID); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5. 设置新的置顶内容（前3名）</span></span><br><span class="line">    topCount := <span class="built_in">len</span>(hotPosts)</span><br><span class="line">    <span class="keyword">if</span> topCount &gt; <span class="number">3</span> &#123;</span><br><span class="line">        topCount = <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; topCount; i++ &#123;</span><br><span class="line">        post := hotPosts[i]</span><br><span class="line">        err := s.postRepo.SetPinnedStatus(context.Background(), shard, post.ID, i+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Error(<span class="string">&quot;设置置顶状态失败&quot;</span>, zap.Int64(<span class="string">&quot;post_id&quot;</span>, post.ID), zap.Error(err))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 6. 更新缓存</span></span><br><span class="line">    s.updatePinnedCache(enterpriseID, hotPosts[:topCount])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实时检查置顶条件（点赞触发）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *PinnedService)</span></span> CheckPinnedCondition(postID, enterpriseID <span class="type">int64</span>, likeCount <span class="type">int64</span>) &#123;</span><br><span class="line">    <span class="comment">// 只有点赞数达到10时才触发检查</span></span><br><span class="line">    <span class="keyword">if</span> likeCount == <span class="number">10</span> &#123;</span><br><span class="line">        <span class="comment">// 检查是否为24小时内发布</span></span><br><span class="line">        shard := s.getShardByEnterpriseID(enterpriseID)</span><br><span class="line">        post, err := s.postRepo.GetByID(context.Background(), shard, postID)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> time.Since(post.CreatedAt) &lt;= <span class="number">24</span>*time.Hour &#123;</span><br><span class="line">            <span class="comment">// 异步触发置顶更新</span></span><br><span class="line">            <span class="keyword">go</span> s.updateEnterpriseTopPosts(enterpriseID)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-5-评论系统"><a href="#3-3-5-评论系统" class="headerlink" title="3.3.5 评论系统"></a>3.3.5 评论系统</h4><p>****功能描述****：</p>
<ul>
<li>顶级评论：直接对内容进行评论</li>
<li>回复评论：支持二级回复（回复具体的评论）</li>
<li>评论删除：评论者和内容发布者均可删除</li>
<li>评论点赞：支持对评论进行点赞</li>
</ul>
<p>****技术实现****：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type CommentService struct &#123;</span><br><span class="line">    commentRepo repository.CommentRepository</span><br><span class="line">    postRepo    repository.PostRepository</span><br><span class="line">    redisClient redis.Client</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 发表评论</span><br><span class="line">func (s *CommentService) CreateComment(ctx context.Context, req *CreateCommentRequest) (*CommentVO, error) &#123;</span><br><span class="line">    // 1. 验证目标内容是否存在</span><br><span class="line">    shard := s.getShardByEnterpriseID(req.EnterpriseID)</span><br><span class="line">    post, err := s.postRepo.GetByID(ctx, shard, req.PostID)</span><br><span class="line">    if err != nil || post.Status != 1 &#123;</span><br><span class="line">        return nil, errors.New(&quot;目标内容不存在或已删除&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 2. 如果是回复评论，验证父评论</span><br><span class="line">    var rootID int64 = 0</span><br><span class="line">    if req.ParentID &gt; 0 &#123;</span><br><span class="line">        parentComment, err := s.commentRepo.GetByID(ctx, shard, req.ParentID)</span><br><span class="line">        if err != nil &#123;</span><br><span class="line">            return nil, errors.New(&quot;父评论不存在&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        // 确定根评论ID</span><br><span class="line">        if parentComment.RootID &gt; 0 &#123;</span><br><span class="line">            rootID = parentComment.RootID</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            rootID = parentComment.ID</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 3. 创建评论</span><br><span class="line">    comment := &amp;model.Comment&#123;</span><br><span class="line">        PostID:         req.PostID,</span><br><span class="line">        UserID:         req.UserID,</span><br><span class="line">        EnterpriseID:   req.EnterpriseID,</span><br><span class="line">        ParentID:       req.ParentID,</span><br><span class="line">        RootID:         rootID,</span><br><span class="line">        ReplyToUserID:  req.ReplyToUserID,</span><br><span class="line">        Content:        req.Content,</span><br><span class="line">        Status:         1,</span><br><span class="line">        CreatedAt:      time.Now(),</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if err := s.commentRepo.Create(ctx, shard, comment); err != nil &#123;</span><br><span class="line">        return nil, err</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 4. 更新内容的评论数</span><br><span class="line">    s.postRepo.IncrementCommentCount(ctx, shard, req.PostID)</span><br><span class="line">    </span><br><span class="line">    // 5. 如果是回复，更新父评论的回复数</span><br><span class="line">    if req.ParentID &gt; 0 &#123;</span><br><span class="line">        s.commentRepo.IncrementReplyCount(ctx, shard, req.ParentID)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return s.buildCommentVO(ctx, comment), nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-6-缓存策略设计"><a href="#3-3-6-缓存策略设计" class="headerlink" title="3.3.6 缓存策略设计"></a>3.3.6 缓存策略设计</h4><p>****Redis数据结构设计****：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 点赞计数器</span><br><span class="line">Key: <span class="string">&quot;post:like_count:&#123;post_id&#125;&quot;</span></span><br><span class="line">Type: String</span><br><span class="line">TTL: 24小时</span><br><span class="line">Value: 点赞数量</span><br><span class="line"></span><br><span class="line">// 用户会话缓存</span><br><span class="line">Key: <span class="string">&quot;user:session:&#123;user_id&#125;&quot;</span></span><br><span class="line">Type: Hash</span><br><span class="line">TTL: 7天</span><br><span class="line">Fields: &#123;<span class="string">&quot;id&quot;</span>, <span class="string">&quot;enterprise_id&quot;</span>, <span class="string">&quot;nickname&quot;</span>, <span class="string">&quot;avatar&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">// 企业Feed缓存</span><br><span class="line">Key: <span class="string">&quot;feed:&#123;enterprise_id&#125;:&#123;page&#125;:&#123;size&#125;&quot;</span></span><br><span class="line">Type: String (JSON)</span><br><span class="line">TTL: 5分钟</span><br><span class="line">Value: 序列化的动态列表</span><br><span class="line"></span><br><span class="line">// 置顶内容缓存</span><br><span class="line">Key: <span class="string">&quot;pinned:posts:&#123;enterprise_id&#125;&quot;</span></span><br><span class="line">Type: List</span><br><span class="line">TTL: 1小时</span><br><span class="line">Value: 置顶内容ID列表（按排序）</span><br><span class="line"></span><br><span class="line">// 热门内容24小时榜单</span><br><span class="line">Key: <span class="string">&quot;hot:posts:24h:&#123;enterprise_id&#125;&quot;</span></span><br><span class="line">Type: Sorted Set</span><br><span class="line">TTL: 1小时</span><br><span class="line">Score: 点赞数，Member: post_id</span><br></pre></td></tr></table></figure>

<h3 id="3-4-接口设计"><a href="#3-4-接口设计" class="headerlink" title="3.4 接口设计"></a>3.4 接口设计</h3><h4 id="3-4-1-用户认证接口"><a href="#3-4-1-用户认证接口" class="headerlink" title="3.4.1 用户认证接口"></a>3.4.1 用户认证接口</h4><h5 id="用户注册"><a href="#用户注册" class="headerlink" title="用户注册"></a>用户注册</h5><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST /api/v1/auth/register</span><br><span class="line">Content-Type<span class="punctuation">:</span> application/json</span><br><span class="line"></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;username&quot;</span><span class="punctuation">:</span> <span class="string">&quot;zhangsan&quot;</span><span class="punctuation">,</span>           <span class="comment">// 必填，用户名，3-20字符</span></span><br><span class="line">    <span class="attr">&quot;password&quot;</span><span class="punctuation">:</span> <span class="string">&quot;password123&quot;</span><span class="punctuation">,</span>        <span class="comment">// 必填，密码，8-32字符</span></span><br><span class="line">    <span class="attr">&quot;email&quot;</span><span class="punctuation">:</span> <span class="string">&quot;zhangsan@company.com&quot;</span><span class="punctuation">,</span>  <span class="comment">// 必填，邮箱地址</span></span><br><span class="line">    <span class="attr">&quot;nickname&quot;</span><span class="punctuation">:</span> <span class="string">&quot;张三&quot;</span><span class="punctuation">,</span>               <span class="comment">// 必填，昵称，1-20字符</span></span><br><span class="line">    <span class="attr">&quot;phone&quot;</span><span class="punctuation">:</span> <span class="string">&quot;13800138000&quot;</span><span class="punctuation">,</span>           <span class="comment">// 可选，手机号</span></span><br><span class="line">    <span class="attr">&quot;department&quot;</span><span class="punctuation">:</span> <span class="string">&quot;技术部&quot;</span><span class="punctuation">,</span>           <span class="comment">// 可选，部门</span></span><br><span class="line">    <span class="attr">&quot;position&quot;</span><span class="punctuation">:</span> <span class="string">&quot;高级工程师&quot;</span><span class="punctuation">,</span>         <span class="comment">// 可选，职位</span></span><br><span class="line">    <span class="attr">&quot;enterprise_code&quot;</span><span class="punctuation">:</span> <span class="string">&quot;TECH001&quot;</span>      <span class="comment">// 必填，企业邀请码</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>****响应示例****：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">200</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;注册成功&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;user_id&quot;</span><span class="punctuation">:</span> <span class="number">1001</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;username&quot;</span><span class="punctuation">:</span> <span class="string">&quot;zhangsan&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;nickname&quot;</span><span class="punctuation">:</span> <span class="string">&quot;张三&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;enterprise_name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;科技有限公司&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="用户登录"><a href="#用户登录" class="headerlink" title="用户登录"></a>用户登录</h5><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST /api/v1/auth/login</span><br><span class="line">Content-Type<span class="punctuation">:</span> application/json</span><br><span class="line"></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;username&quot;</span><span class="punctuation">:</span> <span class="string">&quot;zhangsan&quot;</span><span class="punctuation">,</span>     <span class="comment">// 用户名或邮箱</span></span><br><span class="line">    <span class="attr">&quot;password&quot;</span><span class="punctuation">:</span> <span class="string">&quot;password123&quot;</span>   <span class="comment">// 密码</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>****响应示例****：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">200</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;登录成功&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;token&quot;</span><span class="punctuation">:</span> <span class="string">&quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;expires_in&quot;</span><span class="punctuation">:</span> <span class="number">7200</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;user&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1001</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;username&quot;</span><span class="punctuation">:</span> <span class="string">&quot;zhangsan&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;nickname&quot;</span><span class="punctuation">:</span> <span class="string">&quot;张三&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;avatar&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://cdn.example.com/avatars/1001.jpg&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;department&quot;</span><span class="punctuation">:</span> <span class="string">&quot;技术部&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;position&quot;</span><span class="punctuation">:</span> <span class="string">&quot;高级工程师&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;enterprise&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">100</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;科技有限公司&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;logo&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://cdn.example.com/logos/100.jpg&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="刷新令牌"><a href="#刷新令牌" class="headerlink" title="刷新令牌"></a>刷新令牌</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /api/v1/auth/refresh</span><br><span class="line">Authorization: Bearer &#123;token&#125;</span><br></pre></td></tr></table></figure>

<h5 id="用户登出"><a href="#用户登出" class="headerlink" title="用户登出"></a>用户登出</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /api/v1/auth/logout</span><br><span class="line">Authorization: Bearer &#123;token&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-4-2-企业圈内容接口"><a href="#3-4-2-企业圈内容接口" class="headerlink" title="3.4.2 企业圈内容接口"></a>3.4.2 企业圈内容接口</h4><h5 id="发布内容"><a href="#发布内容" class="headerlink" title="发布内容"></a>发布内容</h5><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST /api/v1/posts</span><br><span class="line">Authorization<span class="punctuation">:</span> Bearer <span class="punctuation">&#123;</span>token<span class="punctuation">&#125;</span></span><br><span class="line">Content-Type<span class="punctuation">:</span> application/json</span><br><span class="line"></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="string">&quot;今天的工作总结，团队协作很棒！&quot;</span><span class="punctuation">,</span>     <span class="comment">// 必填，内容文本，1-2000字符</span></span><br><span class="line">    <span class="attr">&quot;images&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span>                                      <span class="comment">// 可选，图片URL数组，最多9张</span></span><br><span class="line">        <span class="string">&quot;https://cdn.example.com/images/001.jpg&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;https://cdn.example.com/images/002.jpg&quot;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;video_url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://cdn.example.com/video.mp4&quot;</span><span class="punctuation">,</span> <span class="comment">// 可选，视频URL</span></span><br><span class="line">    <span class="attr">&quot;location&quot;</span><span class="punctuation">:</span> <span class="string">&quot;北京市朝阳区望京SOHO&quot;</span><span class="punctuation">,</span>                <span class="comment">// 可选，位置信息</span></span><br><span class="line">    <span class="attr">&quot;tags&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;工作总结&quot;</span><span class="punctuation">,</span> <span class="string">&quot;团队协作&quot;</span><span class="punctuation">]</span>                   <span class="comment">// 可选，标签数组</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>****响应示例****：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">200</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;发布成功&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">123456</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="string">&quot;今天的工作总结，团队协作很棒！&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;images&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;https://cdn.example.com/images/001.jpg&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;https://cdn.example.com/images/002.jpg&quot;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;video_url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://cdn.example.com/video.mp4&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;location&quot;</span><span class="punctuation">:</span> <span class="string">&quot;北京市朝阳区望京SOHO&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;tags&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;工作总结&quot;</span><span class="punctuation">,</span> <span class="string">&quot;团队协作&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;like_count&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;comment_count&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;view_count&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;is_pinned&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;created_at&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2024-12-19T10:00:00Z&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="获取企业圈动态"><a href="#获取企业圈动态" class="headerlink" title="获取企业圈动态"></a>获取企业圈动态</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /api/v1/posts?page=1&amp;size=20&amp;sort=created_at</span><br><span class="line">Authorization: Bearer &#123;token&#125;</span><br></pre></td></tr></table></figure>

<p>****查询参数****：</p>
<ul>
<li><code>page</code>: 页码，默认1</li>
<li><code>size</code>: 每页数量，默认20，最大100</li>
<li><code>sort</code>: 排序方式，可选值：created_at（时间）、like_count（点赞数）</li>
</ul>
<p>****响应示例****：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">200</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;获取成功&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;posts&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">123456</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;user&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1001</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;nickname&quot;</span><span class="punctuation">:</span> <span class="string">&quot;张三&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;avatar&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://cdn.example.com/avatars/1001.jpg&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;department&quot;</span><span class="punctuation">:</span> <span class="string">&quot;技术部&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;position&quot;</span><span class="punctuation">:</span> <span class="string">&quot;高级工程师&quot;</span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="string">&quot;今天的工作总结，团队协作很棒！&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;images&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                    <span class="string">&quot;https://cdn.example.com/images/001.jpg&quot;</span></span><br><span class="line">                <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;video_url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;location&quot;</span><span class="punctuation">:</span> <span class="string">&quot;北京市朝阳区望京SOHO&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;tags&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;工作总结&quot;</span><span class="punctuation">,</span> <span class="string">&quot;团队协作&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;like_count&quot;</span><span class="punctuation">:</span> <span class="number">25</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;comment_count&quot;</span><span class="punctuation">:</span> <span class="number">8</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;view_count&quot;</span><span class="punctuation">:</span> <span class="number">156</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;share_count&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;is_liked&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;is_pinned&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;pinned_order&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;can_edit&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;can_delete&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;created_at&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2024-12-19T08:30:00Z&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;updated_at&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2024-12-19T08:30:00Z&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;pagination&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;page&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">20</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;total&quot;</span><span class="punctuation">:</span> <span class="number">156</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;has_more&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="获取单个内容详情"><a href="#获取单个内容详情" class="headerlink" title="获取单个内容详情"></a>获取单个内容详情</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /api/v1/posts/&#123;post_id&#125;</span><br><span class="line">Authorization: Bearer &#123;token&#125;</span><br></pre></td></tr></table></figure>

<h5 id="编辑内容"><a href="#编辑内容" class="headerlink" title="编辑内容"></a>编辑内容</h5><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /api/v1/posts/<span class="punctuation">&#123;</span>post_id<span class="punctuation">&#125;</span></span><br><span class="line">Authorization<span class="punctuation">:</span> Bearer <span class="punctuation">&#123;</span>token<span class="punctuation">&#125;</span></span><br><span class="line">Content-Type<span class="punctuation">:</span> application/json</span><br><span class="line"></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="string">&quot;修改后的内容&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;images&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;https://cdn.example.com/images/new.jpg&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;tags&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;新标签&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>****业务规则****：</p>
<ul>
<li>只能编辑自己发布的内容</li>
<li>发布后24小时内可编辑</li>
<li>编辑后重置点赞和评论计数</li>
</ul>
<h5 id="删除内容"><a href="#删除内容" class="headerlink" title="删除内容"></a>删除内容</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELETE /api/v1/posts/&#123;post_id&#125;</span><br><span class="line">Authorization: Bearer &#123;token&#125;</span><br></pre></td></tr></table></figure>

<p>****响应示例****：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">200</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;删除成功&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="3-4-3-点赞相关接口"><a href="#3-4-3-点赞相关接口" class="headerlink" title="3.4.3 点赞相关接口"></a>3.4.3 点赞相关接口</h4><h5 id="点赞-取消点赞"><a href="#点赞-取消点赞" class="headerlink" title="点赞&#x2F;取消点赞"></a>点赞&#x2F;取消点赞</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /api/v1/posts/&#123;post_id&#125;/like</span><br><span class="line">Authorization: Bearer &#123;token&#125;</span><br></pre></td></tr></table></figure>

<p>****路径参数****：</p>
<ul>
<li><code>post_id</code>: 内容ID，必填</li>
</ul>
<p>****响应示例****：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">200</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;操作成功&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;is_liked&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>          <span class="comment">// 当前点赞状态</span></span><br><span class="line">        <span class="attr">&quot;like_count&quot;</span><span class="punctuation">:</span> <span class="number">26</span><span class="punctuation">,</span>          <span class="comment">// 最新点赞总数</span></span><br><span class="line">        <span class="attr">&quot;action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;liked&quot;</span>          <span class="comment">// 操作类型：liked/unliked</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="获取点赞列表"><a href="#获取点赞列表" class="headerlink" title="获取点赞列表"></a>获取点赞列表</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /api/v1/posts/&#123;post_id&#125;/likes?page=1&amp;size=20</span><br><span class="line">Authorization: Bearer &#123;token&#125;</span><br></pre></td></tr></table></figure>

<p>****查询参数****：</p>
<ul>
<li><code>page</code>: 页码，默认1</li>
<li><code>size</code>: 每页数量，默认20，最大50</li>
</ul>
<p>****响应示例****：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">200</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;获取成功&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;users&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1001</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;nickname&quot;</span><span class="punctuation">:</span> <span class="string">&quot;张三&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;avatar&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://cdn.example.com/avatars/1001.jpg&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;department&quot;</span><span class="punctuation">:</span> <span class="string">&quot;技术部&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;position&quot;</span><span class="punctuation">:</span> <span class="string">&quot;高级工程师&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;liked_at&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2024-12-19T10:30:00Z&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1002</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;nickname&quot;</span><span class="punctuation">:</span> <span class="string">&quot;李四&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;avatar&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://cdn.example.com/avatars/1002.jpg&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;department&quot;</span><span class="punctuation">:</span> <span class="string">&quot;产品部&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;position&quot;</span><span class="punctuation">:</span> <span class="string">&quot;产品经理&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;liked_at&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2024-12-19T09:15:00Z&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;pagination&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;page&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">20</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;total&quot;</span><span class="punctuation">:</span> <span class="number">26</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;has_more&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="批量检查点赞状态"><a href="#批量检查点赞状态" class="headerlink" title="批量检查点赞状态"></a>批量检查点赞状态</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /api/v1/posts/likes/batch-check</span><br><span class="line">Authorization: Bearer &#123;token&#125;</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;post_ids&quot;: [123456, 123457, 123458]  // 内容ID数组，最多100个</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>****响应示例****：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">200</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;获取成功&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;like_status&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;123456&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;123457&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;123458&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="3-4-4-评论相关接口"><a href="#3-4-4-评论相关接口" class="headerlink" title="3.4.4 评论相关接口"></a>3.4.4 评论相关接口</h4><h5 id="发表评论"><a href="#发表评论" class="headerlink" title="发表评论"></a>发表评论</h5><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST /api/v1/posts/<span class="punctuation">&#123;</span>post_id<span class="punctuation">&#125;</span>/comments</span><br><span class="line">Authorization<span class="punctuation">:</span> Bearer <span class="punctuation">&#123;</span>token<span class="punctuation">&#125;</span></span><br><span class="line">Content-Type<span class="punctuation">:</span> application/json</span><br><span class="line"></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="string">&quot;非常赞同你的观点！&quot;</span><span class="punctuation">,</span>        <span class="comment">// 必填，评论内容，1-500字符</span></span><br><span class="line">    <span class="attr">&quot;parent_id&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span>                       <span class="comment">// 可选，父评论ID，0为顶级评论</span></span><br><span class="line">    <span class="attr">&quot;reply_to_user_id&quot;</span><span class="punctuation">:</span> <span class="number">1002</span>             <span class="comment">// 可选，回复的用户ID</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>****响应示例****：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">200</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;评论成功&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">789012</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="string">&quot;非常赞同你的观点！&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;parent_id&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;root_id&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;reply_to_user_id&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;user&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1001</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;nickname&quot;</span><span class="punctuation">:</span> <span class="string">&quot;张三&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;avatar&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://cdn.example.com/avatars/1001.jpg&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;department&quot;</span><span class="punctuation">:</span> <span class="string">&quot;技术部&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;like_count&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;reply_count&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;can_delete&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;created_at&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2024-12-19T11:15:00Z&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="获取评论列表"><a href="#获取评论列表" class="headerlink" title="获取评论列表"></a>获取评论列表</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /api/v1/posts/&#123;post_id&#125;/comments?page=1&amp;size=20&amp;sort=created_at</span><br><span class="line">Authorization: Bearer &#123;token&#125;</span><br></pre></td></tr></table></figure>

<p>****查询参数****：</p>
<ul>
<li><code>page</code>: 页码，默认1</li>
<li><code>size</code>: 每页数量，默认20，最大100</li>
<li><code>sort</code>: 排序方式，可选值：created_at（时间）、like_count（点赞数）</li>
</ul>
<p>****响应示例****：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">200</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;获取成功&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;comments&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">789012</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="string">&quot;非常赞同你的观点！&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;parent_id&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;root_id&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;user&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1001</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;nickname&quot;</span><span class="punctuation">:</span> <span class="string">&quot;张三&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;avatar&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://cdn.example.com/avatars/1001.jpg&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;department&quot;</span><span class="punctuation">:</span> <span class="string">&quot;技术部&quot;</span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;reply_to_user&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;like_count&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;reply_count&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;is_liked&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;can_delete&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;replies&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                    <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">789013</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="string">&quot;我也这么认为&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;parent_id&quot;</span><span class="punctuation">:</span> <span class="number">789012</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;root_id&quot;</span><span class="punctuation">:</span> <span class="number">789012</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;user&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                            <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1002</span><span class="punctuation">,</span></span><br><span class="line">                            <span class="attr">&quot;nickname&quot;</span><span class="punctuation">:</span> <span class="string">&quot;李四&quot;</span><span class="punctuation">,</span></span><br><span class="line">                            <span class="attr">&quot;avatar&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://cdn.example.com/avatars/1002.jpg&quot;</span></span><br><span class="line">                        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;reply_to_user&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                            <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1001</span><span class="punctuation">,</span></span><br><span class="line">                            <span class="attr">&quot;nickname&quot;</span><span class="punctuation">:</span> <span class="string">&quot;张三&quot;</span></span><br><span class="line">                        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;like_count&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;created_at&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2024-12-19T11:20:00Z&quot;</span></span><br><span class="line">                    <span class="punctuation">&#125;</span></span><br><span class="line">                <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;created_at&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2024-12-19T11:15:00Z&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;pagination&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;page&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">20</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;total&quot;</span><span class="punctuation">:</span> <span class="number">8</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;has_more&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="回复评论"><a href="#回复评论" class="headerlink" title="回复评论"></a>回复评论</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /api/v1/comments/&#123;comment_id&#125;/replies</span><br><span class="line">Authorization: Bearer &#123;token&#125;</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;content&quot;: &quot;我也这么认为&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="评论点赞"><a href="#评论点赞" class="headerlink" title="评论点赞"></a>评论点赞</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /api/v1/comments/&#123;comment_id&#125;/like</span><br><span class="line">Authorization: Bearer &#123;token&#125;</span><br></pre></td></tr></table></figure>

<h5 id="删除评论"><a href="#删除评论" class="headerlink" title="删除评论"></a>删除评论</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELETE /api/v1/comments/&#123;comment_id&#125;</span><br><span class="line">Authorization: Bearer &#123;token&#125;</span><br></pre></td></tr></table></figure>

<p>****响应示例****：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;code&quot;: 200,</span><br><span class="line">    &quot;message&quot;: &quot;删除成功&quot;,</span><br><span class="line">    &quot;data&quot;: null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-4-5-文件上传接口"><a href="#3-4-5-文件上传接口" class="headerlink" title="3.4.5 文件上传接口"></a>3.4.5 文件上传接口</h4><h5 id="图片上传"><a href="#图片上传" class="headerlink" title="图片上传"></a>图片上传</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /api/v1/upload/images</span><br><span class="line">Authorization: Bearer &#123;token&#125;</span><br><span class="line">Content-Type: multipart/form-data</span><br><span class="line"></span><br><span class="line">files: [File, File, ...]  // 支持批量上传，最多9张图片</span><br></pre></td></tr></table></figure>

<p>****响应示例****：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;code&quot;: 200,</span><br><span class="line">    &quot;message&quot;: &quot;上传成功&quot;,</span><br><span class="line">    &quot;data&quot;: &#123;</span><br><span class="line">        &quot;urls&quot;: [</span><br><span class="line">            &quot;https://cdn.example.com/images/20241219/001.jpg&quot;,</span><br><span class="line">            &quot;https://cdn.example.com/images/20241219/002.jpg&quot;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="视频上传"><a href="#视频上传" class="headerlink" title="视频上传"></a>视频上传</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /api/v1/upload/video</span><br><span class="line">Authorization: Bearer &#123;token&#125;</span><br><span class="line">Content-Type: multipart/form-data</span><br><span class="line"></span><br><span class="line">file: File  // 单个视频文件，最大100MB</span><br></pre></td></tr></table></figure>

<h4 id="3-4-6-统计接口"><a href="#3-4-6-统计接口" class="headerlink" title="3.4.6 统计接口"></a>3.4.6 统计接口</h4><h5 id="获取企业圈统计数据"><a href="#获取企业圈统计数据" class="headerlink" title="获取企业圈统计数据"></a>获取企业圈统计数据</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /api/v1/statistics/enterprise</span><br><span class="line">Authorization: Bearer &#123;token&#125;</span><br></pre></td></tr></table></figure>

<p>****响应示例****：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;code&quot;: 200,</span><br><span class="line">    &quot;message&quot;: &quot;获取成功&quot;,</span><br><span class="line">    &quot;data&quot;: &#123;</span><br><span class="line">        &quot;total_posts&quot;: 1250,           // 企业总内容数</span><br><span class="line">        &quot;total_users&quot;: 89,             // 企业总用户数</span><br><span class="line">        &quot;today_posts&quot;: 15,             // 今日新增内容</span><br><span class="line">        &quot;today_active_users&quot;: 67,      // 今日活跃用户</span><br><span class="line">        &quot;hot_posts&quot;: [                 // 当前热门内容(前3)</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;id&quot;: 123456,</span><br><span class="line">                &quot;content&quot;: &quot;工作总结摘要...&quot;,</span><br><span class="line">                &quot;like_count&quot;: 35,</span><br><span class="line">                &quot;is_pinned&quot;: true</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="获取个人统计数据"><a href="#获取个人统计数据" class="headerlink" title="获取个人统计数据"></a>获取个人统计数据</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /api/v1/statistics/personal</span><br><span class="line">Authorization: Bearer &#123;token&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-4-7-通用响应格式"><a href="#3-4-7-通用响应格式" class="headerlink" title="3.4.7 通用响应格式"></a>3.4.7 通用响应格式</h4><p>所有API接口均采用统一的响应格式：</p>
<p>****成功响应****：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;code&quot;: 200,</span><br><span class="line">    &quot;message&quot;: &quot;success&quot;,</span><br><span class="line">    &quot;data&quot;: &#123;</span><br><span class="line">        // 具体数据内容</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>****错误响应****：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;code&quot;: 400,  // 错误码</span><br><span class="line">    &quot;message&quot;: &quot;参数错误&quot;,  // 错误信息</span><br><span class="line">    &quot;data&quot;: null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>****常见错误码****：</p>
<ul>
<li>200: 请求成功</li>
<li>400: 请求参数错误</li>
<li>401: 未授权（token无效或过期）</li>
<li>403: 无权限访问（跨企业访问等）</li>
<li>404: 资源不存在</li>
<li>409: 资源冲突（重复点赞等）</li>
<li>422: 业务逻辑错误（超出编辑时限等）</li>
<li>429: 请求频率限制</li>
<li>500: 服务器内部错误</li>
<li>503: 服务暂不可用</li>
</ul>
<p>****错误响应详细示例****：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;code&quot;: 422,</span><br><span class="line">    &quot;message&quot;: &quot;内容发布失败&quot;,</span><br><span class="line">    &quot;data&quot;: null,</span><br><span class="line">    &quot;error_details&quot;: &#123;</span><br><span class="line">        &quot;error_code&quot;: &quot;POST_EDIT_TIMEOUT&quot;,</span><br><span class="line">        &quot;error_msg&quot;: &quot;发布时间超过24小时，无法编辑&quot;,</span><br><span class="line">        &quot;field&quot;: &quot;created_at&quot;,</span><br><span class="line">        &quot;timestamp&quot;: &quot;2024-12-19T10:00:00Z&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-5-部署架构设计"><a href="#3-5-部署架构设计" class="headerlink" title="3.5 部署架构设计"></a>3.5 部署架构设计</h3><h4 id="3-5-1-容器化部署"><a href="#3-5-1-容器化部署" class="headerlink" title="3.5.1 容器化部署"></a>3.5.1 容器化部署</h4><p>****Docker镜像构建****：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Dockerfile</span></span><br><span class="line"><span class="keyword">FROM</span> golang:<span class="number">1.21</span>-alpine AS builder</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . .</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> go mod download</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> CGO_ENABLED=0 GOOS=linux go build -o enterprise-circle ./cmd/server</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> alpine:latest</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apk --no-cache add ca-certificates tzdata</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=builder /app/enterprise-circle .</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=builder /app/configs ./configs</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;./enterprise-circle&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p>****Kubernetes部署配置****：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># deployment.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">enterprise-circle-api</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">enterprise-circle-api</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">enterprise-circle-api</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">api</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">enterprise-circle:v1.1</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8080</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">DB_HOST</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">&quot;mysql-cluster&quot;</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">REDIS_HOST</span>  </span><br><span class="line">          <span class="attr">value:</span> <span class="string">&quot;redis-cluster&quot;</span></span><br><span class="line">        <span class="attr">resources:</span></span><br><span class="line">          <span class="attr">requests:</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">&quot;512Mi&quot;</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">&quot;500m&quot;</span></span><br><span class="line">          <span class="attr">limits:</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">&quot;1Gi&quot;</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">&quot;1000m&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="3-5-2-监控部署"><a href="#3-5-2-监控部署" class="headerlink" title="3.5.2 监控部署"></a>3.5.2 监控部署</h4><p>****Prometheus监控配置****：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># prometheus.yml</span></span><br><span class="line"><span class="attr">global:</span></span><br><span class="line">  <span class="attr">scrape_interval:</span> <span class="string">15s</span></span><br><span class="line"></span><br><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">&#x27;enterprise-circle&#x27;</span></span><br><span class="line">    <span class="attr">static_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">targets:</span> [<span class="string">&#x27;api:8080&#x27;</span>]</span><br><span class="line">    <span class="attr">metrics_path:</span> <span class="string">&#x27;/metrics&#x27;</span></span><br><span class="line">    <span class="attr">scrape_interval:</span> <span class="string">10s</span></span><br></pre></td></tr></table></figure>

<h2 id="四、技术实现要点"><a href="#四、技术实现要点" class="headerlink" title="四、技术实现要点"></a>四、技术实现要点</h2><h3 id="4-1-高并发优化策略"><a href="#4-1-高并发优化策略" class="headerlink" title="4.1 高并发优化策略"></a>4.1 高并发优化策略</h3><h4 id="4-1-1-分层缓存体系"><a href="#4-1-1-分层缓存体系" class="headerlink" title="4.1.1 分层缓存体系"></a>4.1.1 分层缓存体系</h4><p>****L1缓存 - 本地缓存****：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 使用sync.Map实现高性能本地缓存</span><br><span class="line">type LocalCache struct &#123;</span><br><span class="line">    enterpriseCache sync.Map  // 企业信息缓存</span><br><span class="line">    userCache      sync.Map   // 用户基础信息缓存</span><br><span class="line">    configCache    sync.Map   // 配置信息缓存</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 企业信息本地缓存（变化频率低）</span><br><span class="line">func (c *LocalCache) GetEnterprise(enterpriseID int64) *model.Enterprise &#123;</span><br><span class="line">    if val, ok := c.enterpriseCache.Load(enterpriseID); ok &#123;</span><br><span class="line">        return val.(*model.Enterprise)</span><br><span class="line">    &#125;</span><br><span class="line">    return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>****L2缓存 - Redis分布式缓存****：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Redis缓存策略配置</span><br><span class="line">var CacheConfig = map[string]CacheStrategy&#123;</span><br><span class="line">    &quot;user:session&quot;:    &#123;TTL: 7 * 24 * time.Hour, Type: &quot;hash&quot;&#125;,</span><br><span class="line">    &quot;post:detail&quot;:     &#123;TTL: 1 * time.Hour, Type: &quot;string&quot;&#125;,</span><br><span class="line">    &quot;post:like_count&quot;: &#123;TTL: 24 * time.Hour, Type: &quot;string&quot;&#125;,</span><br><span class="line">    &quot;feed:enterprise&quot;: &#123;TTL: 5 * time.Minute, Type: &quot;string&quot;&#125;,</span><br><span class="line">    &quot;hot:posts:24h&quot;:   &#123;TTL: 1 * time.Hour, Type: &quot;zset&quot;&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-1-2-数据库集群架构"><a href="#4-1-2-数据库集群架构" class="headerlink" title="4.1.2 数据库集群架构"></a>4.1.2 数据库集群架构</h4><p>****MySQL读写分离配置****：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 数据库配置</span><br><span class="line">database:</span><br><span class="line">  master:</span><br><span class="line">    host: mysql-master.example.com</span><br><span class="line">    port: 3306</span><br><span class="line">    max_open_conns: 200</span><br><span class="line">    max_idle_conns: 50</span><br><span class="line">  </span><br><span class="line">  slaves:</span><br><span class="line">    - host: mysql-slave1.example.com</span><br><span class="line">      port: 3306</span><br><span class="line">      weight: 1</span><br><span class="line">    - host: mysql-slave2.example.com  </span><br><span class="line">      port: 3306</span><br><span class="line">      weight: 1</span><br><span class="line">  </span><br><span class="line">  sharding:</span><br><span class="line">    strategy: &quot;enterprise_id&quot;</span><br><span class="line">    shard_count: 100</span><br><span class="line">    rule: &quot;enterprise_id % 100&quot;</span><br></pre></td></tr></table></figure>

<p>****分表路由策略****：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type ShardingRouter struct &#123;</span><br><span class="line">    shardCount int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (r *ShardingRouter) GetShard(enterpriseID int64) string &#123;</span><br><span class="line">    shard := enterpriseID % int64(r.shardCount)</span><br><span class="line">    return fmt.Sprintf(&quot;%d&quot;, shard)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (r *ShardingRouter) GetTableName(baseTable string, enterpriseID int64) string &#123;</span><br><span class="line">    shard := r.GetShard(enterpriseID)</span><br><span class="line">    return fmt.Sprintf(&quot;%s_%s&quot;, baseTable, shard)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-1-3-异步处理架构"><a href="#4-1-3-异步处理架构" class="headerlink" title="4.1.3 异步处理架构"></a>4.1.3 异步处理架构</h4><p>****消息队列设计****：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 消息队列主题设计</span><br><span class="line">const (</span><br><span class="line">    TopicFeedUpdate    = &quot;feed.update&quot;     // Feed更新</span><br><span class="line">    TopicLikeEvent     = &quot;like.event&quot;      // 点赞事件</span><br><span class="line">    TopicCommentEvent  = &quot;comment.event&quot;   // 评论事件</span><br><span class="line">    TopicPinnedUpdate  = &quot;pinned.update&quot;   // 置顶更新</span><br><span class="line">    TopicStatistics    = &quot;statistics&quot;      // 统计数据</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 异步消息处理器</span><br><span class="line">type AsyncProcessor struct &#123;</span><br><span class="line">    contentService *ContentService</span><br><span class="line">    likeService    *LikeService</span><br><span class="line">    redisClient    redis.Client</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 处理Feed更新消息</span><br><span class="line">func (p *AsyncProcessor) HandleFeedUpdate(msg *FeedUpdateMessage) error &#123;</span><br><span class="line">    switch msg.Action &#123;</span><br><span class="line">    case &quot;create&quot;:</span><br><span class="line">        return p.contentService.InvalidateFeedCache(msg.EnterpriseID)</span><br><span class="line">    case &quot;delete&quot;:</span><br><span class="line">        return p.contentService.RemoveFromFeedCache(msg.PostID, msg.EnterpriseID)</span><br><span class="line">    case &quot;update&quot;:</span><br><span class="line">        return p.contentService.UpdateFeedCache(msg.PostID, msg.EnterpriseID)</span><br><span class="line">    &#125;</span><br><span class="line">    return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-1-4-连接池优化"><a href="#4-1-4-连接池优化" class="headerlink" title="4.1.4 连接池优化"></a>4.1.4 连接池优化</h4><p>****数据库连接池配置****：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// MySQL连接池优化配置</span><br><span class="line">func NewMySQLConfig() *mysql.Config &#123;</span><br><span class="line">    return &amp;mysql.Config&#123;</span><br><span class="line">        MaxOpenConns:    200,              // 最大连接数</span><br><span class="line">        MaxIdleConns:    50,               // 最大空闲连接数</span><br><span class="line">        ConnMaxLifetime: 60 * time.Minute, // 连接最大生存时间</span><br><span class="line">        ConnMaxIdleTime: 10 * time.Minute, // 连接最大空闲时间</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Redis连接池配置</span><br><span class="line">func NewRedisConfig() *redis.Options &#123;</span><br><span class="line">    return &amp;redis.Options&#123;</span><br><span class="line">        PoolSize:     100,              // 连接池大小</span><br><span class="line">        MinIdleConns: 20,               // 最小空闲连接数</span><br><span class="line">        MaxRetries:   3,                // 最大重试次数</span><br><span class="line">        PoolTimeout:  5 * time.Second,  // 获取连接超时</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-数据一致性保障"><a href="#4-2-数据一致性保障" class="headerlink" title="4.2 数据一致性保障"></a>4.2 数据一致性保障</h3><h4 id="4-2-1-分布式锁实现"><a href="#4-2-1-分布式锁实现" class="headerlink" title="4.2.1 分布式锁实现"></a>4.2.1 分布式锁实现</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type DistributedLock struct &#123;</span><br><span class="line">    redisClient redis.Client</span><br><span class="line">    keyPrefix   string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取分布式锁</span><br><span class="line">func (l *DistributedLock) Acquire(ctx context.Context, key string, expiry time.Duration) (*Lock, error) &#123;</span><br><span class="line">    lockKey := l.keyPrefix + key</span><br><span class="line">    lockValue := uuid.New().String()</span><br><span class="line">    </span><br><span class="line">    // 使用SET NX EX原子操作获取锁</span><br><span class="line">    success := l.redisClient.SetNX(ctx, lockKey, lockValue, expiry).Val()</span><br><span class="line">    if !success &#123;</span><br><span class="line">        return nil, errors.New(&quot;获取锁失败&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return &amp;Lock&#123;</span><br><span class="line">        key:   lockKey,</span><br><span class="line">        value: lockValue,</span><br><span class="line">        redis: l.redisClient,</span><br><span class="line">    &#125;, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 释放锁（使用Lua脚本保证原子性）</span><br><span class="line">func (lock *Lock) Release() error &#123;</span><br><span class="line">    script := `</span><br><span class="line">        if redis.call(&quot;get&quot;, KEYS[1]) == ARGV[1] then</span><br><span class="line">            return redis.call(&quot;del&quot;, KEYS[1])</span><br><span class="line">        else</span><br><span class="line">            return 0</span><br><span class="line">        end</span><br><span class="line">    `</span><br><span class="line">    return lock.redis.Eval(context.Background(), script, []string&#123;lock.key&#125;, lock.value).Err()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-2-最终一致性方案"><a href="#4-2-2-最终一致性方案" class="headerlink" title="4.2.2 最终一致性方案"></a>4.2.2 最终一致性方案</h4><p>****数据同步策略****：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 定期同步Redis计数器到MySQL</span><br><span class="line">func (s *SyncService) SyncLikeCountsToMySQL() &#123;</span><br><span class="line">    // 1. 获取所有待同步的计数器</span><br><span class="line">    pattern := &quot;post:like_count:*&quot;</span><br><span class="line">    keys := s.redisClient.Keys(context.Background(), pattern).Val()</span><br><span class="line">    </span><br><span class="line">    // 2. 批量获取计数值</span><br><span class="line">    pipe := s.redisClient.Pipeline()</span><br><span class="line">    for _, key := range keys &#123;</span><br><span class="line">        pipe.Get(context.Background(), key)</span><br><span class="line">    &#125;</span><br><span class="line">    results, err := pipe.Exec(context.Background())</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 3. 批量更新数据库</span><br><span class="line">    updates := make(map[int64]int64)</span><br><span class="line">    for i, result := range results &#123;</span><br><span class="line">        postID := s.extractPostIDFromKey(keys[i])</span><br><span class="line">        count := result.(*redis.StringCmd).Val()</span><br><span class="line">        if countInt, err := strconv.ParseInt(count, 10, 64); err == nil &#123;</span><br><span class="line">            updates[postID] = countInt</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 4. 事务更新MySQL</span><br><span class="line">    s.postRepo.BatchUpdateLikeCount(context.Background(), updates)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-性能监控与告警"><a href="#4-3-性能监控与告警" class="headerlink" title="4.3 性能监控与告警"></a>4.3 性能监控与告警</h3><h4 id="4-3-1-关键指标监控"><a href="#4-3-1-关键指标监控" class="headerlink" title="4.3.1 关键指标监控"></a>4.3.1 关键指标监控</h4><p>****API性能指标****：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type Metrics struct &#123;</span><br><span class="line">    // API响应时间分布</span><br><span class="line">    APILatency       *prometheus.HistogramVec</span><br><span class="line">    // API请求频率</span><br><span class="line">    APIRequestTotal  *prometheus.CounterVec</span><br><span class="line">    // API错误率</span><br><span class="line">    APIErrorRate     *prometheus.CounterVec</span><br><span class="line">    // 数据库连接池使用率</span><br><span class="line">    DBPoolUsage      prometheus.Gauge</span><br><span class="line">    // Redis连接池使用率</span><br><span class="line">    RedisPoolUsage   prometheus.Gauge</span><br><span class="line">    // 置顶算法执行时间</span><br><span class="line">    PinnedAlgorithmDuration prometheus.Histogram</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 监控中间件</span><br><span class="line">func MetricsMiddleware(metrics *Metrics) gin.HandlerFunc &#123;</span><br><span class="line">    return func(c *gin.Context) &#123;</span><br><span class="line">        start := time.Now()</span><br><span class="line">        path := c.FullPath()</span><br><span class="line">        method := c.Request.Method</span><br><span class="line">        </span><br><span class="line">        c.Next()</span><br><span class="line">        </span><br><span class="line">        duration := time.Since(start)</span><br><span class="line">        status := c.Writer.Status()</span><br><span class="line">        </span><br><span class="line">        // 记录响应时间</span><br><span class="line">        metrics.APILatency.WithLabelValues(method, path).Observe(duration.Seconds())</span><br><span class="line">        </span><br><span class="line">        // 记录请求计数</span><br><span class="line">        metrics.APIRequestTotal.WithLabelValues(method, path, strconv.Itoa(status)).Inc()</span><br><span class="line">        </span><br><span class="line">        // 记录错误率</span><br><span class="line">        if status &gt;= 400 &#123;</span><br><span class="line">            metrics.APIErrorRate.WithLabelValues(method, path).Inc()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-3-2-业务监控指标"><a href="#4-3-2-业务监控指标" class="headerlink" title="4.3.2 业务监控指标"></a>4.3.2 业务监控指标</h4><p>****关键业务指标****：</p>
<ul>
<li>****内容发布量****：每分钟、每小时、每日发布量统计</li>
<li>****用户活跃度****：DAU、MAU统计</li>
<li>****点赞互动率****：平均点赞数、点赞参与度</li>
<li>****置顶命中率****：24小时内达到置顶条件的内容比例</li>
<li>****系统稳定性****：API可用率、平均响应时间</li>
</ul>
<p>****告警规则配置****：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alerts:</span><br><span class="line">  - name: &quot;API响应时间过长&quot;</span><br><span class="line">    condition: &quot;api_latency_p99 &gt; 1000ms&quot;</span><br><span class="line">    severity: &quot;warning&quot;</span><br><span class="line">  </span><br><span class="line">  - name: &quot;数据库连接池使用率过高&quot;</span><br><span class="line">    condition: &quot;db_pool_usage &gt; 0.8&quot;</span><br><span class="line">    severity: &quot;critical&quot;</span><br><span class="line">  </span><br><span class="line">  - name: &quot;Redis连接池使用率过高&quot;</span><br><span class="line">    condition: &quot;redis_pool_usage &gt; 0.9&quot;</span><br><span class="line">    severity: &quot;warning&quot;</span><br><span class="line">  </span><br><span class="line">  - name: &quot;错误率过高&quot;</span><br><span class="line">    condition: &quot;api_error_rate &gt; 0.01&quot;</span><br><span class="line">    severity: &quot;critical&quot;</span><br></pre></td></tr></table></figure>

<h3 id="4-4-安全性设计"><a href="#4-4-安全性设计" class="headerlink" title="4.4 安全性设计"></a>4.4 安全性设计</h3><h4 id="4-4-1-认证安全"><a href="#4-4-1-认证安全" class="headerlink" title="4.4.1 认证安全"></a>4.4.1 认证安全</h4><p>****JWT令牌安全策略****：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type JWTConfig struct &#123;</span><br><span class="line">    SecretKey       string        // 密钥，定期轮换</span><br><span class="line">    AccessTokenTTL  time.Duration // 访问令牌有效期：2小时</span><br><span class="line">    RefreshTokenTTL time.Duration // 刷新令牌有效期：7天</span><br><span class="line">    Issuer          string        // 签发者</span><br><span class="line">    Algorithm       string        // 签名算法：HS256</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 令牌黑名单机制</span><br><span class="line">func (s *AuthService) AddToBlacklist(ctx context.Context, tokenID string) error &#123;</span><br><span class="line">    key := fmt.Sprintf(&quot;blacklist:token:%s&quot;, tokenID)</span><br><span class="line">    return s.redisClient.Set(ctx, key, &quot;1&quot;, 7*24*time.Hour).Err()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-4-2-数据安全"><a href="#4-4-2-数据安全" class="headerlink" title="4.4.2 数据安全"></a>4.4.2 数据安全</h4><p>****敏感数据处理****：</p>
<ul>
<li>密码使用bcrypt加密存储</li>
<li>用户数据按企业ID严格隔离</li>
<li>API接口添加频率限制</li>
<li>关键操作记录审计日志</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 频率限制中间件</span><br><span class="line">func RateLimitMiddleware() gin.HandlerFunc &#123;</span><br><span class="line">    limiter := rate.NewLimiter(rate.Every(time.Second), 100) // 每秒100次</span><br><span class="line">    </span><br><span class="line">    return func(c *gin.Context) &#123;</span><br><span class="line">        if !limiter.Allow() &#123;</span><br><span class="line">            c.JSON(429, gin.H&#123;&quot;error&quot;: &quot;请求频率过高，请稍后重试&quot;&#125;)</span><br><span class="line">            c.Abort()</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        c.Next()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五、附录"><a href="#五、附录" class="headerlink" title="五、附录"></a>五、附录</h2><h3 id="5-1-名词解释"><a href="#5-1-名词解释" class="headerlink" title="5.1 名词解释"></a>5.1 名词解释</h3><table>
<thead>
<tr>
<th><em><strong>*术语*</strong></em></th>
<th><em><strong>*解释*</strong></em></th>
</tr>
</thead>
<tbody><tr>
<td>企业圈</td>
<td>类似微信朋友圈的企业内部社交功能，支持内容发布、点赞、评论等交互</td>
</tr>
<tr>
<td>智能置顶</td>
<td>基于点赞数的自动置顶算法，24小时内点赞数超过10的内容参与排名，前3名自动置顶</td>
</tr>
<tr>
<td>JWT</td>
<td>JSON Web Token，用于分布式系统中的用户身份验证和授权的令牌标准</td>
</tr>
<tr>
<td>QPS</td>
<td>Queries Per Second，系统每秒处理的查询请求数量，衡量系统吞吐能力的关键指标</td>
</tr>
<tr>
<td>分库分表</td>
<td>数据库水平拆分策略，按照特定规则将数据分布到多个数据库或表中</td>
</tr>
<tr>
<td>读写分离</td>
<td>数据库架构模式，写操作在主库执行，读操作在从库执行，提升并发性能</td>
</tr>
<tr>
<td>分布式锁</td>
<td>在分布式环境中实现互斥访问的机制，防止并发操作导致的数据不一致</td>
</tr>
<tr>
<td>Feed流</td>
<td>用户动态流，按时间或算法排序展示的内容列表</td>
</tr>
<tr>
<td>缓存击穿</td>
<td>缓存失效时大量请求同时访问数据库的现象</td>
</tr>
<tr>
<td>缓存雪崩</td>
<td>大量缓存同时失效导致数据库压力激增的现象</td>
</tr>
<tr>
<td>热点数据</td>
<td>访问频率高的数据，需要特殊的缓存和优化策略</td>
</tr>
</tbody></table>
<h3 id="5-2-参考资料"><a href="#5-2-参考资料" class="headerlink" title="5.2 参考资料"></a>5.2 参考资料</h3><p>****技术框架文档****：</p>
<ol>
<li><a href="https://gin-gonic.com/docs/">Gin Web Framework 官方文档</a></li>
<li><a href="https://golang.org/doc/">Go语言官方文档</a></li>
<li><a href="https://dev.mysql.com/doc/refman/8.0/en/">MySQL 8.0 官方参考手册</a></li>
<li><a href="https://redis.io/documentation">Redis 官方文档</a></li>
</ol>
<p>****架构设计参考****：</p>
<ol>
<li><a href="https://microservices.io/patterns/">微服务架构设计模式</a></li>
<li><a href="https://github.com/donnemartin/system-design-primer">高并发系统设计原理</a></li>
<li><a href="https://patterns.arc42.org/">分布式系统设计模式</a></li>
</ol>
<p>****数据库设计参考****：</p>
<ol>
<li><a href="https://dev.mysql.com/doc/mysql-ha-scalability/en/">MySQL 高可用架构设计</a></li>
<li><a href="https://shardingsphere.apache.org/document/current/cn/overview/">数据库分库分表实践</a></li>
<li><a href="https://redis.io/topics/cluster-tutorial">Redis 集群架构指南</a></li>
</ol>
<p>****API设计规范****：</p>
<ol>
<li><a href="https://restfulapi.net/">RESTful API 设计指南</a></li>
<li><a href="https://swagger.io/specification/">OpenAPI 3.0 规范</a></li>
<li><a href="https://httpstatuses.com/">HTTP状态码规范</a></li>
</ol>
<p>****安全设计参考****：</p>
<ol>
<li><a href="https://jwt.io/introduction/">JWT 官方规范文档</a></li>
<li><a href="https://owasp.org/www-project-api-security/">OWASP API安全指南</a></li>
<li><a href="https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html">密码安全最佳实践</a></li>
</ol>
<p>****性能优化参考****：</p>
<ol>
<li><a href="https://github.com/dgryski/go-perfbook">Go语言性能优化实践</a></li>
<li><a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/cache-aside">缓存设计模式</a></li>
<li><a href="https://nginx.org/en/docs/http/load_balancing.html">负载均衡策略</a></li>
</ol>
<hr>
<p>****文档版本****：v1.1</p>
<p>****编写日期****：2024-12-19</p>
<p>****最后更新****：2024-12-19</p>
<p>****文档状态****：待评审</p>
<p>****架构师****：系统架构团队</p>
]]></content>
      <categories>
        <category>后端开发</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>后端开发</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>生成式AI模型实现MNIST数据增强</title>
    <url>/2024/12/06/%E7%94%9F%E6%88%90%E5%BC%8FAI%E6%A8%A1%E5%9E%8B%E5%AE%9E%E7%8E%B0MNIST%E6%95%B0%E6%8D%AE%E5%A2%9E%E5%BC%BA/</url>
    <content><![CDATA[<h1 id="文档说明："><a href="#文档说明：" class="headerlink" title="文档说明："></a>文档说明：</h1><p>​	本文主要是作为我本身的结课的作业的一种提交形式。内容主要包括使用生成式AI模型实现MNIST数据增强。选用cGAN、VAE等生成式AI模型。在深度学习框架PyTorch上基于MNIST训练集优化所选生成式AI模型。基于定量性能指标：[分类准确率]对比无数据增强、有数据增强技术路线性能。并且对所选生成式AI模型分析其数据增强的效果差异并进行对比分析。</p>
<p>​	流程图如：</p>
<p><img data-src="https://raw.githubusercontent.com/jianingdai/Blog_img/main/img202412061423492.png" alt="image-20241206142328369"></p>
<h1 id="VAE数据增强实现部分："><a href="#VAE数据增强实现部分：" class="headerlink" title="VAE数据增强实现部分："></a>VAE数据增强实现部分：</h1><p>​	VAE数据增强部分，我这里是分成了两个脚本文件来进行操作，其中一个文件是<code>train_vae.py</code>，这个文件主要是为了训练vae模型。然后还有一个文件，名字是<code>generate_vae.py</code>，该文件主要是利用训练好的vae模型对MNIST数据集进行数据增强，我这里是将MNIST的训练集中的每个样本图片都进行了重参数化（reparameterize）然后输入到Decoder中生成对应的数据样本，同时也是方便我获取生成样本的标签，这是因为VAE模型的Decoder是从潜在空间中生成的样本，本质上是无标签的，所以我要利用原样本的标签和其在潜在空间中的值，这会帮助我生成增强数据集。</p>
<h2 id="VAE训练代码train-vae-py："><a href="#VAE训练代码train-vae-py：" class="headerlink" title="VAE训练代码train_vae.py："></a>VAE训练代码<code>train_vae.py</code>：</h2><p>以下是我的<code>homeWork/train_vae.py</code>文件的说明：</p>
<p>该脚本在MNIST数据集上训练变分自编码器（VAE）。</p>
<h3 id="依赖项："><a href="#依赖项：" class="headerlink" title="依赖项："></a>依赖项：</h3><ul>
<li><code>torch</code></li>
<li><code>torch.nn</code></li>
<li><code>torch.optim</code></li>
<li><code>torch.utils.data</code></li>
<li><code>torchvision.datasets</code></li>
<li><code>torchvision.transforms</code></li>
</ul>
<h3 id="VAE模型："><a href="#VAE模型：" class="headerlink" title="VAE模型："></a>VAE模型：</h3><p>VAE模型由编码器和解码器组成。编码器将输入数据压缩到潜在空间表示，解码器从该表示中重构数据。</p>
<h4 id="编码器："><a href="#编码器：" class="headerlink" title="编码器："></a>编码器：</h4><ul>
<li><strong>输入</strong>：784维向量（展平的28x28图像）</li>
<li><strong>输出</strong>：两个20维向量（均值和对数方差）</li>
</ul>
<h4 id="解码器："><a href="#解码器：" class="headerlink" title="解码器："></a>解码器：</h4><ul>
<li><strong>输入</strong>：20维潜在向量</li>
<li><strong>输出</strong>：784维向量（重构的图像）</li>
</ul>
<h4 id="重参数化技巧："><a href="#重参数化技巧：" class="headerlink" title="重参数化技巧："></a>重参数化技巧：</h4><p>为了允许通过随机采样过程进行反向传播，使用重参数化技巧：$ z &#x3D; \mu + \epsilon \cdot \sigma\  $其中$\epsilon$是从标准正态分布中采样。</p>
<h3 id="损失函数："><a href="#损失函数：" class="headerlink" title="损失函数："></a>损失函数：</h3><p>VAE的损失函数由重构损失和KL散度组成：</p>
<ul>
<li><strong>重构损失</strong>：衡量重构图像与原始图像的匹配程度。</li>
<li><strong>KL散度</strong>：衡量潜在空间分布与标准正态分布的接近程度。</li>
</ul>
<h3 id="训练："><a href="#训练：" class="headerlink" title="训练："></a>训练：</h3><ol>
<li>加载MNIST数据集。</li>
<li>初始化VAE模型和优化器。</li>
<li>训练模型若干个epoch，更新模型参数以最小化损失函数。</li>
<li>将训练好的模型保存到文件。</li>
</ol>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> datasets, transforms</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义VAE模型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VAE</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, latent_dim=<span class="number">20</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(VAE, <span class="variable language_">self</span>).__init__()</span><br><span class="line">        <span class="variable language_">self</span>.encoder = nn.Sequential(</span><br><span class="line">            nn.Linear(<span class="number">784</span>, <span class="number">512</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.Linear(<span class="number">512</span>, <span class="number">256</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.Linear(<span class="number">256</span>, <span class="number">2</span> * latent_dim)  <span class="comment"># 输出均值和对数方差</span></span><br><span class="line">        )</span><br><span class="line">        <span class="variable language_">self</span>.decoder = nn.Sequential(</span><br><span class="line">            nn.Linear(latent_dim, <span class="number">256</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.Linear(<span class="number">256</span>, <span class="number">512</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.Linear(<span class="number">512</span>, <span class="number">784</span>),</span><br><span class="line">            nn.Sigmoid()  <span class="comment"># 输出值范围在[0, 1]</span></span><br><span class="line">        )</span><br><span class="line">        <span class="variable language_">self</span>.latent_dim = latent_dim</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">encode</span>(<span class="params">self, x</span>):</span><br><span class="line">        h = <span class="variable language_">self</span>.encoder(x)</span><br><span class="line">        mu, log_var = h.chunk(<span class="number">2</span>, dim=-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> mu, log_var</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reparameterize</span>(<span class="params">self, mu, log_var</span>):</span><br><span class="line">        std = torch.exp(<span class="number">0.5</span> * log_var)</span><br><span class="line">        eps = torch.randn_like(std)</span><br><span class="line">        <span class="keyword">return</span> mu + eps * std</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decode</span>(<span class="params">self, z</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.decoder(z)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        mu, log_var = <span class="variable language_">self</span>.encode(x.view(-<span class="number">1</span>, <span class="number">784</span>))</span><br><span class="line">        z = <span class="variable language_">self</span>.reparameterize(mu, log_var)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.decode(z), mu, log_var</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义损失函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">vae_loss</span>(<span class="params">recon_x, x, mu, log_var</span>):</span><br><span class="line">    recon_loss = nn.functional.binary_cross_entropy(recon_x, x.view(-<span class="number">1</span>, <span class="number">784</span>), reduction=<span class="string">&#x27;sum&#x27;</span>)</span><br><span class="line">    kl_divergence = -<span class="number">0.5</span> * torch.<span class="built_in">sum</span>(<span class="number">1</span> + log_var - mu.<span class="built_in">pow</span>(<span class="number">2</span>) - log_var.exp())</span><br><span class="line">    <span class="keyword">return</span> recon_loss + kl_divergence, recon_loss, kl_divergence</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 加载MNIST数据</span></span><br><span class="line">    transform = transforms.ToTensor()</span><br><span class="line">    mnist_train = datasets.MNIST(root=<span class="string">&#x27;./data&#x27;</span>, train=<span class="literal">True</span>, transform=transform, download=<span class="literal">True</span>)</span><br><span class="line">    mnist_loader = DataLoader(mnist_train, batch_size=<span class="number">128</span>, shuffle=<span class="literal">True</span>, num_workers=<span class="number">4</span>, pin_memory=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始化模型与优化器</span></span><br><span class="line">    latent_dim = <span class="number">20</span></span><br><span class="line">    vae = VAE(latent_dim=latent_dim).to(<span class="string">&#x27;cuda&#x27;</span>)</span><br><span class="line">    optimizer = optim.Adam(vae.parameters(), lr=<span class="number">1e-3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        vae.load_state_dict(torch.load(<span class="string">&#x27;vae_gen_mnist.pth&#x27;</span>, weights_only=<span class="literal">True</span>))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Model loaded successfully.&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Model file not found. Initializing model with random weights.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 训练VAE模型</span></span><br><span class="line">    epochs = <span class="number">150</span></span><br><span class="line">    vae.train()</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(epochs):</span><br><span class="line">        train_loss = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x, _ <span class="keyword">in</span> mnist_loader:</span><br><span class="line">            x = x.to(<span class="string">&#x27;cuda&#x27;</span>)</span><br><span class="line">            optimizer.zero_grad()</span><br><span class="line">            recon_x, mu, log_var = vae(x)</span><br><span class="line">            loss, recon_loss, kl_divergence = vae_loss(recon_x, x, mu, log_var)</span><br><span class="line">            loss.backward()</span><br><span class="line">            train_loss += loss.item()</span><br><span class="line">            optimizer.step()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Epoch <span class="subst">&#123;epoch + <span class="number">1</span>&#125;</span>, Total Loss: <span class="subst">&#123;train_loss / <span class="built_in">len</span>(mnist_loader.dataset):<span class="number">.4</span>f&#125;</span>, &quot;</span></span><br><span class="line">              <span class="string">f&quot;Reconstruction Loss: <span class="subst">&#123;recon_loss.item() / <span class="built_in">len</span>(mnist_loader.dataset):<span class="number">.4</span>f&#125;</span>, &quot;</span></span><br><span class="line">              <span class="string">f&quot;KL Divergence: <span class="subst">&#123;kl_divergence.item() / <span class="built_in">len</span>(mnist_loader.dataset):<span class="number">.4</span>f&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保存训练好的模型</span></span><br><span class="line">    torch.save(vae.state_dict(), <span class="string">&#x27;vae_gen_mnist.pth&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="VAE生成代码generate-vae-py"><a href="#VAE生成代码generate-vae-py" class="headerlink" title="VAE生成代码generate_vae.py:"></a>VAE生成代码<code>generate_vae.py</code>:</h2><p>该脚本使用预训练的变分自编码器（VAE）生成MNIST数据集的样本，并将生成的样本保存为<code>.ubyte</code>文件格式。</p>
<h3 id="依赖项：-1"><a href="#依赖项：-1" class="headerlink" title="依赖项："></a>依赖项：</h3><ul>
<li><code>torch</code></li>
<li><code>torch.nn</code></li>
<li><code>numpy</code></li>
<li><code>matplotlib.pyplot</code></li>
<li><code>torch.utils.data</code></li>
<li><code>torchvision.datasets</code></li>
<li><code>torchvision.transforms</code></li>
<li><code>torchvision.utils</code></li>
<li><code>struct</code></li>
</ul>
<h3 id="VAE模型：-1"><a href="#VAE模型：-1" class="headerlink" title="VAE模型："></a>VAE模型：</h3><p>VAE模型由编码器和解码器组成。编码器将输入数据压缩到潜在空间表示，解码器从该表示中重构数据。</p>
<h4 id="编码器：-1"><a href="#编码器：-1" class="headerlink" title="编码器："></a>编码器：</h4><ul>
<li><strong>输入</strong>：784维向量（展平的28x28图像）</li>
<li><strong>输出</strong>：两个20维向量（均值和对数方差）</li>
</ul>
<h4 id="解码器：-1"><a href="#解码器：-1" class="headerlink" title="解码器："></a>解码器：</h4><ul>
<li><strong>输入</strong>：20维潜在向量</li>
<li><strong>输出</strong>：784维向量（重构的图像）</li>
</ul>
<h4 id="重参数化技巧：-1"><a href="#重参数化技巧：-1" class="headerlink" title="重参数化技巧："></a>重参数化技巧：</h4><p>为了允许通过随机采样过程进行反向传播，使用重参数化技巧：$z &#x3D; \mu + \epsilon \cdot \sigma$ 其中$\epsilon$是从标准正态分布中采样。</p>
<h3 id="保存增强数据集方法："><a href="#保存增强数据集方法：" class="headerlink" title="保存增强数据集方法："></a>保存增强数据集方法：</h3><p><code>save_dataset(images_filepath, labels_filepath, dataset)</code>函数将生成的图像和标签保存为<code>.ubyte</code>文件格式。</p>
<ul>
<li><strong>参数</strong>：<ul>
<li><code>images_filepath</code>：图像文件路径</li>
<li><code>labels_filepath</code>：标签文件路径</li>
<li><code>dataset</code>：包含图像和标签的列表</li>
</ul>
</li>
</ul>
<h3 id="主要步骤："><a href="#主要步骤：" class="headerlink" title="主要步骤："></a>主要步骤：</h3><ol>
<li>定义VAE模型。</li>
<li>尝试加载预训练（如果有）的VAE模型权重。</li>
<li>加载MNIST数据集。</li>
<li>使用VAE生成样本。</li>
<li>将生成的样本保存为<code>VAE-Generated-images-idx3-ubyte</code>文件和<code>VAE-Generated-labels-idx1-ubyte</code>。</li>
</ol>
<h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> datasets, transforms</span><br><span class="line"><span class="keyword">from</span> torchvision.utils <span class="keyword">import</span> make_grid</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line"><span class="comment"># ======================== 定义VAE模型 ========================</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VAE</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, latent_dim=<span class="number">20</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(VAE, <span class="variable language_">self</span>).__init__()</span><br><span class="line">        <span class="variable language_">self</span>.encoder = nn.Sequential(</span><br><span class="line">            nn.Linear(<span class="number">784</span>, <span class="number">512</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.Linear(<span class="number">512</span>, <span class="number">256</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.Linear(<span class="number">256</span>, <span class="number">2</span> * latent_dim)  <span class="comment"># 输出均值和对数方差</span></span><br><span class="line">        )</span><br><span class="line">        <span class="variable language_">self</span>.decoder = nn.Sequential(</span><br><span class="line">            nn.Linear(latent_dim, <span class="number">256</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.Linear(<span class="number">256</span>, <span class="number">512</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.Linear(<span class="number">512</span>, <span class="number">784</span>),</span><br><span class="line">            nn.Sigmoid()  <span class="comment"># 输出值范围在[0, 1]</span></span><br><span class="line">        )</span><br><span class="line">        <span class="variable language_">self</span>.latent_dim = latent_dim</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">encode</span>(<span class="params">self, x</span>):</span><br><span class="line">        h = <span class="variable language_">self</span>.encoder(x)</span><br><span class="line">        mu, log_var = h.chunk(<span class="number">2</span>, dim=-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> mu, log_var</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reparameterize</span>(<span class="params">self, mu, log_var</span>):</span><br><span class="line">        std = torch.exp(<span class="number">0.5</span> * log_var)</span><br><span class="line">        eps = torch.randn_like(std)</span><br><span class="line">        <span class="keyword">return</span> mu + eps * std</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decode</span>(<span class="params">self, z</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.decoder(z)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        mu, log_var = <span class="variable language_">self</span>.encode(x.view(-<span class="number">1</span>, <span class="number">784</span>))</span><br><span class="line">        z = <span class="variable language_">self</span>.reparameterize(mu, log_var)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.decode(z), mu, log_var</span><br><span class="line"></span><br><span class="line"><span class="comment"># ======================== 保存增强数据集方法 ========================</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">save_dataset</span>(<span class="params">images_filepath, labels_filepath, dataset</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;保存合并后的数据集到 .ubyte 文件&quot;&quot;&quot;</span></span><br><span class="line">    images = []</span><br><span class="line">    labels = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> image, label <span class="keyword">in</span> dataset:</span><br><span class="line">        images.append(image.numpy())</span><br><span class="line">        labels.append(label)</span><br><span class="line"></span><br><span class="line">    images = np.stack(images).astype(np.uint8)  <span class="comment"># 转为 [N, 28, 28] 的 uint8 数组</span></span><br><span class="line">    labels = np.array(labels, dtype=np.uint8)  <span class="comment"># 转为 uint8 的标签</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Labels before saving: <span class="subst">&#123;labels.shape&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Unique labels before saving: <span class="subst">&#123;np.unique(labels)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 写入图像文件</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(images_filepath, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(struct.pack(<span class="string">&#x27;&gt;IIII&#x27;</span>, <span class="number">2051</span>, <span class="built_in">len</span>(images), <span class="number">28</span>, <span class="number">28</span>))  <span class="comment"># Magic number 2051 for images</span></span><br><span class="line">        f.write(images.tobytes())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 写入标签文件</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(labels_filepath, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(struct.pack(<span class="string">&#x27;&gt;II&#x27;</span>, <span class="number">2049</span>, <span class="built_in">len</span>(labels)))  <span class="comment"># Magic number 2049 for labels</span></span><br><span class="line">        f.write(labels.tobytes())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 加载训练好的模型</span></span><br><span class="line">    latent_dim = <span class="number">20</span></span><br><span class="line">    vae = VAE(latent_dim=latent_dim).to(<span class="string">&#x27;cuda&#x27;</span>)</span><br><span class="line">    vae.load_state_dict(torch.load(<span class="string">&#x27;vae_gen_mnist.pth&#x27;</span>, weights_only=<span class="literal">True</span>))</span><br><span class="line">    vae.<span class="built_in">eval</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 加载MNIST数据集</span></span><br><span class="line">    transform = transforms.ToTensor()</span><br><span class="line">    mnist_train = datasets.MNIST(root=<span class="string">&#x27;./data&#x27;</span>, train=<span class="literal">True</span>, transform=transform, download=<span class="literal">True</span>)</span><br><span class="line">    mnist_loader = DataLoader(mnist_train, batch_size=<span class="number">128</span>, shuffle=<span class="literal">True</span>, num_workers=<span class="number">4</span>, pin_memory=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ======================== 使用VAE生成样本 ========================</span></span><br><span class="line">    generated_samples = []</span><br><span class="line">    generated_labels = []</span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        <span class="keyword">for</span> x, y <span class="keyword">in</span> mnist_loader:</span><br><span class="line">            x = x.to(<span class="string">&#x27;cuda&#x27;</span>)</span><br><span class="line">            mu, log_var = vae.encode(x.view(-<span class="number">1</span>, <span class="number">784</span>))</span><br><span class="line">            z = vae.reparameterize(mu, log_var)</span><br><span class="line">            generated_images = vae.decode(z).cpu().view(-<span class="number">1</span>, <span class="number">28</span>, <span class="number">28</span>).numpy()  <span class="comment"># 转为 28x28 的 NumPy 数组</span></span><br><span class="line">            generated_samples.extend(generated_images)</span><br><span class="line">            generated_labels.extend(y.numpy())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将列表转换为单一 numpy 数组</span></span><br><span class="line">    generated_samples = np.array(generated_samples)  <span class="comment"># 转为 (N, 28, 28) 的 numpy 数组</span></span><br><span class="line">    generated_labels = np.array(generated_labels, dtype=np.uint8)  <span class="comment"># 转为 uint8 的标签数组</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 确保生成的样本数据在 [0, 255] 范围内</span></span><br><span class="line">    generated_samples = (generated_samples * <span class="number">255</span>).astype(np.uint8)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保存生成的样本到 .ubyte 文件</span></span><br><span class="line">    generated_images_path = <span class="string">&#x27;./enhanced_mnist/VAE-Generated-images-idx3-ubyte&#x27;</span></span><br><span class="line">    generated_labels_path = <span class="string">&#x27;./enhanced_mnist/VAE-Generated-labels-idx1-ubyte&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将生成的样本和标签打包成数据集</span></span><br><span class="line">    generated_dataset = [(torch.tensor(image, dtype=torch.uint8), label) <span class="keyword">for</span> image, label <span class="keyword">in</span> <span class="built_in">zip</span>(generated_samples, generated_labels)]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用 save_dataset 函数保存生成的数据集</span></span><br><span class="line">    save_dataset(generated_images_path, generated_labels_path, generated_dataset)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;生成的数据集已保存到文件：&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot; - 图像文件: <span class="subst">&#123;generated_images_path&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot; - 标签文件: <span class="subst">&#123;generated_labels_path&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="CGAN数据增强实现部分："><a href="#CGAN数据增强实现部分：" class="headerlink" title="CGAN数据增强实现部分："></a>CGAN数据增强实现部分：</h1><h2 id="CGAN训练代码train-gan-py"><a href="#CGAN训练代码train-gan-py" class="headerlink" title="CGAN训练代码train_gan.py:"></a>CGAN训练代码<code>train_gan.py</code>:</h2><h3 id="依赖项：-2"><a href="#依赖项：-2" class="headerlink" title="依赖项："></a>依赖项：</h3><p><code>torch</code><br><code>torchvision</code></p>
<h3 id="CGAN模型："><a href="#CGAN模型：" class="headerlink" title="CGAN模型："></a>CGAN模型：</h3><h4 id="生成器设计（Generator）"><a href="#生成器设计（Generator）" class="headerlink" title="生成器设计（Generator）:"></a>生成器设计（Generator）:</h4><p>​	生成器模型用于生成与真实图像相似的图像。其结构如下：  </p>
<h5 id="嵌入层："><a href="#嵌入层：" class="headerlink" title="嵌入层："></a>嵌入层：</h5><ul>
<li>label_emb：将类别标签嵌入到与噪声向量相同的维度中。</li>
<li>参数：num_classes（类别数），num_classes（嵌入向量维度）。</li>
</ul>
<h5 id="全连接层："><a href="#全连接层：" class="headerlink" title="全连接层："></a>全连接层：</h5><ul>
<li>fc：将噪声向量和嵌入标签连接起来，并通过全连接层进行处理。</li>
<li>全连接层参数：输入维度 input_size + num_classes，输出维度 num_feature。</li>
</ul>
<h5 id="卷积层："><a href="#卷积层：" class="headerlink" title="卷积层："></a>卷积层：</h5><ul>
<li>conv1_g：包含卷积层、批归一化层和ReLU激活函数。</li>
<li>卷积层参数：输入通道数 1，输出通道数 50，卷积核大小 3，填充 1。</li>
<li>conv2_g：包含卷积层、批归一化层和ReLU激活函数。</li>
<li>卷积层参数：输入通道数 50，输出通道数 25，卷积核大小 3，填充 1。</li>
<li>conv3_g：包含卷积层和Tanh激活函数。</li>
<li>卷积层参数：输入通道数 25，输出通道数 1，卷积核大小 2，步幅 2。</li>
</ul>
<h4 id="判别器设计（Discriminator）："><a href="#判别器设计（Discriminator）：" class="headerlink" title="判别器设计（Discriminator）："></a>判别器设计（Discriminator）：</h4><p>​	判别器模型用于区分真实图像和生成图像。其结构如下：  </p>
<h5 id="嵌入层：-1"><a href="#嵌入层：-1" class="headerlink" title="嵌入层："></a>嵌入层：</h5><ul>
<li>label_emb：将类别标签嵌入到与图像大小相同的向量中。</li>
<li>参数：num_classes（类别数），28 * 28（嵌入向量维度）。</li>
</ul>
<h5 id="卷积层：-1"><a href="#卷积层：-1" class="headerlink" title="卷积层："></a>卷积层：</h5><ul>
<li>conv1：包含卷积层、LeakyReLU激活函数和最大池化层。</li>
<li>卷积层参数：输入通道数 2，输出通道数 32，卷积核大小 5，填充 2。</li>
<li>conv2：包含卷积层、LeakyReLU激活函数和最大池化层。</li>
<li>卷积层参数：输入通道数 32，输出通道数 64，卷积核大小 5，填充 2。</li>
</ul>
<h5 id="全连接层：-1"><a href="#全连接层：-1" class="headerlink" title="全连接层："></a>全连接层：</h5><ul>
<li>fc：包含全连接层、LeakyReLU激活函数和Sigmoid激活函数。</li>
<li>全连接层参数：输入维度 64 * 7 * 7，输出维度 1024 和 1。</li>
</ul>
<h3 id="损失函数：-1"><a href="#损失函数：-1" class="headerlink" title="损失函数："></a>损失函数：</h3><p>GAN模型的损失函数是二元交叉熵损失函数（Binary Cross-Entropy Loss），定义如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">criterion = nn.BCELoss()</span><br></pre></td></tr></table></figure>

<p>在训练过程中，判别器和生成器的损失分别计算如下：</p>
<ul>
<li><p>判别器损失（<code>d_loss</code>）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d_loss_real = criterion(real_out, real_label)</span><br><span class="line">d_loss_fake = criterion(fake_out, fake_label)</span><br><span class="line">d_loss = d_loss_real + d_loss_fake</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成器损失（<code>g_loss</code>）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">g_loss = criterion(output, real_label)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="训练：-1"><a href="#训练：-1" class="headerlink" title="训练："></a>训练：</h3><ol>
<li>加载MNIST数据集。</li>
<li>初始化GAN模型和优化器。</li>
<li>训练模型若干个epoch，更新模型参数以最小化损失函数。</li>
<li>将训练好的模型保存到文件。</li>
</ol>
<h3 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> datasets, transforms</span><br><span class="line"><span class="keyword">from</span> torch.autograd <span class="keyword">import</span> Variable</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># # ======================== 创建保存图像的文件夹 ========================</span></span><br><span class="line"><span class="comment"># if not os.path.exists(&#x27;./GAN&#x27;):</span></span><br><span class="line"><span class="comment">#     os.mkdir(&#x27;./GAN&#x27;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ======================== 定义图像转换函数 ========================</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">to_img</span>(<span class="params">x</span>):</span><br><span class="line">    out = <span class="number">0.5</span> * (x + <span class="number">1</span>)</span><br><span class="line">    out = out.clamp(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">    out = out.view(-<span class="number">1</span>, <span class="number">1</span>, <span class="number">28</span>, <span class="number">28</span>)</span><br><span class="line">    <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ======================== 设置超参数 ========================</span></span><br><span class="line">batch_size = <span class="number">128</span> <span class="comment"># 批处理大小</span></span><br><span class="line">num_epoch = <span class="number">150</span>  <span class="comment"># 训练epoch</span></span><br><span class="line">z_dimension = <span class="number">100</span>  <span class="comment"># 噪声维度</span></span><br><span class="line">num_classes = <span class="number">10</span>  <span class="comment"># 类别数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ======================== 图像处理 ========================</span></span><br><span class="line">transform = transforms.Compose([</span><br><span class="line">    transforms.ToTensor(),</span><br><span class="line">    transforms.Normalize(mean=[<span class="number">0.5</span>], std=[<span class="number">0.5</span>])</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment"># ======================== 加载MNIST数据集 ========================</span></span><br><span class="line">mnist = datasets.MNIST(</span><br><span class="line">    root=<span class="string">&#x27;./data&#x27;</span>, train=<span class="literal">True</span>, transform=transform, download=<span class="literal">True</span>)</span><br><span class="line">dataloader = torch.utils.data.DataLoader(</span><br><span class="line">    dataset=mnist, batch_size=batch_size, shuffle=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ======================== 定义判别器模型 ========================</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Discriminator</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, num_classes</span>):</span><br><span class="line">        <span class="built_in">super</span>(Discriminator, <span class="variable language_">self</span>).__init__()</span><br><span class="line">        <span class="variable language_">self</span>.label_emb = nn.Embedding(num_classes, <span class="number">28</span> * <span class="number">28</span>)</span><br><span class="line">        <span class="variable language_">self</span>.conv1 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">2</span>, <span class="number">32</span>, <span class="number">5</span>, padding=<span class="number">2</span>),  <span class="comment"># batch, 32, 28, 28</span></span><br><span class="line">            nn.LeakyReLU(<span class="number">0.2</span>),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>, stride=<span class="number">2</span>)  <span class="comment"># batch, 32, 14, 14</span></span><br><span class="line">        )</span><br><span class="line">        <span class="variable language_">self</span>.conv2 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">32</span>, <span class="number">64</span>, <span class="number">5</span>, padding=<span class="number">2</span>),  <span class="comment"># batch, 64, 14, 14</span></span><br><span class="line">            nn.LeakyReLU(<span class="number">0.2</span>),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>, stride=<span class="number">2</span>)  <span class="comment"># batch, 64, 7, 7</span></span><br><span class="line">        )</span><br><span class="line">        <span class="variable language_">self</span>.fc = nn.Sequential(</span><br><span class="line">            nn.Linear(<span class="number">64</span> * <span class="number">7</span> * <span class="number">7</span>, <span class="number">1024</span>),</span><br><span class="line">            nn.LeakyReLU(<span class="number">0.2</span>),</span><br><span class="line">            nn.Linear(<span class="number">1024</span>, <span class="number">1</span>),</span><br><span class="line">            nn.Sigmoid()</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, img, labels</span>):</span><br><span class="line">        label_embedding = <span class="variable language_">self</span>.label_emb(labels).view(labels.size(<span class="number">0</span>), <span class="number">1</span>, <span class="number">28</span>, <span class="number">28</span>)</span><br><span class="line">        x = torch.cat((img, label_embedding), <span class="number">1</span>)</span><br><span class="line">        x = <span class="variable language_">self</span>.conv1(x)</span><br><span class="line">        x = <span class="variable language_">self</span>.conv2(x)</span><br><span class="line">        x = x.view(x.size(<span class="number">0</span>), -<span class="number">1</span>)</span><br><span class="line">        x = <span class="variable language_">self</span>.fc(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ======================== 定义生成器模型 ========================</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Generator</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, input_size, num_feature, num_classes</span>):</span><br><span class="line">        <span class="built_in">super</span>(Generator, <span class="variable language_">self</span>).__init__()</span><br><span class="line">        <span class="variable language_">self</span>.label_emb = nn.Embedding(num_classes, num_classes)</span><br><span class="line">        <span class="variable language_">self</span>.fc = nn.Linear(input_size + num_classes, num_feature)  <span class="comment"># batch, 3136=1x56x56</span></span><br><span class="line">        <span class="variable language_">self</span>.br = nn.Sequential(</span><br><span class="line">            nn.BatchNorm2d(<span class="number">1</span>),</span><br><span class="line">            nn.ReLU(<span class="literal">True</span>)</span><br><span class="line">        )</span><br><span class="line">        <span class="variable language_">self</span>.conv1_g = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">1</span>, <span class="number">50</span>, <span class="number">3</span>, stride=<span class="number">1</span>, padding=<span class="number">1</span>),  <span class="comment"># batch, 50, 56, 56</span></span><br><span class="line">            nn.BatchNorm2d(<span class="number">50</span>),</span><br><span class="line">            nn.ReLU(<span class="literal">True</span>)</span><br><span class="line">        )</span><br><span class="line">        <span class="variable language_">self</span>.conv2_g = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">50</span>, <span class="number">25</span>, <span class="number">3</span>, stride=<span class="number">1</span>, padding=<span class="number">1</span>),  <span class="comment"># batch, 25, 56, 56</span></span><br><span class="line">            nn.BatchNorm2d(<span class="number">25</span>),</span><br><span class="line">            nn.ReLU(<span class="literal">True</span>)</span><br><span class="line">        )</span><br><span class="line">        <span class="variable language_">self</span>.conv3_g = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">25</span>, <span class="number">1</span>, <span class="number">2</span>, stride=<span class="number">2</span>),  <span class="comment"># batch, 1, 28, 28</span></span><br><span class="line">            nn.Tanh()</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, noise, labels</span>):</span><br><span class="line">        label_embedding = <span class="variable language_">self</span>.label_emb(labels)</span><br><span class="line">        x = torch.cat((noise, label_embedding), -<span class="number">1</span>)</span><br><span class="line">        x = <span class="variable language_">self</span>.fc(x)</span><br><span class="line">        x = x.view(x.size(<span class="number">0</span>), <span class="number">1</span>, <span class="number">56</span>, <span class="number">56</span>)</span><br><span class="line">        x = <span class="variable language_">self</span>.br(x)</span><br><span class="line">        x = <span class="variable language_">self</span>.conv1_g(x)</span><br><span class="line">        x = <span class="variable language_">self</span>.conv2_g(x)</span><br><span class="line">        x = <span class="variable language_">self</span>.conv3_g(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># ======================== 初始化模型 ========================</span></span><br><span class="line">    discriminator = Discriminator(num_classes)</span><br><span class="line">    generator = Generator(z_dimension, <span class="number">3136</span>,num_classes)</span><br><span class="line">    <span class="keyword">if</span> torch.cuda.is_available():</span><br><span class="line">        discriminator = discriminator.cuda()</span><br><span class="line">        generator = generator.cuda()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ======================== 定义损失函数和优化器 ========================</span></span><br><span class="line">    <span class="comment"># 使用二元交叉熵损失函数</span></span><br><span class="line">    criterion = nn.BCELoss()</span><br><span class="line">    d_optimizer = torch.optim.Adam(discriminator.parameters(), lr=<span class="number">0.0001</span>)</span><br><span class="line">    g_optimizer = torch.optim.Adam(generator.parameters(), lr=<span class="number">0.0001</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        generator.load_state_dict(torch.load(<span class="string">&#x27;./GAN_generator.pth&#x27;</span>, weights_only=<span class="literal">True</span>))</span><br><span class="line">        discriminator.load_state_dict(torch.load(<span class="string">&#x27;./GAN_discriminator.pth&#x27;</span>, weights_only=<span class="literal">True</span>))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\n--------Model restored--------\n&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\n--------Model not restored: File not found--------\n&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;\n--------Model not restored: <span class="subst">&#123;e&#125;</span>--------\n&quot;</span>)</span><br><span class="line">    <span class="comment"># ======================== 训练模型 ========================</span></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epoch):</span><br><span class="line">        <span class="keyword">for</span> i, (img, labels) <span class="keyword">in</span> <span class="built_in">enumerate</span>(dataloader):</span><br><span class="line">            num_img = img.size(<span class="number">0</span>)</span><br><span class="line">            real_img = Variable(img).cuda()</span><br><span class="line">            real_label = Variable(torch.ones(num_img)).cuda().unsqueeze(<span class="number">1</span>)</span><br><span class="line">            fake_label = Variable(torch.zeros(num_img)).cuda().unsqueeze(<span class="number">1</span>)</span><br><span class="line">            labels = Variable(labels).cuda()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Train Discriminator</span></span><br><span class="line">            real_out = discriminator(real_img, labels)</span><br><span class="line">            d_loss_real = criterion(real_out, real_label)</span><br><span class="line">            real_scores = real_out  <span class="comment"># Closer to 1 means better</span></span><br><span class="line"></span><br><span class="line">            z = Variable(torch.randn(num_img, z_dimension)).cuda()</span><br><span class="line">            fake_img = generator(z, labels)</span><br><span class="line">            fake_out = discriminator(fake_img, labels)</span><br><span class="line">            d_loss_fake = criterion(fake_out, fake_label)</span><br><span class="line">            fake_scores = fake_out  <span class="comment"># Closer to 0 means better</span></span><br><span class="line"></span><br><span class="line">            d_loss = d_loss_real + d_loss_fake</span><br><span class="line">            d_optimizer.zero_grad()</span><br><span class="line">            d_loss.backward()</span><br><span class="line">            d_optimizer.step()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Train Generator</span></span><br><span class="line">            z = Variable(torch.randn(num_img, z_dimension)).cuda()</span><br><span class="line">            fake_img = generator(z, labels)</span><br><span class="line">            output = discriminator(fake_img, labels)</span><br><span class="line">            g_loss = criterion(output, real_label)</span><br><span class="line"></span><br><span class="line">            g_optimizer.zero_grad()</span><br><span class="line">            g_loss.backward()</span><br><span class="line">            g_optimizer.step()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">1</span>) % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;Epoch [&#123;&#125;/&#123;&#125;], d_loss: &#123;:.6f&#125;, g_loss: &#123;:.6f&#125; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;D real: &#123;:.6f&#125;, D fake: &#123;:.6f&#125;&#x27;</span>.<span class="built_in">format</span>(</span><br><span class="line">                    epoch, num_epoch, d_loss.item(), g_loss.item(),</span><br><span class="line">                    real_scores.data.mean(), fake_scores.data.mean()))</span><br><span class="line">    <span class="comment"># ======================== 保存模型 ========================</span></span><br><span class="line">    torch.save(generator.state_dict(), <span class="string">&#x27;./GAN_generator.pth&#x27;</span>)</span><br><span class="line">    torch.save(discriminator.state_dict(), <span class="string">&#x27;./GAN_discriminator.pth&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="CGAN生成代码generator-GAN-py："><a href="#CGAN生成代码generator-GAN-py：" class="headerlink" title="CGAN生成代码generator_GAN.py："></a>CGAN生成代码generator_GAN.py：</h2><h3 id="依赖项"><a href="#依赖项" class="headerlink" title="依赖项"></a>依赖项</h3><p>该项目需要以下依赖项：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">torch</span><br><span class="line">torchvision</span><br><span class="line">numpy</span><br></pre></td></tr></table></figure>

<h3 id="CGAN模型"><a href="#CGAN模型" class="headerlink" title="CGAN模型"></a>CGAN模型</h3><p>​	条件生成对抗网络 (CGAN) 是一种在训练过程中也利用标签的 GAN。生成器 - 给定标签和随机数组作为输入，该网络生成与对应相同标签的训练数据观察具有相同结构的数据。生成器用于生成与真实图像相似的图像，判别器用于区分真实图像和生成图像。在本文件中因为已经默认使用了MNIST数据集对模型进行过了训练，所以本文件中就没有用到辨别器（Discriminator），只用到了生成器。</p>
<p>生成器模型的结构如下：</p>
<ol>
<li><p><strong>嵌入层</strong>：</p>
<ul>
<li><code>label_emb</code>：将类别标签嵌入到与噪声向量相同的维度中。</li>
<li>参数：<code>num_classes</code>（类别数），<code>num_classes</code>（嵌入向量维度）。</li>
</ul>
</li>
<li><p><strong>全连接层</strong>：</p>
<ul>
<li><code>fc</code>：将噪声向量和嵌入标签连接起来，并通过全连接层进行处理。</li>
<li>参数：输入维度 <code>input_size + num_classes</code>，输出维度 <code>num_feature</code>。</li>
</ul>
</li>
<li><p><strong>卷积层</strong>：</p>
<ul>
<li><code>conv1_g</code>：包含卷积层、批归一化层和ReLU激活函数。<ul>
<li>参数：输入通道数 <code>1</code>，输出通道数 <code>50</code>，卷积核大小 <code>3</code>，填充 <code>1</code>。</li>
</ul>
</li>
<li><code>conv2_g</code>：包含卷积层、批归一化层和ReLU激活函数。<ul>
<li>参数：输入通道数 <code>50</code>，输出通道数 <code>25</code>，卷积核大小 <code>3</code>，填充 <code>1</code>。</li>
</ul>
</li>
<li><code>conv3_g</code>：包含卷积层和Tanh激活函数。<ul>
<li>参数：输入通道数 <code>25</code>，输出通道数 <code>1</code>，卷积核大小 <code>2</code>，步幅 <code>2</code>。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="保存数据集的方法"><a href="#保存数据集的方法" class="headerlink" title="保存数据集的方法"></a>保存数据集的方法</h3><p>该项目提供了一个方法来保存生成的数据集到 <code>.ubyte</code> 文件中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">save_dataset</span>(<span class="params">images_filepath, labels_filepath, images, labels</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(images_filepath, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(struct.pack(<span class="string">&#x27;&gt;IIII&#x27;</span>, <span class="number">2051</span>, <span class="built_in">len</span>(images), <span class="number">28</span>, <span class="number">28</span>))  <span class="comment"># Magic number 2051 for images</span></span><br><span class="line">        f.write(images.tobytes())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(labels_filepath, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(struct.pack(<span class="string">&#x27;&gt;II&#x27;</span>, <span class="number">2049</span>, <span class="built_in">len</span>(labels)))  <span class="comment"># Magic number 2049 for labels</span></span><br><span class="line">        f.write(labels.tobytes())</span><br></pre></td></tr></table></figure>

<h3 id="主要步骤"><a href="#主要步骤" class="headerlink" title="主要步骤"></a>主要步骤</h3><ol>
<li><p><strong>导入必要的库</strong>：</p>
<ul>
<li>导入 <code>torch</code>、<code>torch.nn</code>、<code>numpy</code> 等库。</li>
</ul>
</li>
<li><p><strong>定义生成器模型</strong>：</p>
<ul>
<li><code>Generator</code> 类包含嵌入层、全连接层和卷积层，用于生成图像。</li>
</ul>
</li>
<li><p><strong>设置超参数</strong>：</p>
<ul>
<li>定义噪声维度、类别数、生成样本数量和输出目录。</li>
</ul>
</li>
<li><p><strong>加载生成器模型</strong>：</p>
<ul>
<li>初始化生成器模型，并加载预训练的模型权重。</li>
</ul>
</li>
<li><p><strong>生成数据集</strong>：</p>
<ul>
<li>使用生成器模型生成指定数量的样本和标签。</li>
</ul>
</li>
<li><p><strong>保存生成的样本到 <code>.ubyte</code> 文件</strong>：</p>
<ul>
<li>使用 <code>save_dataset</code> 方法将生成的样本和标签保存到文件<code>GAN-Generated-images-idx3-ubyte</code>和<code>GAN-Generated-labels-idx1-ubyte</code>中。</li>
</ul>
</li>
</ol>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch.autograd <span class="keyword">import</span> Variable</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Generator</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, input_size, num_feature, num_classes</span>):</span><br><span class="line">        <span class="built_in">super</span>(Generator, <span class="variable language_">self</span>).__init__()</span><br><span class="line">        <span class="variable language_">self</span>.label_emb = nn.Embedding(num_classes, num_classes)</span><br><span class="line">        <span class="variable language_">self</span>.fc = nn.Linear(input_size + num_classes, num_feature)  <span class="comment"># batch, 3136=1x56x56</span></span><br><span class="line">        <span class="variable language_">self</span>.br = nn.Sequential(</span><br><span class="line">            nn.BatchNorm2d(<span class="number">1</span>),</span><br><span class="line">            nn.ReLU(<span class="literal">True</span>)</span><br><span class="line">        )</span><br><span class="line">        <span class="variable language_">self</span>.conv1_g = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">1</span>, <span class="number">50</span>, <span class="number">3</span>, stride=<span class="number">1</span>, padding=<span class="number">1</span>),  <span class="comment"># batch, 50, 56, 56</span></span><br><span class="line">            nn.BatchNorm2d(<span class="number">50</span>),</span><br><span class="line">            nn.ReLU(<span class="literal">True</span>)</span><br><span class="line">        )</span><br><span class="line">        <span class="variable language_">self</span>.conv2_g = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">50</span>, <span class="number">25</span>, <span class="number">3</span>, stride=<span class="number">1</span>, padding=<span class="number">1</span>),  <span class="comment"># batch, 25, 56, 56</span></span><br><span class="line">            nn.BatchNorm2d(<span class="number">25</span>),</span><br><span class="line">            nn.ReLU(<span class="literal">True</span>)</span><br><span class="line">        )</span><br><span class="line">        <span class="variable language_">self</span>.conv3_g = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">25</span>, <span class="number">1</span>, <span class="number">2</span>, stride=<span class="number">2</span>),  <span class="comment"># batch, 1, 28, 28</span></span><br><span class="line">            nn.Tanh()</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, noise, labels</span>):</span><br><span class="line">        label_embedding = <span class="variable language_">self</span>.label_emb(labels)</span><br><span class="line">        x = torch.cat((noise, label_embedding), -<span class="number">1</span>)</span><br><span class="line">        x = <span class="variable language_">self</span>.fc(x)</span><br><span class="line">        x = x.view(x.size(<span class="number">0</span>), <span class="number">1</span>, <span class="number">56</span>, <span class="number">56</span>)</span><br><span class="line">        x = <span class="variable language_">self</span>.br(x)</span><br><span class="line">        x = <span class="variable language_">self</span>.conv1_g(x)</span><br><span class="line">        x = <span class="variable language_">self</span>.conv2_g(x)</span><br><span class="line">        x = <span class="variable language_">self</span>.conv3_g(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置超参数</span></span><br><span class="line">z_dimension = <span class="number">100</span>  <span class="comment"># 噪声维度</span></span><br><span class="line">num_classes = <span class="number">10</span>  <span class="comment"># 类别数</span></span><br><span class="line">num_samples = <span class="number">60000</span>  <span class="comment"># 生成样本数量</span></span><br><span class="line">output_dir = <span class="string">&#x27;./enhanced_mnist&#x27;</span>  <span class="comment"># 输出目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建输出目录</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(output_dir):</span><br><span class="line">    os.makedirs(output_dir)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载生成器模型</span></span><br><span class="line">generator = Generator(z_dimension, <span class="number">3136</span>, num_classes)</span><br><span class="line">generator.load_state_dict(torch.load(<span class="string">&#x27;./GAN_generator.pth&#x27;</span>, weights_only=<span class="literal">True</span>))</span><br><span class="line">generator.<span class="built_in">eval</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> torch.cuda.is_available():</span><br><span class="line">    generator = generator.cuda()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成数据集</span></span><br><span class="line">generated_samples = []</span><br><span class="line">generated_labels = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_samples):</span><br><span class="line">    z = Variable(torch.randn(<span class="number">1</span>, z_dimension)).cuda()</span><br><span class="line">    labels = Variable(torch.randint(<span class="number">0</span>, num_classes, (<span class="number">1</span>,))).cuda()</span><br><span class="line">    fake_img = generator(z, labels)</span><br><span class="line">    fake_img = fake_img.cpu().data.numpy().squeeze() * <span class="number">255</span>  <span class="comment"># 转为 numpy 数组并缩放到 [0, 255]</span></span><br><span class="line">    generated_samples.append(fake_img.astype(np.uint8))</span><br><span class="line">    generated_labels.append(labels.cpu().item())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将生成的样本和标签打包成数据集</span></span><br><span class="line">generated_samples = np.stack(generated_samples)</span><br><span class="line">generated_labels = np.array(generated_labels, dtype=np.uint8)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存生成的样本到 .ubyte 文件</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">save_dataset</span>(<span class="params">images_filepath, labels_filepath, images, labels</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(images_filepath, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(struct.pack(<span class="string">&#x27;&gt;IIII&#x27;</span>, <span class="number">2051</span>, <span class="built_in">len</span>(images), <span class="number">28</span>, <span class="number">28</span>))  <span class="comment"># Magic number 2051 for images</span></span><br><span class="line">        f.write(images.tobytes())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(labels_filepath, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(struct.pack(<span class="string">&#x27;&gt;II&#x27;</span>, <span class="number">2049</span>, <span class="built_in">len</span>(labels)))  <span class="comment"># Magic number 2049 for labels</span></span><br><span class="line">        f.write(labels.tobytes())</span><br><span class="line"></span><br><span class="line">generated_images_path = os.path.join(output_dir, <span class="string">&#x27;GAN-Generated-images-idx3-ubyte&#x27;</span>)</span><br><span class="line">generated_labels_path = os.path.join(output_dir, <span class="string">&#x27;GAN-Generated-labels-idx1-ubyte&#x27;</span>)</span><br><span class="line"></span><br><span class="line">save_dataset(generated_images_path, generated_labels_path, generated_samples, generated_labels)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;生成的数据集已保存到文件：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot; - 图像文件: <span class="subst">&#123;generated_images_path&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot; - 标签文件: <span class="subst">&#123;generated_labels_path&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="三种数据集可视化对比展示："><a href="#三种数据集可视化对比展示：" class="headerlink" title="三种数据集可视化对比展示："></a>三种数据集可视化对比展示：</h1><h2 id="原始MNIST数据集展示图："><a href="#原始MNIST数据集展示图：" class="headerlink" title="原始MNIST数据集展示图："></a>原始MNIST数据集展示图：</h2><p>​	<img data-src="https://raw.githubusercontent.com/jianingdai/Blog_img/main/img202412121937255.png" alt="plot_2024-12-12 00-02-25_0"></p>
<h2 id="VAE增强数据集展示图："><a href="#VAE增强数据集展示图：" class="headerlink" title="VAE增强数据集展示图："></a>VAE增强数据集展示图：</h2><p><img data-src="https://raw.githubusercontent.com/jianingdai/Blog_img/main/img202412122335686.png" alt="plot_2024-12-12 23-34-41_2"></p>
<h2 id="CGAN增强数据集展示图："><a href="#CGAN增强数据集展示图：" class="headerlink" title="CGAN增强数据集展示图："></a>CGAN增强数据集展示图：</h2><p><img data-src="https://raw.githubusercontent.com/jianingdai/Blog_img/main/img202412122336984.png" alt="plot_2024-12-12 23-34-41_1"></p>
<h1 id="分别用三种数据集训练分类模型："><a href="#分别用三种数据集训练分类模型：" class="headerlink" title="分别用三种数据集训练分类模型："></a>分别用三种数据集训练分类模型：</h1><h2 id="分类模型选择：LeNet5"><a href="#分类模型选择：LeNet5" class="headerlink" title="分类模型选择：LeNet5"></a>分类模型选择：LeNet5</h2><p>我的这里的深度学习的分类模型选择的是LeNet5模型，当然LeNet5模型本身可以对图像的横向纵向进行特征提取就可以达到99%的正确识别率具体为：</p>
<h3 id="LeNet5-模型"><a href="#LeNet5-模型" class="headerlink" title="LeNet5 模型"></a>LeNet5 模型</h3><p>LeNet5 是一个经典的卷积神经网络（CNN）模型，主要用于图像分类任务。其结构如下：</p>
<ol>
<li><p><strong>卷积层 1</strong> (<code>conv1</code>)：</p>
<ul>
<li>输入通道数：1</li>
<li>输出通道数：6</li>
<li>卷积核大小：5</li>
</ul>
</li>
<li><p><strong>卷积层 2</strong> (<code>conv2</code>)：</p>
<ul>
<li>输入通道数：6</li>
<li>输出通道数：16</li>
<li>卷积核大小：5</li>
</ul>
</li>
<li><p><strong>全连接层 1</strong> (<code>fc1</code>)：</p>
<ul>
<li>输入维度：16 * 4 * 4</li>
<li>输出维度：120</li>
</ul>
</li>
<li><p><strong>全连接层 2</strong> (<code>fc2</code>)：</p>
<ul>
<li>输入维度：120</li>
<li>输出维度：84</li>
</ul>
</li>
<li><p><strong>全连接层 3</strong> (<code>fc3</code>)：</p>
<ul>
<li>输入维度：84</li>
<li>输出维度：10</li>
</ul>
</li>
</ol>
<h3 id="前向传播过程"><a href="#前向传播过程" class="headerlink" title="前向传播过程"></a>前向传播过程</h3><ol>
<li>输入图像通过第一个卷积层 (<code>conv1</code>)，然后经过 ReLU 激活函数。</li>
<li>经过最大池化层 (<code>max_pool2d</code>)。</li>
<li>通过第二个卷积层 (<code>conv2</code>)，然后经过 ReLU 激活函数。</li>
<li>再次经过最大池化层 (<code>max_pool2d</code>)。</li>
<li>将特征图展平为一维向量。</li>
<li>通过第一个全连接层 (<code>fc1</code>)，然后经过 ReLU 激活函数。</li>
<li>通过第二个全连接层 (<code>fc2</code>)，然后经过 ReLU 激活函数。</li>
<li>通过第三个全连接层 (<code>fc3</code>)，输出分类结果。</li>
</ol>
<h3 id="类代码如下："><a href="#类代码如下：" class="headerlink" title="类代码如下："></a>类代码如下：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LeNet5</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(LeNet5, <span class="variable language_">self</span>).__init__()</span><br><span class="line">        <span class="variable language_">self</span>.conv1 = nn.Conv2d(<span class="number">1</span>, <span class="number">6</span>, kernel_size=<span class="number">5</span>)</span><br><span class="line">        <span class="variable language_">self</span>.conv2 = nn.Conv2d(<span class="number">6</span>, <span class="number">16</span>, kernel_size=<span class="number">5</span>)</span><br><span class="line">        <span class="variable language_">self</span>.fc1 = nn.Linear(<span class="number">16</span> * <span class="number">4</span> * <span class="number">4</span>, <span class="number">120</span>)</span><br><span class="line">        <span class="variable language_">self</span>.fc2 = nn.Linear(<span class="number">120</span>, <span class="number">84</span>)</span><br><span class="line">        <span class="variable language_">self</span>.fc3 = nn.Linear(<span class="number">84</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        x = torch.relu(<span class="variable language_">self</span>.conv1(x))</span><br><span class="line">        x = torch.max_pool2d(x, <span class="number">2</span>)</span><br><span class="line">        x = torch.relu(<span class="variable language_">self</span>.conv2(x))</span><br><span class="line">        x = torch.max_pool2d(x, <span class="number">2</span>)</span><br><span class="line">        x = x.view(-<span class="number">1</span>, <span class="number">16</span> * <span class="number">4</span> * <span class="number">4</span>)</span><br><span class="line">        x = torch.relu(<span class="variable language_">self</span>.fc1(x))</span><br><span class="line">        x = torch.relu(<span class="variable language_">self</span>.fc2(x))</span><br><span class="line">        x = <span class="variable language_">self</span>.fc3(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure>

<h2 id="损失函数和优化器："><a href="#损失函数和优化器：" class="headerlink" title="损失函数和优化器："></a>损失函数和优化器：</h2><ol>
<li><p><strong>设置损失函数</strong>：</p>
<ul>
<li><code>criterion = nn.CrossEntropyLoss()</code>：使用交叉熵损失函数（Cross-Entropy Loss），这是一个常用的分类任务损失函数。</li>
</ul>
</li>
<li><p><strong>设置优化器</strong>：</p>
<ul>
<li><code>optimizer = optim.Adam(leNet.parameters(), lr=learning_rate)</code>：使用Adam优化器，并设置学习率。Adam优化器是一种自适应学习率优化算法，适用于大多数深度学习模型。</li>
</ul>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">criterion = nn.CrossEntropyLoss()</span><br><span class="line">optimizer = optim.Adam(leNet.parameters(), lr=learning_rate)</span><br></pre></td></tr></table></figure>

<h2 id="代码：-3"><a href="#代码：-3" class="headerlink" title="代码："></a>代码：</h2><p>三种训练LeNet5的代码都一样只有数据集加载处有些改动，写的时候为了方便调试拆成了3个单独的文件，其中一个利用GAN训练增强数据集<code>GAN_Train_LeNet_Combined.py</code>的代码如下，（另外两个VAE和Original都类似，仅仅只有加载数据集过程中有些小区别）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> datasets, transforms</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader, ConcatDataset</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># ======================== 定义LeNet模型 ========================</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LeNet5</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(LeNet5, <span class="variable language_">self</span>).__init__()</span><br><span class="line">        <span class="variable language_">self</span>.conv1 = nn.Conv2d(<span class="number">1</span>, <span class="number">6</span>, kernel_size=<span class="number">5</span>)</span><br><span class="line">        <span class="variable language_">self</span>.conv2 = nn.Conv2d(<span class="number">6</span>, <span class="number">16</span>, kernel_size=<span class="number">5</span>)</span><br><span class="line">        <span class="variable language_">self</span>.fc1 = nn.Linear(<span class="number">16</span> * <span class="number">4</span> * <span class="number">4</span>, <span class="number">120</span>)</span><br><span class="line">        <span class="variable language_">self</span>.fc2 = nn.Linear(<span class="number">120</span>, <span class="number">84</span>)</span><br><span class="line">        <span class="variable language_">self</span>.fc3 = nn.Linear(<span class="number">84</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        x = torch.relu(<span class="variable language_">self</span>.conv1(x))</span><br><span class="line">        x = torch.max_pool2d(x, <span class="number">2</span>)</span><br><span class="line">        x = torch.relu(<span class="variable language_">self</span>.conv2(x))</span><br><span class="line">        x = torch.max_pool2d(x, <span class="number">2</span>)</span><br><span class="line">        x = x.view(-<span class="number">1</span>, <span class="number">16</span> * <span class="number">4</span> * <span class="number">4</span>)</span><br><span class="line">        x = torch.relu(<span class="variable language_">self</span>.fc1(x))</span><br><span class="line">        x = torch.relu(<span class="variable language_">self</span>.fc2(x))</span><br><span class="line">        x = <span class="variable language_">self</span>.fc3(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="comment"># ======================== 加载增强的数据集 ========================</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_enhanced_dataset</span>(<span class="params">images_path, labels_path</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(images_path, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        images = np.frombuffer(f.read(), dtype=np.uint8, offset=<span class="number">16</span>).reshape(-<span class="number">1</span>, <span class="number">28</span>, <span class="number">28</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(labels_path, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        labels = np.frombuffer(f.read(), dtype=np.uint8, offset=<span class="number">8</span>)</span><br><span class="line">    <span class="keyword">return</span> [(torch.tensor(image, dtype=torch.float32).unsqueeze(<span class="number">0</span>), label) <span class="keyword">for</span> image, label <span class="keyword">in</span> <span class="built_in">zip</span>(images, labels)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># ======================== 设置超参数 ========================</span></span><br><span class="line">    batch_size = <span class="number">64</span></span><br><span class="line">    learning_rate = <span class="number">0.001</span></span><br><span class="line">    num_epochs = <span class="number">50</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ======================== 数据预处理 ========================</span></span><br><span class="line">    transform = transforms.Compose([</span><br><span class="line">        transforms.ToTensor(),</span><br><span class="line">        transforms.Normalize((<span class="number">0.1307</span>,), (<span class="number">0.3081</span>,))</span><br><span class="line">    ])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ======================== 加载MNIST数据集 ========================</span></span><br><span class="line">    train_dataset = datasets.MNIST(root=<span class="string">&#x27;./data&#x27;</span>, train=<span class="literal">True</span>, transform=transform, download=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># test_dataset = datasets.MNIST(root=&#x27;./data&#x27;, train=False, transform=transform, download=True)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ======================== 加载增强的数据集 ========================</span></span><br><span class="line">    enhanced_images_path = <span class="string">&#x27;./enhanced_mnist/GAN-Generated-images-idx3-ubyte&#x27;</span></span><br><span class="line">    enhanced_labels_path = <span class="string">&#x27;./enhanced_mnist/GAN-Generated-labels-idx1-ubyte&#x27;</span></span><br><span class="line">    enhanced_dataset = load_enhanced_dataset(enhanced_images_path, enhanced_labels_path)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ======================== 合并数据集 ========================</span></span><br><span class="line">    combined_train_dataset = ConcatDataset([train_dataset, enhanced_dataset])</span><br><span class="line">    train_loader = DataLoader(combined_train_dataset, batch_size=batch_size, shuffle=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># test_loader = DataLoader(test_dataset, batch_size=batch_size, shuffle=False)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ======================== 初始化模型、损失函数和优化器 ========================</span></span><br><span class="line">    leNet = LeNet5().to(<span class="string">&#x27;cuda&#x27;</span>)</span><br><span class="line">    criterion = nn.CrossEntropyLoss()</span><br><span class="line">    optimizer = optim.Adam(leNet.parameters(), lr=learning_rate)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        leNet.load_state_dict(torch.load(<span class="string">&#x27;GAN_leNet_mnist.pth&#x27;</span>, weights_only=<span class="literal">True</span>))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Model loaded successfully.&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Model file not found. Initializing model with random weights.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ======================== 训练模型 ========================</span></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):</span><br><span class="line">        leNet.train()</span><br><span class="line">        running_loss = <span class="number">0.0</span></span><br><span class="line">        <span class="keyword">for</span> images, labels <span class="keyword">in</span> train_loader:</span><br><span class="line">            images, labels = images.to(<span class="string">&#x27;cuda&#x27;</span>), labels.to(<span class="string">&#x27;cuda&#x27;</span>)</span><br><span class="line"></span><br><span class="line">            optimizer.zero_grad()</span><br><span class="line">            outputs = leNet(images)</span><br><span class="line">            loss = criterion(outputs, labels)</span><br><span class="line">            loss.backward()</span><br><span class="line">            optimizer.step()</span><br><span class="line"></span><br><span class="line">            running_loss += loss.item()</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Epoch [<span class="subst">&#123;epoch+<span class="number">1</span>&#125;</span>/<span class="subst">&#123;num_epochs&#125;</span>], Loss: <span class="subst">&#123;running_loss/<span class="built_in">len</span>(train_loader):<span class="number">.4</span>f&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ======================== 保存模型 ========================</span></span><br><span class="line">    torch.save(leNet.state_dict(), <span class="string">&#x27;GAN_leNet_mnist.pth&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="效果对比"><a href="#效果对比" class="headerlink" title="效果对比"></a>效果对比</h1><p>这里基于MNIST测试集对比三种训练集得到的模型做分类准确率评估评估效果如下：</p>
<p><img data-src="https://raw.githubusercontent.com/jianingdai/Blog_img/main/img202412122341083.png" alt="plot_2024-12-12 23-34-41_3"></p>
<p>三种数据集分别训练LeNet5模型进行分类的成功率如下：</p>
<p>原始数据集：98.98%</p>
<p>利用VAE增强的数据集：98.80%</p>
<p>利用GAN增强的数据集：98.37%</p>
<h1 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h1><p>​	利用增强数据集训练的 LeNet 模型，分类效果略微下降了一些，但整体分类成功率仍能保持在 <strong>98%</strong> 以上。这可能是因为：</p>
<ol>
<li>VAE 和 CGAN 是基于训练集中的数据进行样本生成的，其生成的样本往往会使整个样本集的数据特征更加集中于某些特定方面。当生成的数据过于充分时，这种特性在训练 LeNet-5 时可能进一步削弱其泛化能力，从而导致<strong>过拟合</strong>，在测试集上表现为分类能力下降和性能减退。这一问题在 LeNet-5 这样的复杂多层卷积网络中尤为显著。</li>
<li>我认为，部分过拟合现象可能也与数据集本身过于简单有关。以 MNIST 数据集为例，其本身较为简单，而且训练集已经包含了 60,000 条数据，数量相当充足。在数据增强后，训练集的样本数量更是达到了 120,000 条。假设这些增强数据均为有效样本，那么对于像 LeNet-5 这样专注于分类任务的卷积神经网络来说，更容易出现<strong>过拟合</strong>现象。</li>
<li>CGAN 的工作模式可能会加重<strong>过拟合</strong>现象。这是因为 GAN 模式中的 Discriminator 是基于训练集对 Generator 生成的数据进行辨别的，而这种<strong>对抗性</strong>机制会导致 Discriminator 和 Generator 在训练集上表现得过于“精准”，从而更容易出现过拟合问题。</li>
</ol>
]]></content>
      <categories>
        <category>AI</category>
        <category>GenAI</category>
      </categories>
      <tags>
        <tag>AI</tag>
        <tag>VAE</tag>
        <tag>LeNet</tag>
        <tag>GenAI</tag>
        <tag>CGAN</tag>
        <tag>GAN</tag>
      </tags>
  </entry>
  <entry>
    <title>读写分离sync.Map</title>
    <url>/2025/09/14/%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BBsync-Map/</url>
    <content><![CDATA[<h2 id="sync-Map-概述"><a href="#sync-Map-概述" class="headerlink" title="sync.Map 概述"></a><strong><code>sync.Map</code> 概述</strong></h2><p>在 Go 中，普通的 <code>map</code> 在并发读写时是不安全的，需要通过 <strong><code>sync.Mutex</code> 或 <code>sync.RWMutex</code></strong> 来保护。</p>
<p>为了减少手动加锁的复杂度和一些场景的性能开销，Go 在 <strong>Go1.9</strong> 引入了 **<code>sync.Map</code>**，一个并发安全的 map 实现。其提供了以下的特性：</p>
<ul>
<li><strong>并发安全：</strong><code>sync.Map</code> 支持并发读写操作，读操作和写操作都能安全地在多个 Goroutine 中进行。</li>
<li><strong>读写分离：</strong><code>sync.Map</code> 内部实现优化了读操作的性能，特别是在高并发场景下。</li>
</ul>
<h2 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h2><p><code>sync.Map</code> 提供了几种主要的方法：</p>
<ul>
<li>**<code>Load(key interface&#123;&#125;) (value interface&#123;&#125;, ok bool)</code>**：<ul>
<li>从 <code>sync.Map</code> 中加载指定 <code>key</code> 对应的值。</li>
<li>如果 <code>key</code> 存在，则返回值和 <code>true</code>，否则返回 <code>nil</code> 和 <code>false</code>。</li>
</ul>
</li>
<li>**<code>Store(key, value interface&#123;&#125;)</code>**：<ul>
<li>存储或更新指定 <code>key</code> 对应的值。</li>
</ul>
</li>
<li>**<code>Delete(key interface&#123;&#125;)</code>**：<ul>
<li>删除指定 <code>key</code> 对应的值。</li>
</ul>
</li>
<li>**<code>Range(f func(key, value interface&#123;&#125;) bool)</code>**：<ul>
<li>遍历 <code>sync.Map</code> 中的所有键值对。<code>f</code> 是一个回调函数，用于处理每个键值对。如果 <code>f</code> 返回 <code>false</code>，则遍历会中止。</li>
</ul>
</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><code>sync.Map</code> 没有 <code>make</code>，直接定义就能用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var m sync.Map</span><br></pre></td></tr></table></figure>

<h3 id="（1）Store"><a href="#（1）Store" class="headerlink" title="（1）Store"></a>（1）Store</h3><p>存储键值对（类似 <code>map[key] = value</code>）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">m.Store(&quot;name&quot;, &quot;Jack&quot;)</span><br></pre></td></tr></table></figure>

<h3 id="（2）Load"><a href="#（2）Load" class="headerlink" title="（2）Load"></a>（2）Load</h3><p>读取键值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">value, ok := m.Load(&quot;name&quot;)</span><br><span class="line">if ok &#123;</span><br><span class="line">    fmt.Println(&quot;找到：&quot;, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（3）LoadOrStore"><a href="#（3）LoadOrStore" class="headerlink" title="（3）LoadOrStore"></a>（3）LoadOrStore</h3><p>如果 key 已经存在，返回旧值和 <code>true</code>；<br> 如果 key 不存在，存储新值并返回它和 <code>false</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">actual, loaded := m.LoadOrStore(&quot;age&quot;, 25)</span><br><span class="line">fmt.Println(actual, loaded) // 如果之前有值，loaded = true</span><br></pre></td></tr></table></figure>

<h3 id="（4）Delete"><a href="#（4）Delete" class="headerlink" title="（4）Delete"></a>（4）Delete</h3><p>删除一个键</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">m.Delete(&quot;name&quot;)</span><br></pre></td></tr></table></figure>

<h3 id="（5）Range"><a href="#（5）Range" class="headerlink" title="（5）Range"></a>（5）Range</h3><p>遍历所有键值对（函数返回 <code>true</code> 才继续遍历）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">m.Range(func(key, value any) bool &#123;</span><br><span class="line">    fmt.Println(&quot;key:&quot;, key, &quot;value:&quot;, value)</span><br><span class="line">    return true</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="读写分离的实现原理"><a href="#读写分离的实现原理" class="headerlink" title="读写分离的实现原理"></a>读写分离的实现原理</h2><h3 id="简要版"><a href="#简要版" class="headerlink" title="简要版"></a><strong>简要版</strong></h3><p><code>sync.Map</code> 通过内部的设计来优化读操作，包括以下机制：</p>
<p><strong>1. 读操作优化</strong></p>
<ul>
<li><p><strong>读缓存</strong>：</p>
<ul>
<li><code>sync.Map</code> 通过内置的读缓存来优化读操作。当一个键值对被读取时，它会被存储在一个专用的读缓存中。之后的读取操作会优先访问这个缓存，而不是直接访问底层的存储结构。</li>
</ul>
</li>
<li><p><strong>读优化数据结构</strong>：</p>
<ul>
<li><code>sync.Map</code> 使用了一种特殊的数据结构（分层的数据结构），例如写时复制（Copy-on-write）和延迟删除，来提高读取性能。在并发情况下，读操作不需要加锁，可以直接从缓存中读取数据，从而减少锁竞争的开销。</li>
</ul>
</li>
</ul>
<p><strong>2. 写操作</strong></p>
<ul>
<li><p><strong>写操作锁定</strong>：</p>
<ul>
<li>虽然 <code>sync.Map</code> 优化了读操作，但写操作仍然需要加锁，以保证并发环境下的正确性。写操作包括存储、更新和删除操作，它们会获取锁以确保数据一致性。</li>
</ul>
</li>
<li><p><strong>分离读写</strong>：</p>
<ul>
<li><code>sync.Map</code> 的设计允许读操作和写操作在不同的数据结构中进行，从而避免了读操作对写操作的阻塞。通过这种方式，读操作可以在没有锁的情况下进行，而写操作则会进行锁定。</li>
</ul>
</li>
</ul>
<h3 id="详细版"><a href="#详细版" class="headerlink" title="详细版"></a>详细版</h3><p><code>sync.Map</code> 用<strong>一个只读快表 + 一个“脏”表 + 少量锁与原子操作</strong>的组合来保证读操作的无锁快速路径，同时在必要时把写入合并到脏表并“按需”把脏表提升为新的只读表，从而在<strong>读多写少</strong>或“写只发生一次后大量读取”的场景下减少锁竞争、提高吞吐。</p>
<hr>
<p><strong>关键数据结构（基于源码）</strong></p>
<p>在源码中，核心是 <code>type Map struct</code>，主要字段为：</p>
<ul>
<li><code>mu Mutex</code>：用于保护对脏表（dirty）和其他状态的修改（写路径的互斥）。</li>
<li><code>read atomic.Pointer[readOnly]</code>：只读视图（immutable），可以无锁安全读取。<code>readOnly</code> 包含 <code>m map[any]*entry</code> 和 <code>amended bool</code>（如果 <code>dirty</code> 有 <code>read.m</code> 没有的键则为 true）。</li>
<li><code>dirty map[any]*entry</code>：脏表，需要持 <code>mu</code> 时访问；脏表包含了那些在 read 中不存在或未被“清理”的项。</li>
<li><code>misses int</code>：统计“读没命中只读表需要去锁查脏表”的次数，用来判断何时把 dirty 提升为新的只读表（以 amortize 拷贝成本）。</li>
</ul>
<p><code>readOnly</code> 是不可变的结构体（通过 atomic 存取），这样读者可以无锁读取该结构体的 map 引用。</p>
<hr>
<p><strong>entry：每个 key 的内部表示与三种状态</strong></p>
<p>每个 key 对应 <code>*entry</code>，其中最重要的是 <code>p atomic.Pointer[any]</code> —— 它指向 *interface{} 值 的指针。<code>p</code> 的含义（源码注释可见）可以分成三种主要状态：</p>
<ol>
<li><strong>有效（valid）</strong>：<code>p</code> 指向一个 <code>*interface&#123;&#125;</code>（即保存了 value），表示存在且可读写（用原子替换）。</li>
<li><strong>已删除（deleted but not expunged）</strong>：<code>p == nil</code> —— 表示该 entry 已被删除（但是在某些时刻，脏表&#x2F;只读表的管理会决定是否把它“真正清除&#x2F;标记为 expunged”）。</li>
<li><strong>已彻底移除 &#x2F; expunged</strong>：<code>p == expunged</code>（源码里 <code>var expunged = new(any)</code> 作为特殊哨兵指针）—— 表示该 entry 在脏表中不存在且已被标记为不可恢复（要再写入需先把它“unexpunge”并放进 dirty）。</li>
</ol>
<p>这些状态通过原子 <code>Load/CompareAndSwap/Swap</code> 操作在 <code>entry</code> 层面进行转换（因此单个 entry 可以在并发场景下做无锁更新或删除的部分工作）。</p>
<hr>
<p><strong>操作流程（按方法逐一描述核心块&#x2F;慢路径与状态转移）</strong></p>
<p><strong>Load(key)</strong></p>
<ol>
<li><strong>快路径（无锁）</strong>：读取 <code>read := m.loadReadOnly()</code>（原子读），查 <code>read.m[key]</code>。如果找到对应 <code>*entry</code>，再调用 <code>entry.load()</code>（<code>p := e.p.Load(); if p==nil||p==expunged return notfound; else return *p</code>）。这就是绝大多数读的无锁快路径。</li>
<li><strong>慢路径（需要锁）</strong>：如果 <code>read.m</code> 没找到且 <code>read.amended == true</code>（说明 dirty 里可能有该 key），则会 <code>m.mu.Lock()</code>，重新读取 <code>read</code>（防止竞争），然后去 <code>m.dirty</code> 查找；无论脏表是否命中，都会调用 <code>m.missLocked()</code> 记录一次 miss（因为这个 key 走了慢路径）。<code>missLocked</code> 负责在累计足够多的 miss 后把 <code>dirty</code> 推升为新的 <code>read</code>，以 amortize 拷贝成本。</li>
</ol>
<p><strong>Store &#x2F; Swap &#x2F; LoadOrStore</strong></p>
<ul>
<li><code>Store</code> 实际上是通过 <code>Swap</code> 实现的。<code>Swap</code> 对 <code>read</code> 做尝试性无锁更新（例如尝试在 entry 上做 <code>trySwap</code>），如果失败（例如 entry 不存在或被 expunged），则进入持锁路径：<ul>
<li>如果 <code>read</code> 中存在但是 expunged，需要先 <code>unexpungeLocked</code>（将 expunged -&gt; nil），并把 entry 放入 <code>m.dirty</code>；</li>
<li>如果 <code>m.dirty</code> 为 nil 且要添加新键，调用 <code>dirtyLocked()</code>：它会以 <code>read.m</code> 为蓝本创建 <code>dirty</code> 的浅拷贝（排除已经 expunged 的 entry），并把 <code>read</code> 标记为 <code>amended=true</code>（表示 dirty 含有 read 没有的 key），然后把新键加入 <code>dirty</code>。</li>
</ul>
</li>
<li><code>LoadOrStore</code> 先尝试只读表的快路径（无锁），命中时直接调用 <code>entry.tryLoadOrStore</code>（原子尝试）；否则走锁路径，必要时初始化 <code>dirty</code> 并把新 entry 放入 <code>dirty</code>，同时可能 <code>m.read.Store(&amp;readOnly&#123;... amended:true&#125;)</code>。总之写入通常会落到 <code>dirty</code>，以避免频繁拷贝 <code>read</code>。</li>
</ul>
<p><strong>Delete &#x2F; LoadAndDelete</strong></p>
<ul>
<li>删除对 <code>entry.p</code> 做原子替换为 <code>nil</code>（<code>CompareAndSwap(p, nil)</code>），这将使 <code>entry.load()</code> 以后返回不存在。注意：当 <code>dirty</code> 被下次创建时，<code>tryExpungeLocked</code> 会把 <code>nil</code> 状态的 entry 变为 <code>expunged</code>（即 <code>CompareAndSwap(nil, expunged)</code>），从而在 <code>read</code> 中表明这是“不可恢复并且不应当出现在 dirty 中”的条目。</li>
</ul>
<p><strong>Range</strong></p>
<ul>
<li>如果 <code>read.amended == false</code>，则 <code>read.m</code> 可以被安全遍历（只读视图）。如果 <code>amended == true</code>（说明 <code>m.dirty</code> 有 <code>read</code> 没有的键），<code>Range</code> 会持锁并“把 dirty 立刻提升为新的 read”（把 <code>read</code> 替换为 <code>readOnly&#123;m: m.dirty&#125;</code>，并把 <code>m.dirty = nil</code>、<code>m.misses=0</code>），然后再遍历。源码也明确指出 <code>Range</code> <strong>不保证一致性快照</strong>：并发的 Store&#x2F;Delete 可能导致看到不同时间点的映射。</li>
</ul>
<hr>
<p><strong>miss &#x2F; promotion 策略（为什么有 misses）</strong></p>
<ul>
<li>每次读在只读表 miss 并且需要锁去查脏表时，会调用 <code>m.missLocked()</code>：它会 <code>m.misses++</code>，当 <code>m.misses &gt;= len(m.dirty)</code> 时，认为把 <code>dirty</code> 直接提升为 <code>read</code> 的成本被 amortized（相当于 “多次慢查找的成本 &gt;&#x3D; 一次把 dirty 拷贝为 read 的成本”），于是把 <code>m.read.Store(&amp;readOnly&#123;m: m.dirty&#125;)</code>，<code>m.dirty = nil</code>，并 <code>m.misses = 0</code>。这就是“慢查次数触发脏表提升”的策略，目的是在读多、某些键频繁走慢路径时避免长期的慢查找。</li>
</ul>
<hr>
<p><strong>entry 的 expunge&#x2F;unexpunge 细节（为什么要 expunged）</strong></p>
<ul>
<li>设计目标：在不频繁分配&#x2F;复制读表的情况下，既要支持删除又要在必要时“让写能重新写回被删除的 key”。</li>
<li>实现细节：<ul>
<li>删操作先把 <code>p</code> 置 <code>nil</code>（代表已删除，但 <code>read</code> 中依然可能保有 entry 指针）。</li>
<li>当 <code>dirty</code> 被创建（例如第一次发生写入导致 dirtyLocked），<code>tryExpungeLocked</code> 会把那些 <code>p==nil</code> 的 entry 原子改成 <code>expunged</code>。<code>expunged</code> 的意思是“这个 entry 不应出现在 dirty 中，且要把它从 read 的语义上视为彻底移除”。</li>
<li>如果后来想在该 key 上写入，且 <code>read</code> 中该 entry 是 <code>expunged</code>，则要先 <code>unexpungeLocked</code>（把 <code>expunged</code> -&gt; nil），并把 entry 明确放入 <code>dirty</code>，然后在 <code>dirty</code> 上写入。这样能安全地让“被标记为彻底删除”的项被重新写回。</li>
</ul>
</li>
</ul>
<hr>
<p><strong>为何采用这种“read + dirty + expunge + miss”设计？（设计动机）</strong></p>
<ul>
<li>目标是<strong>让绝大多数读操作走无锁快路径</strong>（仅一次原子加载 read 指针 + map 查找 + entry 的原子加载），避免读侧锁竞争。</li>
<li>写入与删除被推到脏表并在恰当时机批量合并（promote）到只读视图，以把单次写造成的开销摊薄（amortize）。</li>
<li>适合两类场景（源码注释指出）：<ol>
<li>key 只写一次但读很多（如只增不删的缓存）；</li>
<li>多 goroutine 对互斥的 key 集合进行读写（不同 key 集合互不干扰，读少写少的冲突少）。<br> 否则（写非常频繁且热点很大），普通 <code>map + RWMutex</code> 可能更简单且更快。</li>
</ol>
</li>
</ul>
<hr>
<p><strong>状态机小结（便于记忆）</strong></p>
<ul>
<li><code>entry.p</code>:<ul>
<li><code>nil</code> —— 已删除（但尚未被 expunge）</li>
<li><code>expunged</code> —— 已彻底移除（在 dirty 中不存在），写入前需 <code>unexpunge</code></li>
<li>指向 <code>*interface&#123;&#125;</code> —— 有效值</li>
</ul>
</li>
<li>Map 层面：<ul>
<li><code>read</code>：无锁可读的稳定视图（immutable）；</li>
<li><code>dirty</code>：需锁访问的可变视图，包含 read 未包含的键（<code>read.amended==true</code> 表示存在这种情况）；</li>
<li><code>misses</code>：控制何时把 dirty 升级为 read。</li>
</ul>
</li>
</ul>
<p>（以上实现细节均直接反映在 Go 标准库 <code>src/sync/map.go</code> 中的实现与注释。）<a href="https://go.dev/src/sync/map.go">Go</a></p>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h2><p><code>sync.Map</code> 适用于以下场景：</p>
<ul>
<li><strong>高并发读多写少</strong>：在读操作远远多于写操作的情况下，<code>sync.Map</code> 的性能优势明显。</li>
<li><strong>需要并发安全的映射</strong>：当你需要在多个 Goroutine 中安全地读写映射时，<code>sync.Map</code> 是一个很好的选择。但是<strong>写操作频繁</strong>时，不如 <code>map + RWMutex</code> 高效。</li>
</ul>
]]></content>
      <categories>
        <category>后端开发</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>后端开发</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言编写的文件服务器</title>
    <url>/2025/03/09/go%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E7%9A%84%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<h1 id="简易用户文件系统"><a href="#简易用户文件系统" class="headerlink" title="简易用户文件系统"></a>简易用户文件系统</h1><p>项目地址：<a href="https://github.com/jianingdai/filesysByGo">https://github.com/jianingdai/filesysByGo</a></p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol>
<li><p>在 <code>08</code> 文件夹中使用以下命令来启动服务程序</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">go run ./cmd/filesys/main.go</span><br></pre></td></tr></table></figure></li>
<li><p><strong>！！！第一次运行时需要在 <code>08</code> 文件夹下依次运行以下两个命令：</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">go run ./cmd/init_db/main.go</span><br><span class="line">go run ./cmd/gen/main.go</span><br></pre></td></tr></table></figure></li>
</ol>
<p>文件管理系统的默认开启端口为 8080 端口。</p>
<p>访问运行服务程序主机的 8080 端口就可以查看并且测试文件系统，不过前端界面只是测试界面，是一个很简陋的测试界面。</p>
<h2 id="功能概述"><a href="#功能概述" class="headerlink" title="功能概述"></a>功能概述</h2><ol>
<li>实现一个简易的用户文件系统。</li>
<li>每个用户拥有独立的文件树，节点类型包括文件和文件夹。</li>
<li>每个文件或文件夹都有唯一 ID，根目录文件夹 ID 为 0。</li>
<li>支持文件和文件夹的基本操作接口。</li>
<li>系统默认自带管理员账号 <code>admin</code>，仅管理员可创建其他用户。</li>
<li>同一文件夹下文件和文件夹均不可重名，若重名则自动重命名（规则参考 Windows）。</li>
<li>文件支持版本管理，版本号从 1 开始递增，当前版本号最大。</li>
<li><del>高级功能：客户端配合服务端使用 rsync 差分算法实现历史版本增量上传（后续版本实现）。</del></li>
<li>文件存储于工程根目录下的 <a href="week01/practice/go/08/frontend/main.js"><code>data</code></a> 目录，需考虑磁盘文件清理。</li>
<li>推荐使用 Postman 进行接口测试，支持简单前端页面展示更佳。</li>
</ol>
<h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><ul>
<li>Web 框架：<a href="https://github.com/gin-gonic/gin">Gin</a></li>
<li>ORM 框架：<a href="https://gorm.io/">GORM</a></li>
<li>数据库：SQLite</li>
<li>代码生成工具：<a href="https://gorm.io/gen/">GORM Gen</a></li>
</ul>
<h2 id="分层设计"><a href="#分层设计" class="headerlink" title="分层设计"></a>分层设计</h2><p>该项目采用分层设计，主要分为以下几层：</p>
<ul>
<li><strong>cmd</strong>: 包含可执行文件，例如：<ul>
<li><code>filesys</code>: 主程序入口，负责初始化数据库连接、启动 utils.StartSessionCleaner() 定时清理过期 session 的协程，以及初始化并启动 router。</li>
<li><code>init_db</code>: 初始化数据库，创建表结构并创建默认管理员用户。</li>
<li><code>gen</code>: 使用 GORM Gen 自动生成数据库访问代码。<ul>
<li><strong>注意</strong>: 首次运行项目时，需要先运行 <code>init_db</code> 初始化数据库，然后运行 <code>gen</code> 生成数据库访问代码。</li>
</ul>
</li>
</ul>
</li>
<li><strong>dao</strong>: 数据库访问层，包含自动生成的数据库操作代码。 使用 GORM Gen 根据数据库表结构自动生成，位于 dao 目录。<ul>
<li>该层主要通过 GORM 提供的 API 进行数据库操作，例如：<ul>
<li><code>Create</code>: 创建数据。</li>
<li><code>Find</code>: 查询数据。</li>
<li><code>Update</code>: 更新数据。</li>
<li><code>Delete</code>: 删除数据。</li>
</ul>
</li>
</ul>
</li>
<li><strong>models</strong>: 数据库模型定义，定义了数据库表的结构体。 位于 models_def 目录。<ul>
<li><p>例如，<code>User</code> 结构体定义了用户表的结构：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID        <span class="type">int64</span>     <span class="string">`gorm:&quot;primaryKey;autoIncrement&quot;`</span></span><br><span class="line">    Username  <span class="type">string</span>    <span class="string">`gorm:&quot;type:varchar(255);not null;unique&quot;`</span></span><br><span class="line">    Password  <span class="type">string</span>    <span class="string">`gorm:&quot;type:varchar(255);not null&quot;`</span></span><br><span class="line">    CreatedAt time.Time</span><br><span class="line">    UpdatedAt time.Time</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>File</code> 结构体定义了文件表的结构：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> File <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID        <span class="type">int64</span>     <span class="string">`gorm:&quot;primaryKey;autoIncrement&quot;`</span></span><br><span class="line">    UserID    <span class="type">int64</span>     <span class="string">`gorm:&quot;not null&quot;`</span></span><br><span class="line">    ParentID  <span class="type">int64</span>     <span class="string">`gorm:&quot;not null&quot;`</span></span><br><span class="line">    Name      <span class="type">string</span>    <span class="string">`gorm:&quot;type:varchar(255);not null&quot;`</span></span><br><span class="line">    Type      <span class="type">int</span>       <span class="string">`gorm:&quot;not null&quot;`</span> <span class="comment">// 0: 文件夹, 1: 文件</span></span><br><span class="line">    Size      <span class="type">int64</span>     <span class="string">`gorm:&quot;not null&quot;`</span></span><br><span class="line">    Hash      <span class="type">string</span>    <span class="string">`gorm:&quot;type:varchar(255)&quot;`</span></span><br><span class="line">    Version   <span class="type">int</span>       <span class="string">`gorm:&quot;not null;default:1&quot;`</span></span><br><span class="line">    CreatedAt time.Time</span><br><span class="line">    UpdatedAt time.Time</span><br><span class="line">    DeletedAt gorm.DeletedAt <span class="string">`gorm:&quot;index&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>endpoint</strong>: 接口处理层，负责接收 HTTP 请求、参数校验、调用 service 层处理业务逻辑，并将结果返回给客户端。<ul>
<li><p>该层使用了 Gin 框架提供的 API 进行路由注册和请求处理。</p>
</li>
<li><p>例如，<code>CreateUser</code> 函数处理创建用户请求：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateUser</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> err := s.CreateUser(username, password); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>service</strong>: 业务逻辑层，负责实现具体的业务逻辑，例如：<ul>
<li>文件上传、下载、删除、复制、移动、重命名等。</li>
<li>用户登录、创建等。</li>
<li>该层主要调用 dao 层提供的 API 进行数据库操作，并进行必要的业务逻辑处理。</li>
</ul>
</li>
<li><strong>middleware</strong>: 中间件层，负责处理一些通用的逻辑，例如：<ul>
<li>身份验证：<code>AuthMiddleware</code> 验证用户身份，并将用户 ID 存储在上下文中。<ul>
<li>该中间件通过检查 Cookie 中的 <code>sid</code> 来验证用户身份。</li>
<li>如果用户已登录，则将用户 ID 存储在 Gin 的 Context 中，方便后续处理函数使用。</li>
</ul>
</li>
<li>权限验证：<code>FilePermissionMiddleware</code> 验证用户是否有权限访问指定文件。<ul>
<li>该中间件检查当前用户是否有权限访问指定文件，如果没有权限则返回 403 Forbidden 错误。</li>
</ul>
</li>
</ul>
</li>
<li><strong>frontend</strong>: 前端静态资源，包含 HTML、CSS 和 JavaScript 文件。<ul>
<li>前端代码位于 <code>frontend</code> 目录下。</li>
<li>前端使用 JavaScript 调用后端 API，实现文件管理功能。</li>
</ul>
</li>
<li><strong>utils</strong>: 包含一些实用工具函数，例如：<ul>
<li><code>utils.StartSessionCleaner()</code>：定时清理过期 session。<ul>
<li>该函数启动一个 Goroutine，定时清理过期的 session 数据。</li>
<li>Session 过期时间默认为 24 小时。</li>
</ul>
</li>
</ul>
</li>
<li><strong>router</strong>: 路由配置，负责将 HTTP 请求路由到相应的 endpoint 处理函数。<ul>
<li>路由配置位于 <code>router/router.go</code> 文件中。</li>
<li>该文件使用了 Gin 框架提供的 API 进行路由注册。</li>
</ul>
</li>
</ul>
<h2 id="接口说明"><a href="#接口说明" class="headerlink" title="接口说明"></a>接口说明</h2><h3 id="登录接口"><a href="#登录接口" class="headerlink" title="登录接口"></a>登录接口</h3><ul>
<li><code>POST /login</code><br>用户登录，返回 <code>sid</code>，后续接口需在 Cookie 中携带 <code>sid</code>。<ul>
<li>请求体参数：<code>username</code>、<code>password</code>。</li>
<li>成功登录后，服务器会生成一个 session ID，并将其存储在 Cookie 中。</li>
</ul>
</li>
</ul>
<h3 id="管理接口（仅管理员）"><a href="#管理接口（仅管理员）" class="headerlink" title="管理接口（仅管理员）"></a>管理接口（仅管理员）</h3><ul>
<li><code>POST /api/user/create</code><br>创建新用户。<ul>
<li>需要管理员权限。</li>
<li>请求体参数：<code>username</code>、<code>password</code>。</li>
<li>管理员用户可以通过该接口创建新的用户账号。</li>
</ul>
</li>
</ul>
<h3 id="文件接口"><a href="#文件接口" class="headerlink" title="文件接口"></a>文件接口</h3><ul>
<li><code>POST /api/file/&#123;file_id&#125;/new</code><br>新建文件夹，<code>file_id</code> 为父目录 ID，返回文件夹信息。<ul>
<li>请求体参数：<code>name</code> (文件夹名称)</li>
<li>在指定的父目录下创建一个新的文件夹。</li>
</ul>
</li>
<li><code>POST /api/file/&#123;file_id&#125;/upload</code><br>上传文件，<code>file_id</code> 为父目录 ID，文件二进制内容放在请求体，返回文件信息。<ul>
<li>请求体参数：文件二进制数据</li>
<li>在指定的父目录下上传一个新的文件。</li>
</ul>
</li>
<li><code>POST /api/file/&#123;file_id&#125;/update</code><br>更新文件，文件二进制内容放在请求体，返回文件信息。<ul>
<li>请求体参数：文件二进制数据</li>
<li>更新指定文件的内容。</li>
</ul>
</li>
<li><code>DELETE /api/file/&#123;file_id&#125;</code><br>删除文件或文件夹。<ul>
<li>删除指定的文件或文件夹。</li>
</ul>
</li>
<li><code>POST /api/file/&#123;file_id&#125;/copy</code><br>复制文件或文件夹。<ul>
<li>请求体参数：<code>dest_id</code> (目标父目录 ID)</li>
<li>将指定的文件或文件夹复制到目标父目录下。</li>
</ul>
</li>
<li><code>POST /api/file/&#123;file_id&#125;/move</code><br>移动文件或文件夹。<ul>
<li>请求体参数：<code>dest_id</code> (目标父目录 ID)</li>
<li>将指定的文件或文件夹移动到目标父目录下。</li>
</ul>
</li>
<li><code>POST /api/file/&#123;file_id&#125;/rename</code><br>重命名文件或文件夹。<ul>
<li>请求体参数：<code>new_name</code> (新的名称)</li>
<li>重命名指定的文件或文件夹。</li>
</ul>
</li>
<li><code>GET /api/file/&#123;file_id&#125;</code><br>获取文件或文件夹信息。<ul>
<li>返回文件或文件夹的详细信息，例如：ID、名称、类型、大小、创建时间等。</li>
</ul>
</li>
<li><code>GET /api/file/&#123;file_id&#125;/list</code><br>获取文件夹下的文件和文件夹列表。<ul>
<li>返回指定文件夹下的所有文件和文件夹的列表。</li>
</ul>
</li>
<li><code>GET /api/file/&#123;file_id&#125;/content</code><br>下载文件内容。<ul>
<li>返回指定文件的二进制内容。</li>
</ul>
</li>
<li><code>GET /api/file/&#123;file_id&#125;/version/&#123;ver_num&#125;/content</code><br>下载指定历史版本的文件内容。<ul>
<li>返回指定历史版本的文件二进制内容。</li>
</ul>
</li>
<li><code>GET /api/file/&#123;file_id&#125;/versions</code><br>获取文件的版本历史列表。<ul>
<li>返回指定文件的所有历史版本列表。</li>
</ul>
</li>
</ul>
<h2 id="数据库表结构"><a href="#数据库表结构" class="headerlink" title="数据库表结构"></a>数据库表结构</h2><ul>
<li><p><strong>users</strong>: 存储用户信息。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `users` (</span><br><span class="line">    `id` <span class="type">integer</span> <span class="keyword">PRIMARY</span> KEY AUTOINCREMENT,</span><br><span class="line">    `username` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">UNIQUE</span>,</span><br><span class="line">    `password` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `created_at` datetime,</span><br><span class="line">    `updated_at` datetime</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
<li><p><strong>files</strong>: 存储文件和文件夹信息。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `files` (</span><br><span class="line">    `id` <span class="type">integer</span> <span class="keyword">PRIMARY</span> KEY AUTOINCREMENT,</span><br><span class="line">    `user_id` <span class="type">integer</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `parent_id` <span class="type">integer</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `type` <span class="type">integer</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>, <span class="comment">-- 0: 文件夹, 1: 文件</span></span><br><span class="line">    `size` <span class="type">integer</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `hash` <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line">    `version` <span class="type">integer</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">1</span>,</span><br><span class="line">    `created_at` datetime,</span><br><span class="line">    `updated_at` datetime,</span><br><span class="line">    `deleted_at` datetime</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>后端开发</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>后端开发</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>读写锁的实现及底层原理</title>
    <url>/2025/09/19/%E8%AF%BB%E5%86%99%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>Go 语言中的读写锁（<code>sync.RWMutex</code>）是一种同步原语，用于控制多个 Goroutine 对共享资源的并发访问。读写锁允许多个 Goroutine 同时进行读操作，但在写操作进行时，所有其他 Goroutine（包括读操作和写操作）都被阻塞。理解读写锁的实现及底层原理有助于高效地使用它。</p>
<h3 id="1-sync-RWMutex-的基本结构"><a href="#1-sync-RWMutex-的基本结构" class="headerlink" title="1. sync.RWMutex 的基本结构"></a>1. <strong><code>sync.RWMutex</code> 的基本结构</strong></h3><p><code>sync.RWMutex</code> 是 Go 标准库中的一个结构体，它主要由以下部分组成：</p>
<ul>
<li><strong>w</strong>：表示写锁的状态和数量。写锁是互斥的，也就是说，同时只能有一个 Goroutine 获得写锁。</li>
<li><strong>writerSem</strong>：用于阻塞等待写锁的 Goroutine。</li>
<li><strong>readerSem</strong>：用于阻塞等待读锁的 Goroutine。</li>
<li><strong>readerCount</strong>：当前持有读锁的 Goroutine 数量。</li>
<li><strong>readerWait</strong>：表示当前有多少 Goroutine 在等待写锁被释放。</li>
</ul>
<h3 id="2-读写锁的基本操作"><a href="#2-读写锁的基本操作" class="headerlink" title="2. 读写锁的基本操作"></a>2. <strong>读写锁的基本操作</strong></h3><h4 id="读锁（RLock-和-RUnlock）"><a href="#读锁（RLock-和-RUnlock）" class="headerlink" title="读锁（RLock 和 RUnlock）"></a>读锁（<code>RLock</code> 和 <code>RUnlock</code>）</h4><ul>
<li><p>RLock</p>
<p>：获取读锁。</p>
<ol>
<li>如果当前没有 Goroutine 持有写锁，则 <code>readerCount</code> 增加，允许当前 Goroutine 获得读锁。</li>
<li>如果有 Goroutine 持有写锁，则当前 Goroutine 被阻塞，直到写锁被释放。</li>
</ol>
</li>
<li><p>RUnlock</p>
<p>：释放读锁。</p>
<ol>
<li><code>readerCount</code> 减少，当最后一个读锁被释放时，检查是否有等待写锁的 Goroutine。如果有，则唤醒其中一个。</li>
</ol>
</li>
</ul>
<h4 id="写锁（Lock-和-Unlock）"><a href="#写锁（Lock-和-Unlock）" class="headerlink" title="写锁（Lock 和 Unlock）"></a>写锁（<code>Lock</code> 和 <code>Unlock</code>）</h4><ul>
<li><p>Lock</p>
<p>：获取写锁。</p>
<ol>
<li>检查是否有其他 Goroutine 持有读锁或写锁，如果有，当前 Goroutine 被阻塞。</li>
<li>否则，标记写锁已被持有，并阻止其他 Goroutine 获得读锁或写锁。</li>
</ol>
</li>
<li><p>Unlock</p>
<p>：释放写锁。</p>
<ol>
<li>解除写锁标记，检查是否有等待的读锁或写锁 Goroutine，并根据优先级唤醒合适的 Goroutine。</li>
</ol>
</li>
</ul>
<h3 id="3-底层实现原理"><a href="#3-底层实现原理" class="headerlink" title="3. 底层实现原理"></a>3. <strong>底层实现原理</strong></h3><h4 id="写锁的获取与释放"><a href="#写锁的获取与释放" class="headerlink" title="写锁的获取与释放"></a>写锁的获取与释放</h4><ul>
<li>写锁是通过修改 <code>w</code> 来实现的。如果 <code>w</code> 是负数，表示当前已经有 Goroutine 持有写锁，此时新的写操作会被阻塞。</li>
<li>当一个 Goroutine 获取写锁时，它会使 <code>w</code> 的值变成负数，并阻止其他读写操作。</li>
<li>释放写锁时，会将 <code>w</code> 设为 0，解除对后续操作的阻塞。</li>
</ul>
<h4 id="读锁的获取与释放"><a href="#读锁的获取与释放" class="headerlink" title="读锁的获取与释放"></a>读锁的获取与释放</h4><ul>
<li>当没有 Goroutine 持有写锁时，<code>readerCount</code> 可以直接增加，表示读锁已被获取。</li>
<li>如果有写操作在等待，<code>readerCount</code> 不会增加，并且当前 Goroutine 会被阻塞。</li>
<li>读锁的释放通过减少 <code>readerCount</code> 来实现。如果 <code>readerCount</code> 变为 0，且有写锁在等待，写操作会被唤醒。</li>
</ul>
<h3 id="4-锁的升级与降级"><a href="#4-锁的升级与降级" class="headerlink" title="4. 锁的升级与降级"></a>4. <strong>锁的升级与降级</strong></h3><ul>
<li>在 <code>sync.RWMutex</code> 中，不支持锁的升级（即持有读锁时尝试获取写锁）和降级（即持有写锁时尝试获取读锁）。这是为了避免死锁。</li>
<li>如果一个 Goroutine 持有读锁后又尝试获取写锁，会导致死锁，因为写锁的获取会等待所有读锁释放，而读锁的释放在等待写锁的获取，这样两个操作互相等待。</li>
</ul>
<h3 id="5-使用建议"><a href="#5-使用建议" class="headerlink" title="5. 使用建议"></a>5. <strong>使用建议</strong></h3><ul>
<li><strong>读多写少</strong>：<code>sync.RWMutex</code> 适用于读操作远多于写操作的场景，这样可以提高并发性能。</li>
<li><strong>避免锁升级</strong>：避免在持有读锁时尝试获取写锁，因为这可能导致死锁或阻塞。</li>
</ul>
<h3 id="6-性能注意事项"><a href="#6-性能注意事项" class="headerlink" title="6. 性能注意事项"></a>6. <strong>性能注意事项</strong></h3><ul>
<li>读写锁比普通的 <code>Mutex</code> 更复杂，因此在读操作不多的情况下，可能会带来额外的性能开销。</li>
<li>频繁的读写锁竞争可能会导致 Goroutine 被频繁阻塞和唤醒，影响性能。因此，需要根据实际场景选择合适的锁类型。</li>
</ul>
<p>读写锁提供了一种有效的方式来管理共享资源的并发访问，特别是在读操作远多于写操作的情况下。理解其底层原理有助于更好地利用其优势，同时避免常见的陷阱。</p>
]]></content>
      <categories>
        <category>后端开发</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>后端开发</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>高并发缓存系统</title>
    <url>/2025/07/15/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%93%E5%AD%98%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h2 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h2><p>github地址： <a href="https://github.com/jianingdai/my_cache">https://github.com/jianingdai/my_cache</a></p>
<h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><p>在项目目录使用以下命令可以进行测试运行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">go run test.go</span><br></pre></td></tr></table></figure>



<p>项目实现了基础功能，以后可以进一步开发定制化功能</p>
<p><strong>目前只开发基础功能和接口可供其他相关项目使用相关接口或者完善现在还处于一个demo状态，待未来可以慢慢完善扩增。</strong></p>
<h2 id="项目描述"><a href="#项目描述" class="headerlink" title="项目描述"></a>项目描述</h2><p>实现一个高性能的内存缓存系统，支持多种数据结构、过期策略、持久化等功能。</p>
<p><strong><del>仿redis</del></strong></p>
<h2 id="功能要求"><a href="#功能要求" class="headerlink" title="功能要求"></a>功能要求</h2><ol>
<li><strong>数据结构</strong>：支持字符串、列表、哈希表、集合</li>
<li><strong>过期策略</strong>：TTL、LRU、LFU等多种过期策略</li>
<li><strong>持久化</strong>：支持AOF和RDB持久化</li>
<li><strong>主从复制</strong>：支持主从同步</li>
<li><strong>事务支持</strong>：支持原子性操作</li>
<li><strong>集群模式</strong>：支持数据分片和故障转移</li>
<li><strong>监控统计</strong>：提供详细的性能指标</li>
</ol>
]]></content>
      <categories>
        <category>后端开发</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>后端开发</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
</search>
